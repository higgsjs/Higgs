Conference deadlines:
- DLS 2013      June 8, 2013
- VMIL 2013     ~August 2013
- CGO 2014      ~September 2013
- CC 2014       ~October 2013
- PLDI 2014     ~November 2013
- VEE 2014      ~November 2013

TODO: give this project more lovin'! Improve various aspects! Blog!

------------------------------------------------------------------------------

TODO: think about special monitoring instructions
- instrs to allocate type monitors
  - add TypeMon ptr to interp ref list
- union based on values

TODO: System to register TypeMon refs
- Type objs from classes
- Type objects need to be destroyed/finalized (to destroy GC roots)

TODO: log function argument types for most called funs?
- Big dump of all functions, call count, types?

TODO: monitor function arguments in call instructions
- Lazily create monitor objects
- Destroy monitors in collectFun

TODO: update heap refs in type sets after GC
TODO: destroy dead type sets after GC

TODO: allocate class ids?
- nextClassId var in interpreter?
- Need instr to allocate a class id as well
- class_alloc called in only 2 places
- Could add an opNewClass to take care of this

TODO: make sure global obj ptr is updated when global obj is extended
- Trigger GC?

TODO: optimize IsTypeOp, compare ops in conjunction with if_true
- Log optimized instances
- Need to optimize in conjunction with if_true
- Bool op followed by if_true using output of bool op
- Could include the if_true compilation into the boolean compilation if right
  afterwards, skip the if_true compilation
- Test if own value is dead after if_true, if so, don't produce

TODO: improved interpreter frame spill scheme
- Map of call instrs to spill functions
  - special extern(C) function, called by interpreter
- Need to spill if
  - GC, stack traversal
  - exception, stack unwinding
- Pros
  - Ordinary function calls will not cause type spilling
  - No need to write 0 when writing type on type stack
- ISSUE: return address, multiple versions
  - Could be calling a JIT function from multiple points
  - Can't have spilling associated with one single return points
  - Need special JIT return address structure
    - Spill fun
    - Interp call cont
    - JIT fast entry point
- Is this needed right now, is this orthogonal to inlining?

TODO: can we use one less scratch reg?
- Delay until type tags integrated
- Might need more scratch regs as refactorings progress

TODO: benchmarking (performance testing) JS script
- benchmark.js
- should do multiple runs (parameterizable numRuns?)
- use load command, list of benchmarks
- try to make it compatible with V8 as-is

TODO: IR-level optimizations?
- Basic arith ops, simple const prop?
- Jump to block that jumps
- Redundant moves, use original value
  - Must prove move is useless to remove

TODO: stack-frame compaction
- Need liveness info if doing OSR
  - Move only live values to new slot
  - Two live values can't map to same slot

TODO: disable temporary compFun in callFun

TODO: basic OSR if function is on top of the stack











[DONE] TODO: test inlining with functions not currently on stack (pre-OSR)
- funOnStack
- ISSUE: all functions are on the stack when compiled!
- For now, temporarily call compFun in function call bit?

[DONE] FIXME: rt_sub used for negative numbers in JS layout computation!
- Look at irString, $rt_clos_ofs_cell
- Fix in parser

[DONE] FIXME: inlined rt_sub is compiled all wrong???
- Move instruction doesn't copy type tag properly?
- Disabling gen_move fixes problem
- Immediately after move, is_int32 fails
- IsTypeOp doesn't account for known type tags

[DONE] FIXME: segmentation fault on Higgs init
- JIT is probably calling valIsString with the wrong stack frame size
- Optimized call based on pre-inlining size

[DONE] TODO: JIT string printing mechanism

[DONE] TODO: test inlining with the JIT off first?
- Tests pass without JIT and without inlining
  inlining $rt_setCellVal(22E120) into clos(2380CD)
- invalid move dst in clos() function
    $4 = set_undef
    move $4
    jump => call_cont(23812C)
- Call with no return value unhandled

[DONE] FIXME: segfault when executing fun w/ inlining
inlining $rt_obj_ofs_type(11AC) into $rt_obj_set_type(11D6)
- Arguments not copied right, inverted order

[DONE] FIXME: segfault during JIT compilation

[DONE] FIXME: pointer is not pointer type in load op, failing to load from clos ptr

[DONE] TODO: implement size limit in inlining test

[DONE] TODO: funOnStack
- Just scan the stack for RAs, very simple

[DONE] TODO: go over inlining implementation, inspect code

[DONE] TODO: implement inlining
- Maintain original call cont blocks
- Keep track of who's inlined at each call site, for exception stack unwinding
  - Map of call instrs to lists of functions
- Produce mapping of pre-inlining stack slots to inlined slots, for OSR
  - Map of stack indices to stack indices

[DONE] TODO: change function layout so function pointer has fixed offset
- Get offset of word slot 0?
- on alloc class, add numRsvProps parameter

[DONE] TODO: fix closure ctor_class issue

[DONE] TODO: IR, i64 tag, support

[DONE] TODO: IR instr renaming for convenience
- is_i32, is_f64, ...
- set_i32, set_f64, set_str, ...

[DONE] FIXME: crypto-aes, run-time error: undefined base in property read
- array w in KeyExpansion should have been initialized with array, is not
- Likely, failing because loop index is not integer

[DONE] FIXME: crypto-aes, invalid operand 2 type in op "auto r = x * y;" (int32)
- Investigate, create failing unit test
- Problem with new Array, size resulting from division is a float

[DONE] TODO: blog
- DConf, impressions
- method JIT, versioning
- talk slides
- forum.dlang.org/group/digitalmars.D

[DONE] TODO: fix loop label segfault

Publishing: figure out their litmus test. For some, numbers, for some it's
proofs, make sure you have that
- You're selling something, try to have a grand narrative
- Why it's hard, why it's interesting, why is it novel
- Papers you *should cite*, how does it compare
- Try to cite the reviewer...?
- Cohesion, line of thought, don't want sections to look like afterthought

Michael: try to do these optimizations by hand on some benchmarks, where will it pay off?
- I wasted a lot of time trying to do clever things I thought would matter

Michael: constant folding, copy propagation, try to predict benefit? *****

Michael: either work backwards or you backtrack
- Or do it greedily backwards?

Shu: flow problem. Want to optimize CFG to reduce joining work.
- Attach weight to individual nodes based on amount of work
- How much work did we save?
- Model performance characteristics

Problem: add operator, overflow case... Don't want this automatically compiled
- Whole other loop path for doubles?

Michael: don't want duplication to propagate all the way through
- Merge as early as possible
- Metric of benefit vs cost of duplicating a block
- If merging from two different types, we get boxing overhead

Max: Incremental duplication may be necessary... Prevents impossible/useless
duplications to some extent. Otherwise duplication can propagate to successors.
- Similar problem to trace trees

Michael: if you duplicate a block, what is the probability you'll have to
duplicate its successors

Michael: tail duplication has been around for a long time, lots of literature

Michael: would be interesting to try and predict if tail duplication will help
at a specific point

Michael: come up with a metric
- Now way of knowing tail duplication will pay off in the future
- Has a cost, could afford it if it pays off

Shu: split (terminology?)

Michael: profile in an interpreter
- Backwards flow analysis, I need this type info?
- I would like this not to be polymorphic
- Would like this to be an int

Shu: tail duplicate until things become monomorphic
- Drives the duplication

Michael: compile without duplication, monitor hot spots

Shu: don't version at some blocks?
- Re-merge if useless?

[DONE] TODO: start sketching out ir/inlining.d
- inlineCall?
- add comments to flesh out process

[DONE] TODO: allocate stacks with malloc, NO_SCAN

[DONE] TODO: use GC.BlkAttr.NO_SCAN when allocating heap, link table

[DONE] FIXME: return with no semicolon causes parse error
- Create failing parser test

Problem: unwinding stack frames on throw or before calls...
- Must setup stack frame as multiple frames before each exiting call?
  - Correct stack height
  - Write return addresses
  - Spill values/types in the proper slots
- Could save on cost of having to spill types too?
- Need to inflate if exiting to interpreter
  - call to interp
  - unsupported behavior
  - unsupported instruction
- Exceptions need to be able to make the caller inflate
  - Probably want a special extern(C) function to inflate/spill stack frames?
  - Map of call instrs to inflate function
- We can still have interpreter entry points in the middle of functions as before!
  - But these will go to non-inlined versions of functions
  - Don't place entry points in the inlined functions, only at top level
  - Not a huge deal
- Functions with inlining can have an internal stack frame size different from numLocals
  - If we optimize an inlined function and remove temps/vars, need to somehow know
    what temps map to which original function temps
    - could use special pseudo-instr to manage this
    - plase pseudo-instr before possible bailout points, function calls

[DONE] TODO: think about dynamic block/version compilation further
- What would the infrastructure look like?
  - Compile to an assembler, write to a code block
  - ol assembler used for interp entry points, interp fallback
- No longer need a queue of things to compile!
  - Blocks, entry points compiled immediately, until branch occurs
- Need an out of line code block
- Contexts need to account for inlining

Dynamic block compilation...
- Could dynamically profile branches/calls on stubs, eventually compile
- Need to manage a code block and append to it
  - Could simply preallocate to start
- Need to keep track of what jumps to what? Only if we need to displace?
- Incremental compilation of functions
- If compiling and branch occurs, create interp fallback stub, install profiling counters
  - First stub to trigger compilation gets concatenated?
  - Could have already compiled multiple loop iterations?
    - No, because you stopped at the branch!
- Inlining, could do it in the backend?
  - Yes, but we need some sort of lazy move, special alloc state
  - Might be able to recompile calls after some counter hits a threshold
- Issues:
  - Suboptimal code, reoptimization more difficult, but not impossible
  - Jumps to movable code, need to place and rewrite jump

Dynamic compilation cons:
- complicates the backend (N level contexts when inlining?)
- possibly reduces optimization opportunities
- hard to reoptimize code
- need to keep around lists of block versions for future compilations
- can't compute total frame size for inlining ahead of time...
  - would need to reserve space ahead of time

Dynamic compilation pros:
- may save compilation time
- get better profiling data
- avoids invalidating on stub hit
- can try going along with an inlining and back out of it?

[DONE] Inlining heuristics:
- max allowable numLocals of the callee
- max allowable number of blocks in the callee
- total caller + callee size
- total caller + callee locals
- IBM paper considers inlining based on profiles at the callee
  - How many callers, how frequently
  - Generates inlining requests for next compilation
  - Works based on call edge density/distribution, relative method hotness

[DONE] TODO: read empirical inlining paper, note insights

[DONE] TODO: look at IR for getPropIdx... Can we benefit from type info at all?
- Has a ton of calls to various methods
- some eq_const, eq_refptr
- Benefit would probably be fairly small, but inlining will help a lot

[DONE] TODO: functions, remove closure caching, slow offset comp path

[DONE] TODO: BOOL_OUT flag on instructions

[DONE] FIXME: v8/splay segfault with JIT
- Does lots of GC, could be related
- Is this fast enough to include in unit tests? Can we make it faster?
- Note: the GC happens increasingly fast! heap space is exhausted

[DONE] TODO: don't init temps to undef, only local variables
- numTemps, numVars?

[DONE] FIXME: i++ does get_global "i" twice???
function () { return i++; }
- confirmed, first value not used
- Problem is we want the value pre-incrementation

[DONE] FIXME: bug with 3d-raytrace
run-time error: undefined base in read of property "intersect"
Scene_prototype_blocked ("programs/sunspider/3d-raytrace.js"@244:27)
- all unit tests pass, make new regress_raytrace test
- iteration index i becomes null
- i is a global variable! some kind of type corruption happening
- problem is with set_global not using type info properly

[DONE] FIXME: type spilling
- Should only write a type when spilling a value AND the type is not in sync
- What if we're writing a dynamic type, e.g.: move
  - Should write 0 value on the word stack
- BUT, what if we have a memory operand?
  - Might still know the type, not write it to the stack...
  - If we're writing a different type and not in sync, write it to the stack?
- Problem: copying types during ret and call is cumbersome
  - getTypeOpnd, pass scratch reg if mem reading is needed?
  - Need to add stack offset param (in case we pushed more stack space!)
  - default is int32_t.max

[DONE] TODO: try to optimize global prop access, remove offset recomputation

[DONE] TODO: make setOutType change type state
- Should result in more versions, but still working code

[DONE] TODO: simple `make install` target

[DONE] TODO: add typeState to CodeGenState

[DONE] TODO: write adversarial GC/JIT test
- Big loop
- Mix many obj refs & integer calculations?
- Branching

[DONE] TODO: improve register spilling, defaultFn, better usage of liveness info

[DONE] TODO: add a V8 benchmark to make test, more sunspider tests?

[DONE] TODO: re-implement return in JIT

[DONE] TODO: usesThis, usesClos, can optimize function calls further

[DONE] TODO: type flags, type state definitions
- Known type bit
  - If not known, it's stored on the stack
- In sync with stack bit
  - if we test a type, the type we now know is what's on the stack
  - if we spill a type tag, stack becomes in sync
  - if we set a type, and it's the same as before, flag unchanged
- 5 bits for type tag itself, if known

[DONE] FIXME: function calls
- Selectively spill non-args in regs before the call
- Everything that's live after the call must be spilled
- Keep non-live flag for spilling?

[DONE] TODO: try eliminating init maps
- Don't store on function, don't use in GC
- Can init less slots if we only worry about uninitialized variables
- Refactor GC to init/reset stack to 0
- Temporarily: when setting a type, write 0 value
  - Writing 0 in get_global prevents GC crash

[DONE] TODO: check if 0 when setting type fixes the GC bug w.r.t. calls/spills
- Crashes during GC

[DONE] TODO: jit/ops.d

[DONE] TODO: default state, only args should be on stack

[DONE] FIXME: jit.d(485): argument is neither in a register nor on the stack
- Problem is with rt_typeof, used in jit/loop_new
- Log the function we're actually compiling
  $1 = set_null
  $3 = eq_refptr $10, $1
  if_true $3 => if_true(A368), if_false(A36B)
$3 is in fact live after eq_refptr
- eq_refptr uses the interp fallback
  - will not map its value as being on the stack!
  - could change interp fallback to fix this?

[DONE] TODO: bitwise-and, must still be missing instrs for lt
- using default for: $7 = lt_i32 $15, $16 ($rt_lt(27EA))

[DONE] TODO: fix set_global
- Bug with type tags? Should get true, get integer 1, integer type tag

[DONE] TODO: implement/fix get_global

[DONE] TODO: pushRegs, popRegs

[DONE] TODO: revise gen_call
- Will test the limits of the reg alloc

[DONE] TODO: implement reg alloc for simple instructions
- add, mul, and
- get_global_obj
- load

[DONE] FIXME: load with refptr gets bus error
- Unaligned memory access or wrong address???
- Could we be, by using int32 offsets, having invalid hi reg values?
  - If so, problematic!
  - There's your problem...

[DONE] FIXME: ; if_true $4 => if_true(32D6), if_false(32E2)
- Jumping to block with wrong reg alloc

[DONE] TODO: exit to interpreter, should spill regs appropriately

[DONE] TODO: revise defaultFn, might need to save allocatable regs

[DONE] TODO: spill logic

[DONE] TODO: make getArgOpnd have a loadVal argument, load to reg
- Assert not bumping output val

[DONE] TODO: make getOutOpnd try to load to reg if not bumping input

[DONE] TODO: make versioning system work without actual versions or reg alloc
- Always the same state, one version

[DONE] TODO: think about block version **state** objects
- State evolves as we go through blocks
- Should be a struct so we can assign it simply
- Need list of block versions, labels with associated states
- For now, ignore type tags, keep them on the stack ***
  - Focus on reg alloc only
- Need a map of blocks to state/label pairs
  - getBlockLabel(block, state)
  - Try to find a match, if none, produce one

[DONE] TODO: integrate level 0 FFI functionality

[DONE] TODO: interference analysis, coloring
- Go over basic blocks, count number of instrs where values interfere
  - Add counts to edges
- Color slots with registers so as to minimize conflicts
  - Use greedy coloring algorithm
  - If register must be used, pick one from neighbor with least contention
- Also color with XMM registers for FP values and spills

[DONE] TODO: JIT-to-JIT call
- fast jit entry points on blocks

[DONE] TODO: liveness analysis for stack slots
- Returns map of instrs to sets of live slots after the instr
- Need to know if we can kill a value after an instr

[DONE] IDEAS: Basic block versioning
- Can version based on spill status, type, known constant value
- Instr flow functions give us type info
- Type checks give us extra type info
- Checking if something is a given constant gives us info
  - e.g.: check type of receiver before inlined call
- Can avoid generating paths that haven't occurred in practice
  - Jumping to non-existing path needs to bailout to interpreter, invalidate function
- Blocks with 0 exec count are stubs
- If IRFunction is transformed for inlining, non-inline paths will have 0 exec count to begin with
- If known constant value, can try generating new version
  - If too many versions already, try to match existing versions more coarsely

[DONE] IDEAS: Versioning JIT
- Generalize versioning to per-version pre-conditions
  - Generic/catch-all version has no conditions required
  - Type requirements of various granularities can be encoded as conditions
- Count interpreter cycles per call to grant versioning/optimization/inlining budget
  - Functions that take long to execute should get more!
- Monitor call args to decide how to version
  - Can specialize all the way down to constants
- Can transform loops into tail calls
  - Optimize the tail

[DONE] TODO: implement callee-guessing
- Map of call instrs to lists of callee fptrs with frequencies
  - Store on the caller function
- Test fptr and not closure ptr

[DONE] TODO: mid-loop entry
- Create entry points for loop headers
- Bitwise and can't be optimized without this

[DONE] TODO: basic block stubbing
- Code should be out of line
- Invalidates code block and all entry points for function
  - Implement through C function
- Run unit tests

[DONE] TODO: implement some of the ops in rt_and
- is_int32, and_i32

[DONE] TODO: make basic method JIT work, use only scratch regs for now, no reg alloc
- Implement jump, if_true
- Implement initial call/ret by bailing out to interp
  - Generate export for continuation target
- Test on bitwise-and to start
- Try unit tests and commit method JIT v0

[DONE] TODO: JIT compilation & entry hooks in interpreter
- If block reaches target exec count, compile its function
- Will automatically work for loops too

[DONE] TODO: secondary entry points for fn returns
- Function to generate the code for an entry point
- Create an exported label? Need to wait until code is assembled to set
- Map of blocks to exported labels
- This code should be out of line ***
- getEntryPoint
- Eliminate initial entry point, just get the entry point for the entry block!

[DONE] ISSUE: you don't know if the caller was running JITted code?
- If calling interpreter function, have to bail out to interpreter first, so that's OK
- If doing JIT-to-JIT call, and then we bail out to the interpreter...
  - KISS: when you do any call, spill the locals

[DONE] TODO: begin compiling basic blocks?
- getBlockLabel?
- stack overflow warning

[DONE] TODO: store CodeBlock pointer on compiled function

[DONE] TODO: solve first problem: how do we enter, how do we bailout
- To enter, call entryFn on some basic block
  - Saves regs, does required prep
- To bailout, pop regs, save wsp, tsp, do return to interpreter
- For now, can have generic bailout label in code gen context

[DONE] TODO: plan register mapping with fixed regs, scratch regs, allocatable regs

[DONE] TODO: read SELF customization article

[DONE] TODO: research procedure cloning, dynamic languages
- Find MATLAB versioning article
  - MaJIC, precompiles version

[DONE] TODO: can we generalize versioning, dispatch based on arbitrary conditions?
- types of class properties involved in parameters (specific type sets)?
  - Is this effective? Avoids invalidation
  - Might have lots of type sets involved?
  - Can disable entry to function with boolean flags, basically
- How granular? can dispatch all the way down to constant values
  - Profiling argument types would make sense here
  - If almost always constant, take advantage
- Heuristic: functions with longer execution time (in interpreter instrs)
  should get more versioning budget/granularity
  - Re-add interpreter cycle counter?
- Should generalize string down to pre-conditions **********
  - Generic/catch-all version has no conditions required ******
  - Type requirements of various granularities can be encoded as conditions
- Start by implementing generic method-based compiler

[DONE] TODO: think about method-based compilation
- Interp fallback
  - Dump stack slots to interp stack
- Mid-loop interp jump
  - Special entry point that jumps into loop (outer loop only?)
  - Can have special prelude code
- Fallback w/ inlining
  - Need to keep track of frames pushed, locals for each frame
  - When inlining, add special call/ret annotation instructions
    - Keeps track of frames pushed, slots added
- Join w/ inlining
  - Join at loop header, not in the middle of inlined calls
- Speculative inlining
  - Can use interp fallback if incorrect guess, or have 2 paths
  - Default path does generic call
- Can prealloc space for inlined frames on call to compiled function
  - When doing inlined call, avoid copying args until write occurs
- Calling non-inlined function
  - Leave extended stack frame as is
  - Put calling instr on stack, as normal
  - Callee checks who caller is when returning, can find actual RA
  - May need to return to interpreter to do call

[DONE] TODO: add support for regexp in parser
var re = /pattern/flags
var re = new RegExp("pattern", "flags");
flags: i, g, m, y

[DONE] TODO: 3d-cube has a horrible trace exit count, why?
- Is it because traces are limited in length? Is it because of recursion?
- MMulti trace has 513 blocks
    root trace entry count: 1160855
    sub-trace entry count : 624093
    trace loop count: 241408
    trace exit count: 919447
- Increasing max trace length doesn't improve things
- getPropIdx isn't the problem
- Low trace count and super long traces doesn't help
- The trace is legitimately very long...

[DONE] TODO: compute trace completion rates?
- increment interp counter on trace start, other counter on final trace completion
- counter for interpreter fallback rate ***
- jit_stats
- Loops? Increment on each trace entry

[DONE] TODO: blog
- Traces, sub-traces
- Stack frame init maps
- Updated perf numbers
- All SunSpider/V8 benchmarks except regexp working, thanks to Tom Low
- FFI
- eval

[DONE] FIXME: segfault on ./higgs programs/sunspider/bitops-bits-in-byte.js 
- Doesn't crash with no JIT
- jump to self at block 30/169 in sub-trace of bits-in-bytes
- Root node has no trace object???? wtf
  - root not marked as a trace start
  - not calling record on it
- not setting root node properly in sub-traces

[DONE] TODO: look at more missing instrs for nsieve-bits
- eq_i8
- does this make sub-traces faster? yes
- crash in sunspider tests, signal 11

[DONE] TODO: review traces and sub-traces, do they make sense?
- long traces probably due to loops in runtime, e.g.: getPropidx
- does allowing longer traces result in slowdowns?
- increasing max trace length makes it slower

[DONE] TODO: jit_dumpinfo

[DONE] TODO: test JIT on earley-boyer
- check memory usage: 2.3%
- sub-traces aren't making much difference

[DONE] TODO: try tweaking trace/sub-trace constants/heuristics
- use jit_nosubs for performance comparisons
- 3d-raytrace is faster with sub-traces
- Tweaking inconclusive, would ideally need automation

[DONE] TODO: jit_disable, jit_dumpasm, jit_nosubs

[DONE] TODO: increment block idx only for trace headers

[DONE] TODO: add/enable more sunspider benchmarks in unit tests

[DONE] FIXME: gc/stackvm crashes with JIT, uses GC
- Crashes during sub-trace compilation

[DONE] FIXME: 3d-raytrace segfaults
- jumps to self too early?

[DONE] FIXME: stack depth issues in sub-traces
- Not keeping track of call stack and call stack depth properly
- Sub-trace needs this initial call stack
- Trace start node needs to start with correct stack depth

[DONE] FIXME: make sub-traces belong to parent trace object, not blocks

[DONE] TODO: make it so sub-traces are part of the root trace tree?
- Do we really need a trace pointer in TraceNode objects, is rootNode ok?

[DONE] TODO: Pass a copy of the CodeGenCtx to the sub-trace?
- Could be a big object
- Can we retrace steps from the root trace? Expensive
  - Expensive but necessary?
  - Could have hundreds of blocks in a main trace
  - Still OK if ctx is relatively small

[DONE] TODO: implement sub traces from if
- If threshold reached
  - call function that begins tracing from block
  - jump to interpreter
- Pass address to patch back for direct jump to trace
  - Write jump directly over a reserved block of nops, 10 + 2 bytes
  - Can reserve 12 bytes, use an assembler to get the proper bytes

[DONE] TODO: Trace node currently stores root node pointer
- Could store trace object pointer instead
- Trace object can store:
  - root trace node
  - parent trace object
  - parent jump address
- Creating the trace object can create the root trace node?

[PASS] TODO: loop to loop, stop at inner trace?
- Doesn't seem to improve performance

[DONE] TODO: keep track of calls/returns during tracing, avoid wasting time?
- Will avoid wasting a lot of time in function traces, super long traces
- Simplifies logic of JIT itself
- Should speedup 3d-cube, 3d-raytrace

[DONE] TODO: better callee-guessing in call

[DONE] TODO: ctx.stopTrace

[DONE] FIXME: 3d-cube, interpreter stack underflow, other crashes
- Caused by trace length being capped? No
- access-binary-trees, multiple levels of recursion in
  run-time error: undefined base in property read
  crash after compiling trace in $rt_getProp(27F5)
- Try disabling global prop access: no
- Disabling ret logic seems to fix it...
- Problem comes from default call/ret implementation not stopping trace

[DONE] FIXME: enable jump to self

[DONE] TODO: remove segment extension code, compile traces from trace nodes

[DONE] FIXME: in nsieve-bits, recording many many traces at rt_not, never compiling

[DONE] TODO: move IIR static ctor to ir/iir.d

[DONE] FIXME: seemingly unrelated blocks in traces...
- Jump into a trace while recording, end up anywhere

[DONE] TODO: implement trace node updating during tracing
- compTrace should take a TraceNode argument, construct the block list
- add a trace node pointer to the interp class?

[DONE] TODO: implement TraceNode class, jit/trace.d
- Node should have count, associated block, depth, tree root, list of children

[DONE] TODO: implement system to constrain trace starts to specific blocks
- Need to label trace start blocks
- Blocks need counter + trace start flag + trace object pointer

[DONE] TODO: refactor global return code into parser
- Useful for eval

[DONE] TODO: implement global eval
- eval_str instruction?

[DONE] TODO: rename segment object to trace, compSegment to compTrace, etc.
- Do grep for Segment/segment, to match comments

[DONE] FIXME: GC bug after multiple runs after load?
- Try to replicate with unit test
  - Hard to achieve, too much code
- rule_loop is the function that was destroyed then called *****
  - appears to be a local function, recreated
  - there are 3 different rule_loop functions...
    - 2 of them transitively added, last one destroyed
- How can we not find one of the rule_loop functions transitively?
- If we GC on global scope... Most functions are destroyed
  - Only a problem if first run occurs first
  - Obviously poor traversal, poor finding of function references
- The problem must be that our transitive function adding is imperfect..
  - Does not implement a proper DFS

[DONE] TODO: ASMComment pseudo-instruction?
- Have function to add comments when dumpasm is enabled?
- Will allow better understanding of asm output

[DONE] TODO: rename JITInstr to ASMInstr

[DONE] TODO: prepare presentation for Friday 15th March
- Explain ideas in more detail
- Elaborate on incremental segment extension
- Is counter=1 like regular tracing?
  - Not exactly, still need multiple passes through segment to extend

[DONE] FIXME: earley-boyer, call to non-function

[DONE] TODO: try self-patching mechanism for optimized global object access?
- cache based on global object address?
- can a load patch its own 32 bit offset???
- flesh out ASM code

[DONE] TODO: IP-relative addressing
- Should be able to specify label, but also extra disp
- Unit asm code execution

[DONE] TODO: refactor instruction operands
- Array of fixed size in instr
- Pointers to subclasses of X86Opnd

[DONE] TODO: IntData JITInstr
- Num bits, value

[DONE] TODO: optimize JIT interp fallback, now have mayGC, isCall
- Test with earley-boyer

[DONE] FIXME: GC during load(), not a proper function call! can't traverse stack
- unit test this, gc/load.js?

[DONE] TODO: remove stack init code from JIT

[DONE] TODO: make interp no longer init stack slots in function calls

[DONE] TODO: refactor GC to use init maps when traversing stack
- Make sure unit tests, earley-boyer still work fine!

[DONE] FIXME: ip is moved before instr is executed...
- Could probably change this with current design

[DONE] TODO: mayGC opcode flag
- Needed by heap_alloc, set_str, set_global, get_global

[DONE] TODO: implement init map system
- bug, seems to be caused by code after branch
- stop adding instrs after branch?

[DONE] FIXME: JIT bug causing segfault in earley-boyer
- Crashes in segment in $rt_class_get_cap(1394), len: 1
- Disabling call and ret JIT instrs does not fix it
- String table gets extended, class gets extended, but no GC yet
    $2 = get_global "$rt_class_ofs_cap", 177
    $1 = get_global_obj
    $3 = call $2, $1, $11 => call_cont(2D5A)
- Could it be get_global? Try disabling?
  - Works without get_global!

[DONE] TODO: optimize set_str

[DONE] TODO: try optimizing/specializing return sequence

[DONE] FIXME: gc causes crash during trace?
- Could the GC be invalidating something?
- Collecting the current function? No
- Segment causing crash is in array_push
  - Loops over $argc
- not crashing in get_arg, set_str, heap_alloc, load
- bug caused by getString in gen_call causing gc!

[DONE] TODO: can we have traces join themselves, e.g.: bitwise-and?

[DONE] TODO: add callStack in CodeGenCtx?
- push/pop the call instructions
- can allow full inlining
- may have problems with very long traces

[DONE] FIXME: v8/crypto sanity check fails

[DONE] TODO: branches extend according to which block is specified in the list
- Last if_true, if no next block is specified, insert counter code
compSegment(Interp, nextBlock, segment = null)
- Segment is created if none exists
- nextBlock gets added to the block list
- compilation loop follows the block list

[DONE] TODO: Create Segment class
- Can store counters, list of blocks, code block, etc.
- Easier to manage!

[DONE] NOTE: block exec counts are betraying us even in very simple cases!
- rt_and, both operands integers
- and_exit and and_sec blocks have the same exec count
- can't tell that the AND condition is always true
- Do we want branch counters instead?
  - Strictly more powerful than block exec counters, can still compute block exec count

[DONE] TODO: log instrs for which default fn is used

[DONE] FIXME: JIT breaks 3d-raytrace?
- Find issue, add jit unit test
- Problem seems to be in the call logic
- String(undefined) produces undefined after compilation
- $rt_isGlobalObj(this) in String starts producing true after compilation

[DONE] TODO: use unique id system for labels, use in toString?
- Just print their current offset?

[DONE] TODO: second assembler object for out of line paths
- Assembler.append(Assembler) function?
- OVF logic => out of line
- Function call interp path => out of line

[DONE] TODO: try logging branch exec counts on if_true
- Log with associated instr
- Many go entirely one way, most unbalanced

[DONE] TODO: refactor all conditional branches to have 2 targets?
- target, excTarget?
- Probably best for block extension
- Need to pick a target to extend the block with either way

[DONE] TODO: blog post about JIT compiler

[DONE] FIXME: v8/earley-boyer requires class extension
- Implement in interp/object.d
- Add unit test for this

[DONE] TODO: try to guess callee function?
- Can introspect a bit, check if calling global fun
- Compare closure pointer against known global
- If known global, run optimized sequence!
- Otherwise run interp version
- Great speedups!

[PASS] TODO: implement CALL instruction
- PROBLEM: call instruction sequence is extremely long!
- Very inefficient to implement

[DONE] TODO: implement RET instruction

[DONE] TODO: stack access functions

[DONE] TODO: table of code gen functions, addressed by opcode
- Default gen function calls the instruction

[DONE] TODO: implement JUMP_TRUE, JUMP_FALSE
- jump to trace end label

[DONE] TODO: implement set_int32
- Need to access wsp, tsp
- Load them from interpreter at start of trace, spill at end?
  - Allows proper indexing
  - Put them in callee-save registers

[DONE] FIXME: including RET or CALL in tracelet causes segfaultl
- Return seems to occur twice?
- Set traceEntry to null before entering trace
- Otherwise, we're setting it to null after trace, undoing work of another trace

[DONE] TODO: command-line option to enable or disable JIT
- options.d?

[DONE] FIXME: somehow, traces make odd behaviors happen, e.g.: call to non-function
- Somehow, semantics differ
- Lots of tracelets seem to get executed successfully
- Setting the IP before instruction execution seems to fix this...

[DONE] FIXME: trace issue, jump(block) can trigger recursive trace exec
- Could jump() set a trace pointer in interp, but not call it?

[DONE] TODO: basic tracelet JIT, jit.d
- Lazily compile tracelets for blocks
- Start with one entry point, as a C function
- Need trace to call into instr op functions
- Trace exits by doing ret

[DONE] TODO: port and test x86 execution tests

[DONE] TODO: convert push/pop test to 64-bit registers

[DONE] TODO: complete porting of assembler tests

[DONE] TODO: begin porting assembler tests

[DONE] TODO: port assembler code

[DONE] TODO: port operand toString

[DONE] TODO: finish porting basics of CodeBlock, add mem block allocation

[DONE] TODO: implement register toString

[DONE] TODO: port operand, encoding code

[DONE] TODO: port instruction table construction

[DONE] TODO: copy over Tachyon assembler tests, instr table

[DONE] TODO: fmod, needed by both raytrace benchmarks

[DONE] FIXME: raytrace sanity check fails
- Problem is division of number by string... assholes.

[DONE] TODO: look at D ABI
- Should match the linux 64-bit C ABI
First six int/pointer arguments in RDI, RSI, RDX, RCX, R8, and R9
Return value is stored in RAX

[DONE] TODO: blog
- Mozilla people, learning, friendly people, pleasant office
- DConf 2013
- Meeting with Apple
- Silicon valley is quite different
- Smartphone
- First pull requests
- Bug fixes
- Feature and benchmark list
- Brainstorming
- Preparing tracelet JIT implementation

[DONE] TODO: Add jump function, to jump to a certain block
- Changes the state of the interpreter, returns
- Asserts target is not null
- add block exec count

[DONE] TODO: enable JSON stdlib module
- parse fails, unknown escape sequence

[DONE] TODO: genCallTargets

[DONE] TODO: make call have 2 targets

[DONE] TODO: make post-call be separate block
- Don't want ret tracelet starting in middle of block
- Better for analysis?
- Alternative is ret stays in same block, IP is post-call
  - Would have to associate tracelet with instr in middle of block!
- bitops-nsieve-bits, before: 19.879, after: 24.189, sep: 21.837

[DONE] FIXME: 4294967295.0 === 0xFFFFFFFF
- Int not represented correctly
- Gen code using set_float instead

[DONE] TODO: Fix toInt32, needed by v8/crypto, v8/splay
- Make it use f64_to_i32
- Add more bitwise unit tests for and, or ops, rsft, ursft
- test corner cases

[DONE] TODO: Comply with ES5 comparison unit test
- Will help certify proper working
- Look at Tachyon implementation of primitives

[DONE] TODO: load_file instr
- Add unit test for this
- Add load to feature list on blog

[DONE] FIXME: deltablue, interpreter stack overflow
- Fails after Error object is finally found?
- Did some assertion fail?

[DONE] TODO: add more basic Tachyon unit tests
- Arith, operators

[DONE] FIXME: do we expect the result of Obj.toString to be a string in $rt_toString

[DONE] FIXME: v8/raytrace, info.color is undefined, shouldn't be
- for-in, used by object extension, is broken
- the presence of "var" screws it up

[DONE] FIXME: v8/deltablue, call to non-function
- EditConstraint corrupts working of UnaryConstraint?
- Setting EditConstraint.prototype.isInput corrupts EditConstraint.prototype.isInput

[DONE] FIXME: typeof global var should produce undefined
- $rt_typeOfGlobal(propName)?
- Needed by v8bench/raytrace
- Implement runtime function to see how practical this is
- Add unit test

[DONE] TODO: parseInt, needed for v8bench/crypto

[DONE] FIXME: interp.interp.RunError: global property "rng_pool" is not defined
- Global var stmt, not initialized to undefined
- Add unit test

[DONE] TODO: add list of working benchmark programs on Higgs page, useful to have

[DONE] TODO: Math.round, needed for 3d-cube

[DONE] FIXME: crypto-md5, crypto-sha1, invalid operand 2 type in op "auto r = x * y;" (int)

[DONE] FIXME: deltablue, 3d-cube, ref ptr out of heap
- Failing on object property
- propIdx is 2, object capacity is 2

[DONE] FIXME: lt,gt,eq functions fails in 3d-raytrace, undefined/null value as input

[DONE] TODO: anon function naming in AST
- Anon functions in sunspider/raytrace.js hard to debug

[DONE] FIXME: v8bench/richards, Segmentation fault
- Can we replicate this in a unit test?

[DONE] TODO: TypeSet, GCRoot, could we just use type monitor objects as weak roots?
- Use linked list kind of system, all type sets linked
- Store associated class, if any
- If class is dead after GC, destroy
- Functions destroy their type sets automatically
- Merge TypeMon and TypeSet

[DONE] TODO: implement delete operator
- Unit test this

[DONE] TODO: complete TypeSet constructor from val, union

[DONE] TODO: complete TypeMon basics

[DONE] TODO: GCRoot assignment operator, copy constructor

[DONE] TODO: blog, higgs interpreter complete
- Flesh out feature list on about page
- Post feature list
- Blog about monitoring
- Mozilla visit

[DONE] TODO: enable stdlib_string unit test, comment out regexp code
- interp.interp.RunError: global property "alloc_str" is not defined

[DONE] FIXME: destroy fun in collectFun causes odd interpreter bug
- Collecting function on stack?
- Log deleted functions

[DONE] TODO: parser, encode operator associativity, improve parenthesization
- Test with Function.toString
- Unit test expressions for correctness
- Problems arise when the parent doesn't have higher priority than us

[DONE] TODO: try to find expression tests that break parser re-parse
- write failing unit test

[DONE] TODO: add problematic expression tests for interpreter

[DONE] TODO: determine how to represent numerical ranges
- Look at moller's paper for insight
- just use int64

[DONE] TODO: start implementing type set object, in D
- interp/type.d?
- operations should mutate set objects? Yes, probably
  - want to keep list of dependencies
  - want to maximize speed of operations

------------------------------------------------------------------------------

Milestone Complete: working benchmarks

[DONE] TODO: for-in loop
- [DONE] Port over Tachyon runtime code for this
- [DONE] Test getPropEnum before implementing loop code gen
- [DONE] Base loop code gen on Tachyon code
  - loop until enum function returns false
- [DONE] Enable for_in unit test

[DONE] TODO: basic Date support
- currentTimeMillis()
- IR instr get_time_ms

[DONE] TODO: class obj, make it a hash table
- like the string table
- add max load consts to layout.py

[DONE] FIXME: string table extension provokes GC
- gc during table ext invalidates string ptr?

[DONE] TODO: arguments object
- If no "arguments" param, create arguments local
- KISS, just create array, copy arg vals in loop, set in local slot
- vars analysis should set usesArguments flag in function
  - KISS for now, any occurrence of "arguments" identifier
- enable gc test

[DONE] TODO: call with apply
- call_apply(closArg, thisArg, argTable, numArgs)
- enable gc test
- add unit Tachyon apply tests

[DONE] TODO: accessing missing global prop should throw exception
- use missing property constant
- assertThrows

[DONE] TODO: missing property constant, like undefined, but not
- [DONE] set_missing
- [DONE] init object properties to missing
- [DONE] revise getProp
- [DONE] revise "in" operator, hasOwnProperty
- [DONE] add unit tests

[DONE] TODO: Look at features of two "real" benchmarks to guide development
- Benchmarks: Bones, sunspider/3d-raytrace
- What features are we missing?
  - Float32Array, could replace by Float64Array, aliased to array
  - Already have everything else for bones!
  - For raytrace, new Date().getTime()
- v8/raytrace uses the for-in loop

[DONE] TODO: string->number, parsing numbers in strings
- stdlib_number unit test

------------------------------------------------------------------------------

Milestone Complete: complete simple interpreter (~Dec 31st)

[DONE] FIXME: topmost function doesn't have closure on stack?
- We free a closure, but can we free all its link indices?
  - No, because the code might still be used...

[DONE] TODO: traverse instructions of dead functions, collect link table refs
- log dead functions

[DONE] TODO: garbage collecting fun refs
- Create new fn ref table
- liveFuns table in interpreter
- When traversing closures, add fns to ref table
- Replace original ref table

[DONE] FIXME: ret addr is calling instruction, not IR function pointer
- Add special instruction pointer type tag

[DONE] TODO: blog post, interpreter milestone complete
- Next goals, monitoring, tracing JIT

[DONE] TODO: edit Higgs page on pgw, add supported features list
- Objects
- Arrays
- Closures
- Variadic functions
- For/while/do loops
- If/switch statements
- UTF-16 strings
- Integer and floating-point arithmetic
- Redefinable arithmetic operators
- Garbage collector

[DONE] TODO: remove GC output during unit tests

[DONE] TODO: garbage collecting string table
- don't forward string table, just re-alloc with same size
- after scan, remove strings table entries without a next pointer
  - need to rebuild table, reinsert strings
  - rebuild from old table
- strcat unit test

[DONE] TODO: remove stack slot init to undef, make it implicit?
- move from push to callFun

[DONE] TODO: make next ptr first field in all layouts
- init next ptr to null
- header is second field
- have GC traverse next pointers in objects

[DONE] TODO: beef up clos alloc test

[DONE] TODO: obj alloc test

[DONE] FIXME: stackvm test, segfault
- allocation completes
- crash after alloc in op_call_new

[DONE] FIXME: deepstack... Stack ref, object not in from-space heap
- collect called manually, not in the middle of anything...
- invalid object is all zeros?
- pointer appears to be from old from-space (zeroed out)
- clearing stack slots on push seems to remove problem
- Temp slots don't get initialized!

[DONE] FIXME: graph test, second collection fails, cannot copy in to-space, heap limit exceeded
- object size is corrupted (by previous GC?)
- happens during op_heap_alloc
- crash during "visiting stack roots"
  - probably, some stack object or stack ref is corrupt
- setting slots to undef on push and pop does not fix the problem
- inserting/removing prints can make the bug disappear...
- layout type of faulty object is closure...
  - object is near boundary of from-space

[DONE] TODO: implement GC count variable, IR instruction

[DONE] TODO: make programs/gc/graph.js run

[DONE] TODO: repeated closure allocation test
- closure in loop
- call closure to test

[DONE] FIXME: heisenbug with repeated closure alloc
- call to non function

[DONE] FIXME: repeated closure allocation produces segfault
- Failure probably occurs during newClos

[DONE] TODO: implement proper shrinkHeap

[DONE] FIXME: heap corruption during collection
- println fails, unhandled type in toString
  - link table problems?

[DONE] TODO: implement heap resizing for GC tests

[DONE] TODO: gc arrays test

[DONE] TODO: while manipulating references in interp, push refs to be saved on stack
- [DONE] setProp 
- [DONE] newObject
  - pay special attention to arguments
- [DONE] interp/string.d
- [DONE] setProp callers
- [DONE] throwError
- [DONE] op_call_new
- [DONE] op_new_clos

[DONE] TODO: eliminate ppClass in newExtObj? How useful is it really?
- Not that important!

[DONE] TODO: store ValuePair in stack root
- Multiple helpful constructors
- Assignment operators

[DONE] TODO: implement stack root system
- use special pointer container object, struct w/ destructor (implement in gc.d)
- object can be linked in doubly linked list

[DONE] TODO: revert to-space alloc code

[DONE] TODO: collect in function test

[DONE] TODO: $ir_gc_collect instruction

[DONE] TODO: get heap size instruction
- $ir_get_heap_size

[DONE] TODO: gcCollect after library loading

[DONE] TODO: gcCollect in middle of library loading

[DONE] TODO: first GC test, call gcCollect after interp init?

[DONE] FIXME: forwarding the same address many times over?

[DONE] TODO: function to allocate to-space
- Check if not allocated in gcCollect, if so allocate

[DONE] TODO: when allocating and running out of space, alloc to-space?
- Can keep allocating in from-space as well!
- Have a special function to check if to-space is allocated, allocate to it

[DONE] TODO: move heapAlloc to interp/gc.d

[DONE] TODO: scan link cells during GC
- Scan as roots

[DONE] TODO: layout_visit_gc(o) dispatching fn

[DONE] TODO: GC obj traversal functions
- Do a get on fields, call gcForward, set the result
  - word/type pairs slightly problematic?
    - if tpField set, call special function to forward

[DONE] TODO: remove array functions from objects.d, maintainability hazard

[DONE] TODO: init object properties and array elements to undefined for now

[DONE] TODO: unit test for obj field init
- Two objects from one class, one with a specific field, one without
  - Second one should come out undefined

[DONE] TODO: word field in object/array/cell should be annoted with type field name
- type field should be resolved

[DONE] TODO: layout_sizeof(o) dispatching fn
- Easy to implement, do this automatically
- obj_get_header(o)

[DONE] TODO: Forwarding pointer in layout
  layout_get_next(o)
  layout_set_next(o, p)
- Set special header flag (top bit), store forwarding pointer after header
- Can write these functions in D if desired

[DONE] TODO: layouts, enforce alignment of fields to field size

[DONE] TODO: implement visitStackRoots

[DONE] TODO: port gcCopy, gcForward

[DONE] TODO: complete port of gcCollect

[DONE] TODO: call gcCollect in heapAlloc function

[DONE] TODO: copy over relevant Tachyon GC code

[DONE] TODO: Make sure pointers are initialized to null
- Unless immediately initialized, init pointers to null

[DONE] TODO: create interp/gc.d

[DONE] TODO: create IRFunction ptr word type tag
- Update in layout.py as well

[DONE] TODO: store ctor class ptr on closure obj?
- refptrs

[DONE] TODO: no more ptr caching in instr/IRFunction, no ptrVal instr arg type

[DONE] TODO: modify opNewClos to use link table entries

[DONE] TODO: use new arr alloc in IR->AST

[DONE] TODO: use new obj alloc in IR->AST

[DONE] TODO: implement newClos in runtime.js
- Issue: need to get IRFunction ptr, add to ref table
  - Special instruction for this?

[DONE] TODO: GET_FUN_PTR
interp.funRefs[cast(void*)fun] = fun;
- GET_FUN_PTR <irfunction>
- Takes ptr, add fn to ref table, produces raw ptr

[DONE] TODO: implement newArr in runtime.js
- Improve Array ctor, use newArr

[DONE] TODO: implement newObj in runtime.js

[DONE] TODO: instructions to access link table
- make_link "name"
- get_link
- set_link

[DONE] TODO: make SET_STR alloc a link table cell internally
- Store cell index in arg
- Add new arg type

[DONE] TODO: add wLinkTable, tLinkTable to interpreter
- Allocate in constructor using malloc
- Have list of free link table entry indices
- Function to get a new link table entry index

[DONE] TODO: create $rt_toNumber
- Used in number constructor

[DONE] FIXME: programs/sunspider/math-spectral-norm.js
interp.interp.RunError: invalid base in property write
- Var statement is parsed incorrectly...
  - Only first identifier is resolved, rest goes in init expression
 - Make a parser unit test

[DONE] FIXME: programs/sunspider/bitops-nsieve-bits.js 
global prop unresolved $rt_not
- Add unit test

[DONE] TODO: float to string support, can't print floats right now!
- expose f64_to_str instruction
- Unit test

[DONE] TODO: can we run more benchmarks? Yes
bitops-nsieve-bits  14.5
math-spectral-norm  3.28
math-partial-sums   10.4
3d-morph            6.07
access-nsieve       8.46
access-fannkuch     33.0

[DONE] TODO: Math.log, Math.exp, Math.pow, Math.ceil, Math.floor, expose as instrs
- Too early to try optimizing this, beat libraries

[DONE] TODO: remove exec flag from heap

[DONE] FIXME: stdlib/math.js, second parse gave different result
    if (term < 1E-15)
        break;
- Add parser unit test, fix

[DONE] TODO: blog post about state of Higgs, features supported, upcoming
- Ask for help, Math.js, anything else?
  - be specific
- Simple JS FFT benchmark?

[DONE] TODO: use exceptions in op_call
- Throw exceptions on error, e.g.: call non-function
- Lookup global exception constructor
  - If avail, create deriv obj from prototype
  - If not avail, throw message string
- Need to run throw logic

[DONE] TODO: catch RunError instances in repl, print stack trace

[DONE] TODO: make stdlib/error.js work

[DONE] TODO: stack trace
- KISS for now, accumulate stack trace in throw

[DONE] TODO: test basic interprocedural try/catch

[DONE] TODO: implement stack unwinding, RunError
- Uncaught exception throws D exception

[DONE] FIXME: infinite loop when generating exc path for runtime calls?
- Infinite loop in compiling finally statements
  - string concat in finally stmt
  - finally stmt has itself in finally list? WRONGE!

[DONE] TODO: exception codegen for call / call_new
- If there is no englobing try/catch and no englobing finally, do nothing special
- If there are englobing finally blocks, need to compile those on exception path
  - After these are compiled, jump to try catch if present, otherwise do interp throw
- Prototype with call

[DONE] TODO: throw from within catch, no catch block, but should trigger finally block
- Could we use getFnlStmts, just use first fnl block?
- make test, finally_throw.js

[DONE] TODO: implement finally support in break/continue
- accumulate finallys until target? can pass list ref as argument to ctx fn
  - compile from inner to outer

[DONE] TODO: implement finally support for return
- find all englobing finally statements
  - compile from inner to outer
- test with finally_ret.js

[DONE] TODO: test intraprocedural throw
- throw_intra.js

[DONE] TODO: basic catch block compilation, ir/ast.d

[DONE] TODO: import some Tachyon stdlib tests (e.g.: boolean)

[DONE] TODO: make String ctor work

[DONE] TODO: make array toString/join work

[DONE] TODO: make new Array(len) work
- Needs arguments object
- unit test
- nqueens test?

[DONE] TODO: make Math.max work

[DONE] TODO: instructions to get arg count, access args

[DONE] TODO: refactor calling convention, call instr will:
  ra, clos, this, argc, args.., ...padding...
- pad with undef for missing args
- push args in reverse order
- push local slots
- ret pops local slots, pops args based on argc, pushes ret val

[DONE] TODO: employ closures to implement Math.random RNG
- Keep the RNG simple, KISS!

[DONE] TODO: use subCtx when creating managing clos cells at function init, save temps

[DONE] TODO: unit test closures more thoroughly
- Tachyon closure tests

[DONE] FIXME: variable resolution
- Currently, after nested function has had its defs added, resolve them
- This seems wrong, need to finish parsing parent functions
- Do a recursive resolveRefs pass at the end?
- Problem: all the scope objects are lost! god damnit.
- Alternative: find all decls at one level before trying to resolve
  - Can just resolve immediately instead of calling resolveRefs

[DONE] TODO: gen code for closure cells
- grab unit tests from Tachyon
- cellMap: maps symbols to closure cells
  - in our case, symbol -> local slot of clos cell
- Creating closure objects, set their cells

[DONE] TODO: allow not having return slot in call instr

[DONE] TODO: resolve captured (closure) vars in parser/vars.d
- In Tachyon, fun.captVars vs fun.escpVars
- captVars: captured from other functions
- escpVars: escaping to nested functions

[DONE] TODO: closure cell layout
- Extra properties after object fields

------------------------------------------------------------------------------

[DONE] TODO: improve valToString

[DONE] TODO: fix AST bracketing (curly braces)?

[DONE] TODO: support for "in" operator

[DONE] TODO: implement instanceof operator (used by stdlib/string)

[DONE] TODO: array prototype object

[DONE] TODO: implement Function.toString()

[DONE] TODO: create fun proto obj in interp?
- Corresponding access instruction

[DONE] TODO: function IR dump, log arg slots

[DONE] TODO: $ir_get_ir_str, $ir_get_ast_str?
- Useful for implementing function toString
- Useful for debugging!

[DONE] TODO: eliminate opSetProp, opGetProp

[DONE] TODO: make ast IR gen use prop access runtime functions

[DONE] TODO: implement getProp, setProp in runtime
- array.length property access
- string indexing access
- Don't need to compute hash code, already computed in strings

[DONE] TODO: implement switch stmt code gen

[DONE] TODO: way to test for null pointer
- Make null constant an actual zero null pointer (refptr)

[DONE] TODO: set_value
- Takes word and type inputs

[DONE] TODO: eq_u8
- Useful for layout type comparison

[DONE] TODO: basic throw instruction support, make it stop interpreter

[DONE] TODO: add global undefined property

[DONE] TODO: interp/objects.d
- Object manipulation primitives
- Keep that code alive

[DONE] TODO: SET_GLOBAL, GET_GLOBAL
- D string argument
- Implement global prop slot caching
- Test speed of bitops-bitwise-and
  - About 10x faster

[DONE] TODO: boolean negation !
- Probably want to inline code sequence?
  - Better compatible with genBoolEval
- Unit test this

[DONE] TODO: finish replacing basic operators with runtime functions
- eg: +=, *=, ...
- Remove corresponding high-level instrs

[DONE] FIXME: genAssign, incompatible with rt fun calls
- Pass delegate function instead

[DONE] TODO: I64/F64 conversion instructions

[DONE] TODO: interp cycle count?
- bitwise-and => 3.72M cycles
- will be less cycles once we have GET_GLOBAL
- currently look through 170+ property names in linear search!

[DONE] TODO: complete bitwise op runtime functions

[DONE] TODO: complete runtime comparison primitives

[DONE] TODO: IIR improvements, eliminate need for $ir_jump_false
- Clearer, more concise!
- genBoolEval? Treat IIR differently

[DONE] TODO: implement/test $rt_toBool
- Before: bitwise and takes 5.97s
- After: bitwise-and takes ~24.6s
- Time probably dwarfed by global lookups

[DONE] TODO: interp file loading
- useful for testing/timing benchmarks

[DONE] TODO: make typeof use runtime function

[DONE] TODO: run controlflow-recursive in unit tests

[DONE] TODO: $rt_eq

[DONE] TODO: assertBool

[DONE] TODO: begin using runtime system for arith ops
- Works for add, make test time seems unaffected

[DONE] FIXME: GC bug redux
- Reference IRFunction in fun table instead of AST
- AST has no pointer to IRFunction

[DONE] TODO: insertRtCall(IRGenCtx ctx, string fName, LocalIdx[] argLocals)
- Current impl uses many IR instrs

[DONE] TODO: JS file tests, import some from Tachyon

[DONE] TODO: comma operator support, ir/ast.d
- Evaluates both expressions, returns second value

[DONE] FIXME: for (var i = 0; i < 1000000; ++i);
    object.Error: heap space exhausted
- SET_STRING allocates string every time

[DONE] FIXME: interpreter crash in unit test
  $rt_toBool('foo')? 1:0
- Crash may or may not happen if source is modified...
- May be related to D GC
  - What if a function we need was randomly collected...?
    - AST or IR collected
- Closure objects keep refs to ASTs
  - Need to keep a function table in interp
- Seems fun.ast has been freed by interp!
    write(core.memory.GC.addrOf(cast(void*)fun.ast));
- Add function reference table in interpreter

[DONE] TODO: Math.pow for integers

[DONE] TODO: $rt_div

[DONE] TODO: $rt_mul

[DONE] TODO: Math.sin, Math.cos, Math.sqrt

[DONE] TODO: cos, sin, sqrt instrs
- Needed for math lib

[DONE] TODO: add interp loadStdLib flag, load stdlib/math.js

[DONE] TODO: $rt_toBool

[DONE] TODO: REPL, don't print if undefined

[DONE] TODO: $ir_print instruction, for debugging
- Use in runtime print function :)

[DONE] TODO: complete $rt_toString

[DONE] TODO: complete $rt_add

[DONE] TODO: complete $rt_strcat

[DONE] TODO: complete $rt_intToStr

[DONE] TODO: GET_STR instruction

[DONE] TODO: heap_alloc instruction
- Unit test w/ load/store

[DONE] TODO: complete low-level arithmetic, bitwise instructions
- Template with mixin

[DONE] TODO: Design Link table
- Part of interpreter, statically allocated, unmoving, contiguous
- primitives to manipulate this (get, set), take a unique id number
- wLinkTable, tLinkTable
- What problem are we trying to solve?
  - For getString: want to link a string object pointer
  - For callNew: want to link a class pointer, different for each callee
  - For newClos, newObj, newArr: want to link a class pointer
    - Two pointers for newClos, closure *and* prototype
  - Want the GC to have easy, fast access to these slots!
- MAKE_LINK instr can give us link cell index (need index, otherwise 2 pointers)
- Want to be able to allocate slots lazily
- JIT may need to link constant objs too. Can be done at compilation time.
- Instrs needing global obj, obj proto?
  - Can have host primitives for this, access through interp object ***
- make_link "classptr", produces index to cell

[DONE] TODO: $rt_typeof
- Will need access to header type field

[DONE] FIXME: obj_get_header not working

[DONE] TODO: Generate runtime functions for layout alloc

[DONE] TODO: Define layout type constants

[DONE] TODO: implement new layout system, layout.py
- Declarative layouts in a list
- add make layout makefile entry
- Generate ASTs from layouts (simple ASTs)
  - For JS, auto add $rt_ prefix to every function name
- Generate D and JS source from ASTs
- layout.d, layout.js

[DONE] TODO: Interp.evalString(string str, string fileName = "string")?
- Use to load layout code

[DONE] TODO: eq_i32, lt_i32

[DONE] TODO: add_i32, mul_i32

[DONE] TODO: load/store instrs
- load_i32, ptr, offs
- simple template for op fun generation

[DONE] TODO: is_refptr, is_const

[DONE] TODO: initial $rt_add runtime function

[DONE] TODO: ftoi instruction, I32_TO_F64

[DONE] TODO: add_i32_ovf, add_f64
- unit test

[DONE] FIXME: branchy IIR, need assignment support

[DONE] TODO: is_int, is_float, is_refptr type test instrs
- Do we ever need to compare type tags? Probably not

[DONE] TODO: implement member call in AST->IR, needed for $rt_toString

[DONE] TODO: test $rt_toString runtime function

[DONE] TODO: branchy IIR syntax: if (%...)

[DONE] TODO: special syntax for inline IR, with % sign (make special unary op?)
- Could just use $iir_ syntax, KISS!
- Normal IIR is a function call expression
- Test in shell

[DONE] TODO: Create extensible table of inlinable IR instructions for IIR access

[DONE] TODO: Create interp/runtime.js file, parse/run this at interp startup

[DONE] TODO: interp.exec(AST), interp.load(file)

[DONE] TODO: integrate SET_ARG into call
- Would make for shorter IR if we call into primitives
- 2 instructions per primitive call could be alot
- constant argument: set_int, then set_arg, kind of retarded!
- setArg is fragile anyways

[DONE] TODO: No more MAX_ARGS for instrs. Var arg system.

[DONE] TODO: Add instruction branch target field
- Refactor branch instructions

[DONE] TODO: Eliminate get_ret and the likes!
- RA is call instr
- Problem: Interp loop sets next instr before call
- Doesn't matter, call/return sets next instr anyways

[DONE] TODO: instr, add IRFunction ptr,
- get rid of raSlot, numLocals in RET, PUSH_FRAME
- Better for supporting exceptions, stack traces!

[DONE] TODO: array unit tests

[DONE] TODO: Modify getProp/putProp
- Look at Tachyon code, port over
- Modify underlying getProp, or higher level?
  - setArrElem assumes array, no toObject
  - go with Tachyon approach, simplify lower level fns

[DONE] TODO: rename confusing len fields in layouts

[DONE] TODO: make type objs in class rawptr, will be host objects

[DONE] TODO: implement opNewArr

[ODNE] TODO: array literal AST->IR

[DONE] TODO: NEW_OBJECT, remove proto local
- Only used for object literals
- stdlib will use custom host functions where needed

[DONE] TODO: array object & array table layout
- Should have array table field for array objects

[DONE] TODO: refactor layout system
- genLayouts
- Auto-generate layout type ids, define constants
- Auto-add type field as first layout field
- Add default field initializers (eg: init next to null)
- Layout extension

[DONE] TODO: alloc min size on closures, proto object
- Test adding many properties to fn.prototype

[DONE] TODO: implement object extension
- Need to handle closures and arrays too!
- Need to define type tags
- Modify getProp to follow next link chain

[DONE] TODO: implement type tags into layout system
- Define as uint32 in layout.d, make enum
- Type should be auto initialized on allocation
- Remove _set_type calls

[DONE] TODO: GET_RET_NEW
- ISSUE: need access to the this object passed to the call!
- Push a hidden this argument on the stack?
- Could have CALL_NEW produce this object in output slot, do explicit
  coupling between CALL_NEW and GET_RET_NEW?
  - Seems reasonable?
- Unit tests for new operator

[DONE] TODO: fix this binding resolution

[DONE] TODO: do proto lookup in opCallNew

[DONE] TODO: prototype chain support in lookup
- Test that missing props evaluate to false

[DONE] TODO: simplify class system, allocate proto slot, all property slots for now!

[DONE] TODO: create proper closure in opNewClos, fix opCall
- Test properties on function objects

[DONE] TODO: closure layout
- Needed for functions to have .prototype
- Cannot concat new props on prop array at compile time...
- Want list of closure cell pointers, function pointer

[DONE] TODO: opNew, AST->IR for new

[DONE] TODO: FP less-than comparison

[DONE] TODO: basic floating-point support
- assertFloat w/ epsilon

[DONE] TODO: Interp.getSlot/Interp.setSlot with ValuePair
- Use to simplify code in interp/ops.d

[DONE] TODO: object literal support w/ unit tests

[DONE] TODO: opSetProp

[DONE] TODO: implement opNewObj
- Lazily create new object class?

[DONE] TODO: make alloc set size fields automatically

[DONE] TODO: auto-generate alloc layout method taking interp as parameter

[DONE] TODO: AST->IR for indexed operations, property access

[DONE] TODO: object literal AST->IR

[DONE] TODO: typeof operator
- IR, AST->IR

[DONE] TODO: string concatenation

[DONE] TODO: Implement getString, replace uses of makeString by getString

[DONE] TODO: string table extension

[DONE] TODO: Interpreter method to get a string from the table

[DONE] TODO: alloc initial string table
- allocStrTable(Interp*)

[DONE] TODO: string hash code computation

[DONE] TODO: string table layout
- len
- num_strs

[DONE] TODO: interp/string.d

[DONE] TODO: interp/ops.d

[DONE] FIXME: many moves are unnecessary
- Moving a value into the output slot, just to transfer the value
- Possible fix: add setOutSlot again

[DONE] TODO: ability to prescribe output slot to sub-context

[DONE] TODO: test unary plus, minus operators

[DONE] TODO: in-place operators, +=, -=, etc.
- Issue: "a[f()] += 1" is not "a[f()] = a[f()] + 1"
  - Don't want to evaluate f twice
- TODO: check in what order V8 evaluates lhs, rhs?
  - lhs, then rhs
- Try passing IR instr to assgToIR for in-place operators

[DONE] TODO: revise ast-to-ir design, currently hard to debug&maintain
- context/sub-contexts interfere with each other in unpredictable way
- out slot should be allocated in current context too, to avoid collision
- should eliminate desired out slot/set out slot mechanism?
  - inserts confusing invisible moves!
  - every expression allocates an output temp for itself
- favor simpler, more robust design!
- When creating sub-ctx, decide if it has output or not
  - If it has output, allocate out slot immediately

[DONE] TODO: fix class desc, prop idx instead of woffs/toffs

[DONE] TODO: test global function declarations

[DONE] TODO: test global var statement

[DONE] TODO: global var unit tests

[DONE] TODO: basic SET_GLOBAL, GET_GLOBAL interp implementation

[DONE] TODO: SET_GLOBAL, GET_GLOBAL IR instructions + IR gen
- opSetGlobal, opGetGlobal?

[DONE] TODO: allocate global object in interpreter init function
- Also need to allocate global class
- Also need to initialize both objects
- Make room for 512 properties

[DONE] TODO: finalize initial object layout, class desc layout
- Start with simple layouts
  - V8 uses at least 3 extra words per object, if not more!

Objects have:
- Header
- Num fields
- Class ptr
- Next ptr
- Prop words
- Prop types
- Proto is property 0

Arrays are objects with special properties:
- array table
- length, capacity

Functions are objects with special properties:
- fn ptr slot (raw ptr)
- fixed number of closure vars (can be named)

Class desc:
- Needs next pointer too, so we can add new fields if needed

[DONE] TODO: IR gen for logical and, logical or
- More unit tests

[DONE] TODO: implement/test string concat

[DONE] TODO: implement SET_STR in interpreter
- Lazily allocate strings in the interpreter?
- Unit test this

[DONE] TODO: instr implementation functions
- instr type objects, rename to opcode
- Have pointer to implementation function
  - implementation takes interp state pointer as input

[DONE] TODO: merge Interp and State, no need for two classes

[DONE] FIXME: crash bug, taking address of function wrong

[DONE] TODO: implement string constant IR gen

[DONE] TODO: think about object layout/format further
- Object needs next ptr, otherwise can't reallocate more space
  - Only needed when writing past num fields
- Simple approach might be best!

[DONE] ISSUE: reading field from object, always need to check next pointer...
- Never know that object is big enough to have this field
- Unless class has special "all conforming" field?
  - All pointers to old objects eliminated during GC
- Result: as soon as a new field is added to one object, class is expanded, 
  not all conform (unless only one object of this type), any JITted using this
  class code must be recompiled not to assume next is null
- Global object: if preallocated large, can stay conforming

[DONE] TODO: SET_STR instruction
- Have string + ref/ptr val, not yet allocated?
- Note: string references exist outside the heap

[DONE] TODO: rename REF to REFPTR

[DONE] TODO: interp/layout.js
- genLayout(), test with mixin immediately, print output

[DONE] TODO: heap memory block
    import core.sys.posix.unistd, core.sys.posix.sys.mman;
    PROT_READ | PROT_WRITE | PROT_EXEC;
    auto mem = mmap(null, length, flags, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (mem == MAP_FAILED)
        return null;
    return cast(ubyte*)mem;
- Must be executable ***
- State should allocate a ubyte array for the heap. Must be immovable.
- Alloc ptr is bumped and aligned (see previous gc code)

[DONE] TODO: break, continue IR gen
- When entering IR gen for a loop, associate labels with break, continue blocks
  in the current context.
- Make a context function for this, pass a statement, the break and continue blocks
- Make a context function to do a recursive break or continue target lookup

[DONE] TODO: break, continue with and without label in parser

[DONE] TODO: label support in parser
    LabelledStatement :
        Identifier : Statement
- Store a list of labels on the statement
- Try with backtracking, see how speed is affected

[DONE] TODO: IR gen for cond ? expr

[DONE] TODO: IR gen for post incr., decr

[DONE] TODO: IR gen for do-while loop

[DONE] TODO: IR gen for for loop

[DONE] TODO: Interpreter while loop test

[DONE] TODO: repl, if ExprStmt, transform into ReturnStmt?

[DONE] TODO: repl, output to string?

[DONE]FIXME: handle incorrect argument counts, currently crashes
- add unit tests

[DONE] TODO: state.move function

[DONE] FIXME: IR function args printing

[DONE] TODO: test fib

[DONE] TODO: test fact?

[DONE] TODO: ValuePair to string

[DONE] TODO: test lt comparison

[DONE] TODO: test branching

[DONE] TODO: implement JUMP, JUMP_TRUE, SET_TRUE, BOOL_VAL instructions

[DONE] TODO: implement CMP_LT comparison instruction

[DONE] TODO: test local var assignment

[DONE] TODO: parameter passing

[DONE] TODO: function calls, return global call
- unit tests

[DONE] TODO: unit tests for global expr return

[DONE] TODO: basic interpreter loop
- Capable of evaluating global expr

[DONE] TODO: calling of top unit-level functions in interpreter
- Interp.run(ASTProgram) ?
- Interp.getRet() ?

[DONE] TODO: PUSH_FRAME call at start of function

[DONE] TODO: start implementing simple interpreter
- Could cheat, closures as IR fn ptrs
- Interpreter state structure
  - Double stack system, two base pointers, two top pointers
  - IR instruction pointer
  - heap allocPtr?

[DONE] TODO: auto name unit functions
- use delegate, map?

[DONE] TODO: reverse local indices after IR gen?
- Issue: want to use stack pointer, not base pointer
- Need to know how many locals there are
- Highest local becomes index 0, top of stack

[DONE] TODO: IR gen, map hidden args in local map

[DONE] TODO: IR gen for closures of nested functions

[DONE] TODO: use IR function in new_clos IR

[DONE] TODO: look at IR for global call

[DONE] TODO: IR gen for function call

[DONE] TODO: IR gen for function expressions

[DONE] Call protocol ISSUES:
- Many hidden args (closure, this, nArgs, RA)
- Should we push all after normal args? Practical, may be problematic if frame resizing needed
  - Not a problem for the JIT if call is inlined (most calls can be?)
  - Not a problem if no resizing!
- Would want call instr to take exception block arg?
  - Technically, this can be some annotation per return address for a function!

Stack frame layout (grows down):
        arg0
        arg1
...
        argN
        closure (pushed by call)
        this    (pushed by call)
        nArgs   (pushed by call)
        RA      (pushed by call as raw pointer)
...
SP+2    local
SP+1    tmp
SP+0    tmp

[DONE] TODO: IR instructions for call protocol

[DONE] FIXME: resolve vars in assign lhs exprs?

[DONE] TODO: pretty print of expressions with less parentheses
- Can parenthesize sub-expressions
- When do we need parentheses?
  - Parent has higher precedence: (x + y) * z
- getPrec function, returns highest by default (atomic)

[DONE] TODO: IR gen for while statement

[DONE] TODO: float expr

[DONE] TODO: IndexExpr, merge with dot operator to simplify AST
- create string expr from ident

[DONE] TODO: IR gen for VarStmt

[DONE] TODO: code gen for if statement

[DONE] TODO: IR for undef constant, return undef by default

[DONE] TODO: decide on IR generation strategy.
- Current code generation strategy:
  - Create codegen context for sub-expressions
  - Can specify an output slot (where the sub-expression should store its output)
  - Sub-expression can specify it already has a slot, move inserted if needed
  - Sub-expression can get a slot allocated for its output if none was specified
- What is problematic about this approach? How can we fix it?
  - Need more higher-level constructs, simplifications for common operations

[DONE] TODO: unary negation code gen

[DONE] TODO: look at Marc's simple C compiler. It uses a stack machine.

[DONE] TODO: for-in statement parsing
- need to make work with regular for statement
- if there's no var, we know it's an expression
- could parse whole expression, see if it's an "in" expression ***?
- if starts with var, parse following expression
  - check if expr is "in" expression
  - can't parse as real var statement...
- for var ... in, could try peeking ahead more

[DONE] TODO: peekSep, peekKw

[PASS] TODO: IR, fuse compare and jump
- Uselessly complicates IR->AST translation

[DONE] TODO: optional catch clause

[DONE] TODO: try parsing stdlib

[DONE] TODO: fix sunspider/3d-raytrace parsing/toString bug

[DONE] TODO: decide on boxing scheme
- Scraping float bits for tagging is problematic
- x86 has (all valid in 64-bit):
    CMP r/m8, imm8 : two-byte instruction
    MOV r/m8, imm8 : two-byte instruction
    MOV r8,r/m8     : 2 bytes?
    MOV r/m8,r8     : 2 bytes?
- With double wrappers, don't need to query objects about their type!
- ASM microbenchmark?
  - Performance indistinguishable between one vs two stack
    pointers, separate type array or not
- "Representing Type Information in Dynamically Typed Languages"
  - Had mostly good things to say
  - Seemed to assume that the only "large-wrapper" option is two words
- Separate tags may have advantages for instr level parallelism (ILP)

[DONE] TODO: adapt parser code
- [DONE] fix operator precedence, operator table
- [DONE] new operator
- [DONE] function syntax, missing fn name
- [DONE] object literal syntax
- [DONE] string literals with single quotes
- [DONE] source should be processed as wstring, UTF-16
- [DONE] string expr should store wstring
- [DONE] hex/unicode string escapes
- [DONE] hex number support
- [DONE] variables, one scope per function
- [DONE] functions, find fn decls in scope
- [DONE] variables, multiple decls per statement
- [DONE] optional semicolon for expression statements
- [DONE] test empty statement
- [DONE] multiline string continuation
- [DONE] re-parse test
- [DONE] optional semicolon for var statement
- [DONE] optional semicolon for return and throw
- [DONE] fix bug with crypto benchmark, do diff
- [DONE] break, continue statements
- [DONE] switch statement, as if cascade
- [DONE] more unit tests
- [DONE] real JS code unit tests, sunspider benchmarks
- [DONE] reverse operator precedence numbering
- [DONE] implement comma operator

[DONE] TODO: put project on github

[DONE] TODO: create Higgs project folder, move code

[DONE] TODO: how many benchmarks can we run with this? Need 2-5 (easier first)
- access-binary-trees, new operator
- math-spectral-norm, uses FP
- math-cordic, uses FP
- access-fannkuc, uses arrays
- access-nbody, uses FP math, arrays
- navier-stokes, uses arrays, FP math
- string-base64, uses strings, arrays
- crypto-*, strings, arrays
- crypto (V8), strings, arrays, math, new
- richards
- splay
- deltablue, uses .call
- raytrace, uses .apply, arguments as object, object literals, FP math
- earley-boyer, uses .call, .apply, arrays, strings
- some of the new octane ones might be feasible (non-DOM ones)

