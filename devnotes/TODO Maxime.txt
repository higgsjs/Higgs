Conference deadlines:
- ECOOP                 December
- CC 2014               October
- ESOP                  October (early Oct)
- PLDI 2014             November
- VEE 2014              ~November
- CGO 2014              ~September
- VMIL 2013             ~August
- Intel Compiler...     ~July
- DLS 2013              June
- DYLA workshop         March
- ISMM                  Feb
- Computing Frontier    Jan 2015, notify Feb
- SLASH 2015

List of possible contributions:
- Type tagging scheme
- Register allocation
- Lazy/incremental JIT
- Basic block versioning
- Interprocedural versioning
- Incremental inlining vs classical inlining
- Typed shapes and basic block versioning

------------------------------------------------------------------------------

FIXME: v8bench/regexp segfaults

FIXME: date-format-tofte
- keeps using more and more memory
- some kind of memory leak issue?

TODO: make $ runtime/stdlib variables read-only, non-enumerable, non-configurable

TODO: const globals
const name1 = value1 [, name2 = value2 [, name3 = value3 [, ... [, nameN = valueN]]]];
- Same structure as var decl
- In D8, these are enumerable
- Use it for Turing Turtle
- Look at current parser code, vars code, ast-to-ir code first ***

TODO: look at eval notes again

TODO: constant prop in ValType?
- Don't have to propagate all
- Would be useful to prop shapes without using a register
- Propagate booleans
- Simplify shape_is_null and such

TODO: blog post, the future of compilation
- Logical reasoning, supercompilation
- JIT compilers, continuous of compilation
- Lazyness is crucial
- Definite place for controlled code duplication

TODO: post dconf talk on r/coding
- Do this when you have time to chat!

When fine-tuning the S9 garbage collector (which also is a constant-space mark-and-sweep collector),
maintaining 50% of free space turned out to be the sweet spot. Whenever less than
50% of free space are available after a collection, the heap grows.
=> grow on next GC

TODO: try embedded arg list for IR instrs?
- What is the object we allocate most of? stats?
At EA, in C++, we have exactly this type in our standard template library as
eastl::fixed_vector<T>. It's definitely kind of annoying to implement, but
extremely useful once you have it for exactly this kind of use case.

TODO: liveness analysis flipped...?
- TODO: start by implementing system to measure total liveness analysis time
  - test on 3d-raytrace, other big benchmarks which don't GC, find slowest
- Current pathological cases, live sets grow very big everywhere
  - Many many large sets, independently allocated
- Idea:
  - For some values, big live intervals
  - Most values, vast majority, tiny live intervals
  - For a given value, store the places where it's live in a set
- Use custom set data structure to store live interval
  - small embedded list
  - associative array, initially empty
  - For most values, small embedded list will work
- Values that are never live don't even have a live set

TODO: optimize host get_prop
- doing shape lookup twice

------------------------------------------------------------------------------

ECOOP - Dec 21st
- Jan Vitek is on organizing committee

VEE - Nov 25th?

TODO: think about interprocedural BBV
- Return info: try to predict what the function will return
  - speculative/predicted info return vs generic return?
  - remark: for many runtime functions, we should know the return type,
    but it may also not be very relevant
- Shape changed flag in context

TODO: blog post, Higgs' Fancy New Object System => get started
- use knightmare image for featured image
- quick sketching program, online?
- post to r/compilers, r/higgsjs
- Typed shapes + BBV a bit of a gamble

TODO: stub branches, pre-reserve space, put block idx in there
- should ideally jump ahead and not backwards
- don't alloc objects for each stub
  - or maybe have an array of stubs, flat
- could use this for function entry stubs too
  - need to become specialized for interprocedural BBV
TODO: stub space, no more generic stubs
- Do we need entry stubs? compile immediately?
- Do we need stub objects?
  - Entry stubs would need a pointer to the entry state
- This should yield interesting performance improvements

TODO: blog post, the lazy compiler
- log current ideas in writing

TODO: push to master
TODO: phi nodes, store in inline array?
- Issue: no more pointers to phi nodes?
TODO: push to master
TODO: attempt inline array for IRInstr args
- measure compilation time before
TODO: look at V8 src wrt IR, phi nodes
- How do they represent/alloc this efficiently?
- No pointers?

2014-10-2X Meeting:
- Submitted rebuttal
- Fixed indexed array element called as method bug
- Fixed regexp parsing bug
- optimized host property reads (uncaptured shapes)
- benchmark-vs-v8 script
- Tried forcing capture of more functions to reduce "slow calls"
  - Not much difference
  - Slow calls result from unorthodox calls or argument count mismatches
- Added shape test stat
  - Many more shape tests than known shapes, ~10:1
  - Interp BBV should help tremendously there
- Type tests for 3d-raytrace, previously 3.5M (optimized), now 1.4M
  - 5.2M with maxvers=0, eliminating 73% of type tests
- Idea for interp BBV returns
  - Only try to predict return type when fairly sure to avoid mispredicts
  - Otherwise only predict that no shapes will be changed

FIXME: gc bug in v8/regexp
- next pointer invalid during GC
- Ask pag for help if needed

TODO: look into ropes
- do some online reading first ***
- left, right, length
- when concat'ed, set right to null

TODO: turing machine for raw sound synth?

TODO: take a break, dust off CPU heatsink and fan
- turn off machine, remove fan
- listen to hyperion!

TODO: add of add peephole pattern
$15 = add_i32 $14, 4
$16 = add_i32 $15, 8
before, code size (bytes): 345992
- Log when used














[DONE] FIXME: maxvers=0 causes segfault on 3d-raytrace
./higgs --maxvers=0 benchmarks/sunspider/3d-raytrace.js
- wStack, first word of VM object, gets corrupted
- Seems obj_init_shape slow path corrupts regs

[DONE] TODO: hack simple drum synth, snare, see synth cookbook
- for now, source/synth.js
- produce a new Sound object for now

[DONE] TODO: add shape test stats

[DONE] TODO: num call apply stat

[DONE] FIXME: regexp parsing bug
/\\/g;

[DONE] TODO: try forcing fn capture in set global?
- how often do we not know the fn? check
  - Array ctor is unknown 
  - v8-raytrace uses weird object system, has many slow calls
- Does eliminate unknown fptrs, but doesn't make net difference in slow calls!

[DONE] TODO: write simple wav encoding test

[DONE] TODO: complete basic wav encoding, for fun

[DONE] TODO: host get prop, try passing args through fun params

[DONE] TODO: benchmark-vs-v8.py script
- Work from CSV files, copy CSV column extraction code
- Use geo mean, compute baseline ratio and crankshaft ratio

[DONE] TODO: Higgs, increase heap size in release mode to 256M

[DONE] TODO: regression test for function call to array element

[DONE] FIXME: turtle segfaults
./higgs ../examples/turtle.js
Assertion failed (runtime/vm.d@1042): expected string value for arg 1 of:
$174 = obj_get_prop $171, $161 => call_merge(77614), if_join(77639)
h> var draw = require('lib/draw');
var window = draw.Window(100,100,200,200, "test");
h> window.onRender(function(canvas) {
canvas.setColor("#008FCC");
canvas.fillRect(10,10, 100, 100); });
// ALL GOOD HERE, UNTIL:
h>window.show();
- Add regression
- Calling an indexed array element as a method

[DONE] TODO: Can we refactor getPropField?
- If we make it to null proto, then prop val is undef, don't call getProp
- If proto is not an object, then not found

[DONE] TODO: getPropField, don't call if the property is a number string
- explain why in comment

[DONE] TODO: add regression test with Array.prototype having property '0'
d8> Array.prototype['0'] = 7; a = [3]; a['0'];
- Add under core/Array tests

[DONE] TODO: Rebuttal, complete today, send to Marc
- to the point, don't argue fine points. Honest and straightforward, simple ***

[DONE] 2014-10-XX Meeting:
- Return type profiling
  - Booleans dominate: gt, lt, eq, toBool
  - closure returns are because of unoptimized method lookups
  - Other most common types are int, float & string, fairly universal
- Optimized property lookup as loop
  - Fixed IR translation bugs
  - Smaller code size
  - deltablue 50% faster, v8-raytrace 33% faster
- Optimized array method lookups
- Optimized slow get prop path
- Benchmark harness
  - Often competitive with V8 baseline, but crankshaft often beats us by a lot
    - Probably due to inlining
    - but sometimes less than 2x slower
  - Seems realistic to beat baseline on most benchmarks
  - With interp BBV, we may approach crankshaft, but probably won't beat it
  - Benchmark setup & teardown, run multiple times or exclude? ***
    - Currently not fully consistent
  - Higgs, increase heap size in release mode to minimize GC?
- Doing fairly bad on all benchmarks involving strings
  - Will probably need ropes to be competitive
- Lack of collaboration, missed opportunity
  - Lunches with Baptiste or group lunches, fixed day

[DONE] TODO: make benchmark-list.csv for nocomptime suite, try it out

[DONE] TODO: benchmark.py, optional benchmark list file
- csv?
- --bench_list=
- default should be source/benchmark-list.csv

[DONE] TODO: complete nocomptime benchmark hooks
load('benchmarks/nocomptime/timebenchmark.js');

[DONE] TODO: timebenchmark.js, adaptive timing

[DONE] TODO: numItrs in timeFun
- do warmup 0, warmup 1
- if warmup 1 < 100ms, do more warmup rounds
  - log supplemental warmup, warmup time
- compute num itrs to get total time ~ 1s, log it
- report time divided by num itrs

[DONE] TODO: optimize host get prop to avoid double shape lookup

[DONE] FIXME: nocomptime/3d-cube gets many setprop calls, why?

[DONE] TODO: deltablue has 13.2K get_prop host calls, why?
- Does not occur through getProp or objGetProp
- Prop name is known
- Shape is unknown, failed to capture

[DONE] TODO: remove *quick benchmarks from nocomptime

[DONE] TODO: do we still need the ne_rawptr hack for shapes? no
- print use

[DONE] TODO: push to master, branches have diverged far enough already!

[DONE] TODO: fix obj_init_shape to account for null prototypes
- foregoing known prototype tag is annoying
- could also have two shapes for objects
- obj_init_shape could take a boolean argument for proto null or not
- Prototype could be many different things, not just object or null!

[DONE] FIXME: Running: ./tests/02-regress/call-non-function.js
Error: error string does not specify function name
./higgs tests/02-regress/call-non-function.js

[DONE] TODO: implement getPropMethod as loop
- Could try and see how it performs
- Affects v8/raytrace, 280K get prop host
- Appears beneficial for performance

[DONE] TODO: can there be arrays with other prototypes besides the array prototype?
- If not, simplify things, make array tag proto known
- Seems like not

[DONE] FIXME: initial object shape is wrong
- Proto is marked as Tag.OBJECT
- This is inaccurate when the prototype is null

[DONE] FIXME: regression bug wrt getPropField loop
- Unreachable code remains in the CFG, breaks liveness analysis

[DONE] FIXME: phi of phi opt problem
- makes no sense that the call to getGlobal would get compiled
Weirdly doesn't fail if stdlib isn't loaded, suggesting it isn't an IR problem?
- Modifying the IR removes the failure....
Fail when compiling the call to new.
Seemingly trying to use the result of call_prim getGlobal
As if we'd wrongly removed the inlining phi node?
We replaced the phi node by the value of getGlobal
Removing the phi of phi opt eliminates this issue
- Issue with phi of phi opt, not valid when first phi has more uses

[DONE] TODO: read blog post about V8 baseline JIT

[DONE] TODO: what function returns closure so much in deltablue?
- objGetProp and getProp often return a closure

[DONE] TODO: profile return types
- Add code in stats
- Have an unknown entry for when the ret value type is unknown?
- Boolean types dominate. gt, lt, se comparisons.

[DONE] TODO: get rid of special defConst treatment of proto
- Could have an initial object shape with the proto slot
- Write the proto value directly

[DONE] TODO: get rid of ExtInfo
- Wait until new capture_shape is implemented

[DONE] 2014-10-16 Meeting:
- Fixed hard GC bug
  - JS strings leaking, getting corrupted
- Fixed parser bug signaled by new contributor
- With new shape system, code size about 25% smaller than old object system
  - Even though more versions
- Added wall clock time measurement to benchmarking script to support V8
- Higgs vs V8 (***caveat, including V8 compile time***)
  - Higgs faster on several benchmarks, smaller/faster ones especially (11/32)
  - Many benchmarks in similar order of magnitude
  - Higgs has pathological cases on several string benchmarks
  - Faster on recursive benchmark, this has short compile time
    - If exec time is made longer, then 2x slower
  - faster on binary trees, but again short benchmark
  - In general: faring not too bad, comparable, except on string benchmarks
    - But only comparable if we exclude Higgs compile time
- With optimizing JIT, V8 has inlining of user functions, Higgs doesn't
- Low hanging fruits: probably many inefficiencies in runtime, generated code
  - Examined specific benchmarks in case studies
  - Focus on the ones where we do poorly, or where I think we could do better
- Found many small inefficiencies in Fibonacci machine code
  - Fixed a few
- Optimized array property access, now much faster
- Made various small optimizations in runtime to improve benchmark performance
- Shape spec, seems we unfortunately still don't win
  - Smaller code size, less type tests, but not better performance
- Next step:
  - Move on to interprocedural BBV or...?
  - Benchmark-specific micro-optimizations?
  - Could implement statistical profiler
  - Could implement code size profiler
- Example small opt: array and string method access
  - Can lookup on array proto and string proto at compile time
  - Right now we do a slow lookup for these
- Example: bad string concat performance
  - 3d-raytrace, two third of time taken by string concat
  - need ropes to perform competitively on this
- Example: stubs without register write, stub space ***
- Interprocedural BBV
  - Implement in steps
  - Step 1: multiple function entry points
    - entry contexts track function argument types
  - Step 2: threading global object as hidden argument to track global shape
  - Step 3: passing information back through returns
  - May also want to implement const prop in BBV for specialized purposes
    - pass argc as constant, for example

[DONE] TODO: what calls getProp in v8bench/raytrace?
- "initialize" and "isHit", called on a regular object
- 187K get prop host
- Also get calls to push and charCodeAt

[DONE] FIXME: v8bench/raytrace has many comparisons of objects vs null
- most of these coming from se, called in the apply function

[DONE] TODO: could strcat be taking a big chunk of the time in 3d-raytrace?
- Modify the benchmark and print the times
- Seems about 2x more time is taken by string concat
- It's really the concatenation that's slow

[DONE] FIXME: move of 0 has upper bits set?

[DONE] TODO: array benchmark, how do we fare against V8 now?
- pretty close now

[DONE] TODO: toPrim, toNumber called 58K+ times in 3d-raytrace, why?
- rt_lt, rt_gt call toNumber of some fp number?
  - probably compared to undefined or something like that

[DONE] FIXME: array access performance sucks
- want hidden __arrTbl__ __arrLen__
  - start with just __arrTbl__
- look at code size before and after, nsieve benchmark
- before: code size (bytes): 354046
./higgs --perf_stats benchmarks/sunspider/access-nsieve.js
    comp time (ms): 311
    exec time (ms): 14
    code size (bytes): 205236
code size (bytes): 351522
./higgs --perf_stats benchmarks/sunspider/access-nsieve.js
    comp time (ms): 241
    exec time (ms): 13
    code size (bytes): 204534
- start simple
  - write $rt_getArrTbl, $rt_getArrLen
  - use defConst in constructor for testing

[DONE] TODO: avoid reading function pointer in getProp when possible
- if fun doesn't use closVal, only one use which is a call
- need constant propagation to implement this properly (GC-safe)

[DONE] FIXME: no reg reusing for add in fib
- x operand isn't live after?
branch_if_true(1E667):
if_true(1E667):
; $26 = add_i32_ovf $11, $21 => call_merge(1E658), if_false(1E66E)
mov rcx, [qword r14 + 88];              498B4E58
mov rdx, [qword r14 + 168];             498B96A8000000
mov edi, ecx;                           89CF
add edi, edx;                           01D7
mov eax, 9818;                          B85A260000
jo branch_if_false(1E66E);              0F80D7A4FDFF
branch_call_merge(1E658):
call_merge(1E658):
; ret $24
- Claiming that $11 is live after the add...
- addIntFloat is not optimized
- before: code size (bytes): 354206
- after: code size (bytes): 354046

[DONE] FIXME: fib, two useless moves in return?
; ret $24
mov rcx, r10;                           4C89D1
mov dl, 1;                              B201
mov eax, [dword r14 + 272];             418B8610010000
sub eax, 1;                             83E801
xor ebx, ebx;                           31DB
cmp eax, 0;                             83F800
cmovl eax, ebx;                         0F4CC3
add eax, 36;                            83C024
mov rbx, [qword r14 + 248];             498B9EF8000000
add r13, rax;                           4901C5
shl rax, 3;                             48C1E003
add r14, rax;                           4901C6
jmp rbx;                                FFE3
- it's the return value!
- could try to bias ret values towards retWordReg
- before, avg code size (bytes): 354334
- after: code size (bytes): 354206

[DONE] FIXME: call, use the global value instead of get_global_obj before call
- look at fib code size
./higgs --nostdlib --perf_stats benchmarks/micro/fib42.js
code size (bytes): 33513
after: 33490, slightly smaller, tiny bit faster

[DONE] TODO: test if we're faster than V8 on good ole fibonacci
- not with a large count

[DONE] TODO: test V8 benchmarking
./benchmark.py --vm_cmd="~/Dropbox/Linux/bin/d8" --num_runs=5
./benchmark.py --vm_cmd="./higgs --perf_stats" --num_runs=5
- runs very very fast, even with 5 runs!

[DONE] TODO: benchmark.py, measure wall clock time

[DONE] TODO: return code error detection in benchmark.py

[DONE] TODO: verify if V8 has exec time option
- doesn't seem like it

[DONE] TODO: numberToString gets called a lot, why?
- Also, rename to numToStr?
- Called by toString, seems inefficient, could be optimized?
  - See if this reduces the count in benchmark.py
- Also called in Number.toString
  - Only this needs the full implementation

[DONE] FIXME: parsing error, on two lines
function x() {} [0, 1]
- Fix on master, 3rd workspace, take a break
- The global function x() is not defined
- It does parse as if an indexing expression, with a comma expression inside!
- This is not a newline problem. It should work even on one line
- When parsing an expr stmt, we should behave differently if we have a function declaration.
- Peek for function.
- V8 rejects global functions with no name

[DONE] FIXME: splay benchmark segfaults
- crashes in the setup phase
- seems it may be a GC bug
- GC possibly corrupting something during run
- crashes at a stage where multiple GCs occur in sequence...
- this may be a flaw in new_clos or something
  - or a problem in setProp
Can happen in strcat, with a double GC
- A second GC happens on the same instruction to expand the heap
- Work keeps happening for a bit, and then there is a segfault
Also happens with alloc_object, again with a double GC
Third occurrence again with heap expansion...
- What's different on the second GC?
- Why doesn't it happen on the first heap expansion?
- Normally, all the junk is gone, result should be exactly the same
- Flipping the heap twice... Back to the same from space
- Leaking JS strings into propCache. Strings get corrupted.

[DONE] TODO: to debug splay, try storing curInstr pointer in main
./higgs --nostdlib splay-fail.js
instrPtr: $48 = obj_get_prop $7, "key" => call_merge(21425), if_join(2142F)
curFun: SplayTree_prototype_splay_(1E7FA)
- This is a host getProp
- Segfault before leaving host getProp
- Segfault in getDefShape, but shape appears valid
- Cache lookup in getDefShape fails
- TODO: verify that obj shape is referenced
  - obj shape pointers valid
  - all obj shapes are referenced all the way to the root
- At GC expansion, the D GC probably runs...
  - Either the shape is collected or something writes over it, corrupts it
- No shape destructor called, pointers valid according to D GC, only propCache corrupted
  - Seemingly, the shape got corrupted, written over somehow
We could scan the heap pre and post GC, query the shapes for the "key" property
- Assume something in the GC heap expansion breaks a shape
- The shape is not inside the new heap range
Many shape flips in this program
- Could verify object shapes after flip ***
Commenting out fast setProp path seems to prevent this issue...
- Try enabling all of setProp except for when a shape flip is needed?
  - Seems to eliminate the problem...
- Somehow precompiled shape flips are to blame?
- TODO: try verifying obj shape after fast getProp, do host call
propCache is corrupted before the last double GC...
There seems to be a corrupted propCache right after shrinkHeap

[DONE] TODO: add assert(s) in prop code to look for temp strings
- Never create a shape from a temp string
- Strings with zeroes in prop cache

[DONE] TODO: try segfault catch hack, global VM ptr
https://github.com/D-Programming-Language/druntime/blob/master/src/core/sys/posix/signal.d
- The IP is not within the exec heap

[DONE] TODO: Meet Marc
- Shape profiling confirmed intuition, first shape in most cases, no exceptions
- Fixed GC performance bug
- Worked on new object access primitives
  - Big refactoring
  - Bug after bug after bug
- ir_break
  compiler makes an observation
  communication between executed code and compiler
- New capture_shape, capture_tag
  - More compact code
  - No redundant object shape pointer written
- Fixed a few inefficiencies in machine code
- One odd GC bug remains
- Results on microbenchmarks:
  - loop_global_incr 2x faster than old obj system
  - 200m-getprop 9x faster than old obj system
  - 10m-getglobal 2x faster than old obj system
  - bitwise-and now faster, wasn't before refactoring
  - recursive benchmark 1ms slower, but faster with longer exec time
- Jan Vitek encourages us to submit to ECOOP in December
  - Also invites us to come present at his university in Boston

[DONE] TODO: look at code for 3bit benchmark, obvious inefficiencies?
./higgs --genasm --e "print(fast3bitlookup.asmString())" benchmarks/sunspider/bitops-3bit-bits-in-byte.js
- not much

[DONE] FIXME: setProto not inlined

[DONE] TODO: check if 3bits-byte, recursive faster than old object system now? If not, why
- Run with --nostdlib --perf_stats
- bitwise-and as fast or faster, but not 3bits-byte, not controlflow-recursive
- do we win on controlflow-recursive with bigger iteration count? yes
  - would suggest compilation interruptions make us lose
  - global obj shape changes may also contribute

[DONE] FIXME: what's going on here?
; capture_shape $1, $2 => if_true(1E38E), if_join(1E390)
mov rax, 139762024056576;               48B80007CCE11C7F0000
cmp rcx, rax;                           4839C1
mov eax, 9706;                          B8EA250000
jne branch_if_true(1E38E);              0F85FC8FFDFF
jmp branch_if_join(1E390);              E900000000
branch_if_join(1E396):
- unclear, if_join is the following block...
- branch code only generated once with DEFAULT ordering?
but normally, branch code goes to stubs...
behaving as it targets already generated?
- Queued target 1 directly, preventing branch code rewrite
- Optimized branch writing function

[DONE] FIXME:
; $1 = get_global_obj
mov rax, [qword r15 + 256];             498B8700010000
mov rsi, rax;                           4889C6

[DONE] TODO: ensure no code is generated for ir_break()
- Should only need to generate code for default ordering

[DONE] FIXME: breakage in asmString, probably due to ir_break
./higgs --genasm --e "print(test.asmString())" benchmarks/micro/loop-global-incr.js 
- Instructions with both branches going to same target

[DONE] TODO: verify that second GC leaves alloc ptr at same offset

[DONE] TODO: add ir_break() before capture_tag as well

[DONE] TODO: undo modification to JumpOp, noStub flag

[DONE] FIXME: property deletion, defineProperty, no way to remove a setter?
- may be able to change the property attributes, then change the value?
- look at how V8 behaves
- add a test for setter deletion and removal with defineProperty
- write it in a small JS file first, for testing

[DONE] FIXME: Running: ./tests/01-stdlib/global.js... global not defined: "k"

[DONE] FIXME: further object test bugs, setter methods
./higgs ./tests/01-stdlib/object.js

[DONE] FIXME: Running: ./tests/01-stdlib/object.js... ***** FAILED! *****

[DONE] FIXME: assertion failed, value not in val map in ctx diff
- Must be error with obj_read_shape?

[DONE] FIXME: higgs init fails
- seemingly, a property descriptor object has an invalid proto
- should check that setProto works properly
  - seems to?
$74 = obj_get_proto $254
$0 = is_object $74
if_true(808C):
$75 = obj_read_shape $74
- Proto ptr read from get_proto is wrong
- Proto set in def_const is right...
- Must get corrupted by set_prop somewhere
- object is marked as having emptyShape in state
  - but doesn't actually have empty shape
- object "known" to have empty shape after call_prim to setProto... nonsense
- Idiotic bug with call_prim not clearing shapes

[DONE] TODO: what happens in get_prop when the properties don't exist?
- Do we take the slow path?

[DONE] FIXME: defineProperty seems to make a property undefined
Object.defineProperty(Map, 'defHashFn', { writable:false });
- Maybe reassigns to it, maybe objHasProp fails
- Not assigning new value, must be obj_set_attrs?

[DONE] FIXME: infinite loop in getGlobal?

[DONE] FIXME: capture_shape needs to be in a different block from get_shape
- capture_shape, when shape is unknown (dynamic), need to observe it at compile time
- possibly, can't observe it at compile time because the code hasn't been
executed yet (still in the compilation queue)
- Could try to implement a simple ir_break
  - Try if ($ir_break()); two branches
  - Execution resumes, jumps to true stub immediately
  - Seems both targets being the same should work

[DONE] TODO: slow path branching for getProp and setProp

[DONE] TODO: implement get_prop and set_prop branching for "abnormal" cases
- for get_prop, can check if const tag to know if prop not found
- what is the performance situation?
- previously, host calls generally happen when prop name unknown
- much smaller IR for inlined cases

[DONE] TODO: new capture_shape, if (capture_shape(obj, objShape)); 
- Generates a branch back into a different version of itself if shape mispredicted
- Avoid elaborate codegen, multiple slots
- Can fall through in many cases
- need to pass both obj and objShape

[DONE] TODO: remove special handling of capture_shape in ir/ast.d

[DONE] TODO: implement obj_get_shape

[DONE] TODO: rename shape_ ops to obj_ when appropriate
obj_init_shape
obj_set_prop
obj_get_prop
obj_get_proto
obj_def_const
obj_set_attrs

[DONE] TODO: don't pass defShape to get_prop

[DONE] FIXME: stdlib init fails
- defineProperty not defined, call to non-function
- Problem: shouldn't ever be asked to read a property which doesn't exist
TODO: construct small scale test, replicate problem with --nostdlib
- Seems there's an error when fetching the property in the call
  - uses optimized get_prop

[DONE] TODO: rewrite getProp to not use defShape info

[DONE] TODO: make getProp take prop name

[DONE] TODO: remove captTagSub

[DONE] TODO: IsTypeOp => IsTagOp, getTypeTestCtr => getTagTestCtr

[DONE] TODO: look at code size and performance with new capture_tag
- slight code size reduction
- performance difference unnoticeable

[DONE] TODO: new capture_tag, while (capture_tag(x));
- "Loops" until it captures the tag
- Assert that no phi nodes to succs, only instr in block
- No need for version limit with capture_tag, yo
For fail succ (self), can set tag to value tested. We do this because we need
a new context. When capture_tag is compiled, it checks if the actual tag value
is the one from the context. If so, do nothing, go straight to false succ.
Otherwise, compile a test for the observed tag. If the tag value is actually
known, the context value can never contradict the obsserved one.

[DONE] TODO: save code size stats pre refactoring
./benchmark.py --higgs_cmd="./higgs --perf_stats" --csv_file="pre_new_capt.csv"
code size (bytes): 428353
comp time (ms): 324
exec time (ms): 61
- Code size only slightly bigger than with old object system

[DONE] TODO: investigate bug found by yawnt on dev-maxime branch
- Fix on master
- Add test
- Make it so exports is globally avail, current modules still work

[DONE] TODO: investigate GC slowness in earley-boyer
- Try not visiting and not collecting IRFunctions
- Allocation of new heap might be quite slow

[DONE] TODO: profile shape entries
- Which of 1st, 2nd, ... gets more hits
  - Do this based on frequency
- First vs not first?
- Separate with global obj or not
- Use codegen on the branch edge

[DONE] TODO: Meet Marc
- Tested --shape_notags, no type tag spec in shapes
  - Reduces code size on average, in most cases
  - Avg reduction in type tests about 33%
  - Execution time not affected much, no difference on average
  - A bit more with 2+ versions, but not many, still a small minority
  - max versions 8 instead of 7
  - num def shape update is 2x higher
  - Intuition: about pays for itself, but more branches, more def shape host
- Overflow check elimination
  - Not perfect, doesn't do globals
  - Still used several times in most benchmarks
  - Tiny reduction in code size, comp time
  - Tiny reduction in exec time
- Investigated earley-boyer, slower than master branch (old object system)
  - Made 1m ctor call microbenchmark, ctor now much faster than old system
  - Added GC time stat, GC is now much slower
  - earley-boyer is now very fast, but GC takes 80% of the execution time
  - difference in v8/raytrace also accounted for by GC
- Fptr spec
  - Fixed big bug: shapes and fptr not propagating through phi nodes
  - Not necessary to capture closure types
    - Already know in most cases of a.m = function () {}
  - Big speedup on call microbenchmark
  - Not enough calls to make a big difference in general
  - Seems more shape spec leads to more branch misprediction
- ECOOP, December 21st, 2 days after CC notification
  - Redirect our typed shapes paper there
- SPLASH

[DONE] TODO: check how often getProp doesn't know the obj shape but knows the prop name
- Not very much!

[DONE] FIXME: segfault
./higgs tests/02-regress/ir-string.js
- irString works, but the call fails. Why?

[DONE] TODO: num call fast stat
- could be that only a minority of calls are optimized
- most calls are optimized

[DONE] TODO: benchmark shape spec vs no spec
./benchmark.py --csv_file="notags.csv" --num_runs=10 --higgs_cmd="./higgs --shape_notagspec --shape_nofptrspec --perf_stats"; ./benchmark.py --csv_file="spec.csv" --num_runs=10 --higgs_cmd="./higgs --perf_stats"
- Code size smaller, but exec time slightly slower on everything?
- Total type tests reduced by more than 33%
- Could be artifact

[DONE] TODO: implement fptr specialization in gen_call
- start by checking that the information gets there
- look at call_prim code

[DONE] FIXME: seems we might be hitting a call stub when the function is already
compiled. Call stub goes fubar
- Need to compile the function to be able to properly optimize the call
- Must set the entryVer pointer appropriately, no longer point to the stub
- Could potentially do this in the compile function

[DONE] FIXME: often have fptrKnown but null fptr...
- Probably calling clearShape on everything? No

[DONE] TODO: modify GC to forward closure and this based on liveness

[DONE] TODO: add regression test for setting global clos, then setting different clos

[DONE] FIXME: new_clos should set fptr

[DONE] FIXME: phi nodes don't propagate shapes, fptr? oshi

[DONE] TODO: propagate known fptr in get_prop
- use setType

[DONE] FIXME: fptrKnown doesn't make it to gen_call
- Most of the time we do extract the fptr... but it is null!
  - Probably def const of fptr didn't work?
- Does increase the count of shapes significantly!

[DONE] TODO: more pretty-printing on host side
arrays, global object

[DONE] TODO: new cmd arg --shape_nofptrspec
- implement in propType method

[DONE] TODO: valType, fptrKnown flag
- for closure types, capture IRFunction
- do we always want to capture the IRFunction?
- if we know the shape, we know the fptr
- but don't want to store closure shape in objects
- propType should do the conversion to fptr ***
- assert that we never have both fptrKnown and shapeKnown

[DONE] FIXME: ctxDiff, should use isSubType function and inequality, KISS

[DONE] TODO: try array sum bench with int and fp, compare with V8
- array performance sucks... probably too many instructions to compute offset

[DONE] TODO: look into oopsla, OOP confs
- Look at Clark's message

[DONE] TODO: gc time, add to master
- try with splay
- earley-boyer, EGMAGHERD! GC TIME 500MS!!!!1

[DONE] TODO: new ctor benchmark, 1M objects
./higgs --nostdlib --stats benchmarks/micro/1m-ctor-call.js
- Add on master
- Only ~30ms, but multiple GCs

[DONE] FIXME: need clearType, but not clearTag

[DONE] TODO: ovf check elimination, for fun?
- subMax flag
  - clear this flag in propType
- Get code size with and without

[DONE] TODO: CodeGenState.setType

[DONE] TODO: try BBV with and without shape_notags
./benchmark.py --csv_file="notags.csv" --num_runs=5 --higgs_cmd="./higgs --shape_notags --perf_stats"; ./benchmark.py --csv_file="spec.csv" --num_runs=5 --higgs_cmd="./higgs --perf_stats"
./benchmark.py --csv_file="notags.csv" --higgs_cmd="./higgs --shape_notags --stats"; ./benchmark.py --csv_file="spec.csv" --higgs_cmd="./higgs --stats"
- Make sure that shape flips is always zero!
- Try benchmark.py, 10 runs
- Output two CSV files

[DONE] FIXME: getProp with no type tag fucks up...
- Probably because type tag is never written...? Doesn't fix it
- Get proto also had this issue

[DONE] FIXME: use propType and isSubType in set_prop

[DONE] TODO: new cmd arg --shape_notags
- implement use in propType

[DONE] TODO: rename noShape to propType

Marc says: improve system for one week, wrt typed shapes

------------------------------------------------------------------------------

Milestone: Equalling Master Branch Performance
----------------------------------------------

[DONE] Meeting:
- Implemented capture_tag
  - added code to take into account the implicit type tests
- Rewrote optimized set_prop
  - Fast shape switching
  - Now even more optimized, doesn't write type tag if not needed
  - global reads and writes in one single instruction
- Implemented elimination of is_closure test for dynamic calls
  - Quite effective
- Fixed bug, forgot to take shape into account into ctx diff, generic version
- Most benchmarks faster, but there are exceptions
- binary-trees, null vs object, is solved, now much faster
  - ~50% less type tests than with old obj system
  - 4x faster than with previous obj system
- 3d-raytrace
  - 33% less type tests
  - type tests from capture_tag are negligible, definitely pays for itself
- earley-boyer
  - ~6% less type tests
    - 25% less than with old object system
  - uninlined cons cell constructor
    - sees very many types
    - can produce enough shape dispatch to eliminate set prop host calls
  - code size is currently double
    - could be reduced with call optimization, known callee
  - probably cache effects causing slowdown
- Seemingly no explosion of versions (which I was afraid of)
- PROBLEM: object tagged property, another reason we can't have shape...
  - Still possible to have function pointer, specialize method calls
  - Fptr spec is very useful for interprocedural basic block versioning
  - Typed shapes help interp BBV, which helps typed shapes
- Beat V8 on microbenchark, loop to 2 billions
  - Includes compile time, stdlib init
  - Not nearly fully-optimized
  - CGO has rebuttal period... If asked for results, bring this up!
- Optimization ideas:
  - for global shape capture, can optimize based on compile
    time info. Only need one slot
    - Size of shape dispatches likely have big performance impact
  - overflow check elimination
  - can optimize size of heap alloc ops
  - could write code to get code size usage by instr kind
    - also frequency of each instr kind
    - could also put together a profiler, visualize hot asm
      - look into gprof support

[DONE] TODO: blog post: Faster than V8 *
time ~/Dropbox/Linux/bin/d8_dbg --print_opt_code --print_code_verbose loop-global-incr.js 
- dev-maxime branch, link
- Moving target
- Slow compile times and inlining
- Higgs values unboxed, separate tags

[DONE] TODO: peephole for i32 to f64 conversion

[DONE] TODO: upgrade V8

[DONE] TODO: is_closure opt
./higgs --perf_stats benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js 
./higgs --perf_stats benchmarks/sunspider/access-binary-trees.js
before:
    binary-trees code size: 305356
    earley-boyer code size: 2730222
after:
    binary-trees code size: 300043
    earley-boyer code size: 2559128

[DONE] TODO: modify shape_get_proto to extract type tag info when known

[DONE] TODO: modify def_const, setProp to not save shape info

[DONE] TODO: time 1M calls, 1M prim calls
1M calls ~ 10ms
prim calls about 20x faster
- size of calls may still matter
  - adds conditional branches
  - multiplied by shapes
- boyer has 2200 call sites
  - 700K of call site bytes out of 3MB

[DONE] TODO: setProp, don't pass defShape

[DONE] TODO: refactorings
st.setType(type) => st.setTag
ValState.setType(tag) => setTag

[DONE] TODO: refactorings
as.setType, as.getType in jit/utils

[DONE] TODO: refactorings
retTypeReg => retTagReg
getTypeOpnd => getTagOpnd
auto typeOpnd = st.getTypeOpnd

[DONE] TODO: refactorings
- get_type => get_tag
- type => tag in layouts

[DONE] TODO: refactorings
- Type => Tag
- type => tag
- Type type => Tag tag

[DONE] TODO: refactorings
typeWritten => tagWritten
writeType => writeTag
- ValType.typeKnown => ValType.tagKnown
- ValType.typeTag => ValType.tag

[DONE] FIXME: set_prop loads capacity but doesn't use it

[DONE] FIXME: in earley-boyer, 660K host dispatch because of "prototype" prop get in new
- Try inlining specialized getprop code directly in new
- Otherwise, could h4xx special get_prototype for closure
  - Doesn't produce type tag
- in v8/raytrace, also issue with apply ***
- Fixing this doesn't change much...

[DONE] TODO: add missing type tests from capture_type

[DONE] TODO: look into earley-boyer slowness
$rt_se: 866002
$rt_objGetProp: 659438
- also an issue with v8-raytrace
num set prop host: 109956
- car & cdr, val type unknown
num heap allocs: 324053
- this is because new now is self-hosted

[DONE] TODO: run ./benchmark.py, compare to master
./benchmark.py --higgs_cmd="./higgs --perf_stats"
- earley-boyer 2x slower, should examine why
- v8-raytrace also slower
- nothing outrageously bad
- code size somewhat bigger, 15%

[DONE] FIXME: capture_tag with setGlobal produces errors
./higgs es5.js
run-time error: Error: unhandled type in toString
$rt_toString(293B) ("runtime/runtime.js"@461:5)
$rt_add(2972) ("runtime/runtime.js"@764:31)
testOp(16E6F) ("./tests/00-runtime/es5-cmp.js"@115:13)
A setProp updates the global obj shape...
According to getProp, the obj shape is unchanged, why?
Shape dispatch problem?
getProp relies on shape dispatch to get the object shape...
Do we even check for compatible shapes in versioning????
- Forgot to take shapes into account in ctx diff, generic version

[DONE] TODO: add capture_tag to runtime

[DONE] TODO: get rid of set_prop_fast vs set_prop, shape_type_match
- set_prop should implement whole logic
- know ahead of time if type matches or not
- if mismatch, use slow path

[DONE] TODO: implement capture_tag(x)
- KISS

[DONE] Meeting:
- CGO deadline extended
  - Proofread by 3 people, minor proofreading changes
  - Changed title and abstract on submission website
- Found issue: making IR for get/set prop "bigger" leads to poor scaling
- Tried to optimize live vars analysis
  - Huge memory footprint, up to 8GB
  - Significant amount of execution time
  - memory footprint reduced quite a bit
  - mixed success wrt execution time
- Blog post, over 18000 views
  - D co-creator has decided to rewrite the GC
- Eureka: capture_type(x) vs capture_shape(x)
  - once again, struggled about how to implement efficient machine code
  - self-hosted implementation is slow, but makes the logic much simpler
- Next paper, typed shapes, what will we say?
  - Need to think about what will be compared against what
  - Typed shapes w/ dispatch vs inline cache?
  - Typed shapes w/ dispatch vs no type info propagated? simplest ***
  - Or do we just want to present the idea?

[DONE] TODO: better live set implementation for liveness analysis?
- union of small arr with associative array
- what is the worst case ever found?

[DONE] TODO: think about capture_type(x)
- Type dispatch
- If type is known, compiles to nothing
- Capture type tag and possibly shape as well
  - Var len encoding??
  - If simple types, probably need only 2 cmps
  - If values are known obj, put shape extraction code
  - Could examine types at compile time
  - If currently obj/closure, guarded shape extraction
    - if not expected extobj tag, jump to generic version
    - then extract shape, test cascade
    - Will work for current shape_get_def usage
    - must support null vs obj?
- Could possibly replace shape_get_def by this
  - Makes dispatch instrs shorter, no def shape move
  - Eliminates superfluous moves
  - set and get can implement their own inline cache
- 3 code gen modes
  - found closure, guard then get one shape, otherwise unknown
    - must check that the value is a closure, then get its shape
    - set both type tag and shape
    - only one line of dispatch needed
  - obj/arr type tag known
    - shape dispatch with multiple entries, as before
  - other type tag known
     - pass through
  - unknown type
    - dispatch with up to 3 type tags
    cmp mem, tag; jmp target
- No longer care about prop names

[DONE] FIXME: valsLiveBefore, valsLiveAfter misbehaving, breaking GC
- could we have duplicates?

[DONE] Liveness analysis is much faster, but code gen is slower.
- May be D GC slowdown
- Try live set reserve? no effect
- Try reserve again? 3x faster at 1024MB, but slow again at 2048
- Try malloc'ing

[DONE] TODO: reimplement faster liveness analysis with list sets
- Performs more poorly

[DONE] TODO: perf study with dummy benchmark, blog post
- get global a, does comp time scale linearly?
./higgs gentest.js -- 6000 > test.js; ./higgs --perf_stats --nostdlib test.js
5K          100ms
50K         2828ms
60K         5848ms              8GB peak mem usage
100K        mem alloc failed
 360041  4021724324  4020121867       11165     pure nothrow ir.ir.IRDstValue[] object._dup!(ir.ir.IRDstValue, ir.ir.IRDstValue)._dup(ir.ir.IRDstValue[])
     69  3692005953  3244254480    47018180     ir.livevars.LiveInfo ir.livevars.LiveInfo.__ctor(ir.ir.IRFunction)
- IRDstValue[], where is this used? is this also in LiveInfo?
  - reg map init, save 25% of time by making it a fixed-size array
  - two lines of code changed
    ./higgs gentest.js -- 60000 > test.js; ./higgs --perf_stats --nostdlib test.js
    comp time (ms): 4538
    peak mem usage (KB): 8409440
- Just allocating the big array is super slow...
  - Maybe try using malloc or something?
  - array is 8GB in size!

[DONE] TODO: test on earley-boyer, max number of live values at any point
- max 64, avg around 1-4

[DONE] TODO: look at popen bug signaled by Brett
- Add test
- popen is pretty much broken
var stdlib = require('lib/stdlib');
var output = stdlib.popen("ls -a", "r");

Recursive type issue
- Don't want to have an infinite cycle of shapes
- If too many children with shape ptrs, limit
  - only allow 1 exact shape ptr, none if null/undef already there

Marc proposes having union types
- Union on type tags?
- When adding properties, new shapes are created?
- Marc would like to have recursive shapes, if possible
- Building recursive types doesn't seem to work...
  - Shapes built incrementally, can't refer to self

Meet Marc Friday afternoon *** ~ 2PM
- Hidden type tests
- Typed shapes
  - Implemented separate type check instruction
    - Code now cleaner
    - 3d-raytrace, 50% less type tests
    - issue with initialization to null or undef (e.g.: tree nodes)
  - optimized property read further
  - simplest solution: if ctor init to null or undef, can set shape type to unknown
  - in the case of global write, can predict against undef, in favor of new type
    - change global obj shape to match new type
  - alternatively: type dispatcher instruction, similar to shape dispatch ***
    - use this instead of type check instruction
    - captures type of value before write, uses small inline cache, generates code paths
    - basic idea: we *need* the type of the value written at property writes
    - if the type is already known, compiles to nothing
    - probably flexible enough, avoids the issue of speculation errors
    - can optimize shape transitions as well
- Gathered some numbers about shape changes
- Linked list paradox
- Submitted abstract
- Paper: can we claim fast compilation times? Not measured
  - Higgs currently has slow compilation times

[DONE] TODO: count how many type changes actually occur in benchmarks
- add stat for this, shape type change
- earley boyer has about 53K, out of over 1M set props
- v8 raytrace and others have very few
- worst offenders
    splay       45K shapes  109K shape flips    1.5M setprop    2M getprop
    boyer       41K shapes  53K shape flips     755K setprop    3.9M getprop
    richards    4K shapes   8K shape flips      51K setprop     244K getprop
- earley-boyer, splay and richards flip between null and object

[DONE] FIXME: shape disagreements for functions in stdlib/string
- types seemingly random
- other global functions have types seemingly initialized to random values
- if type is known in state, then it isn't necessarily on the stack!

[DONE] TODO: look at binary-trees, currently slow
- more set prop host than not
- seems first TreeNode is constructed with null children, speculation fails
- also have one unpredicted type in TreeNode, why?
  property is "right"
  presumably, prediction fail causes obj type loss

[DONE] TODO: count type tests in shape_test, gen_call

[DONE] TODO: getProp, don't even need capacity in some ext table cases
- If type known, don't reextract capacity

[DONE] TODO: set_prop_fast, optimized prop write
- verify that the shape is writable

[DONE] TODO: insert new shape_type_match, verify that tests pass
- commit once passing

[DONE] TODO: set_prop with host fallback

[DONE] TODO: shape instruction to check if value type matches, shape_type_match
- problem is property addition? need to speculate
- could also create prop shape???
  - requires changing object shape (doable)
  - obj shape known, prop shape known to be null
- if the prop shape is unknown (not known null), shape_type_match returns false
  - slow set prop is taken

[DONE] Meeting:
- set_prop instruction, many cases to handle, complex code
  - but all the complexity is in that instruction
- Got very basic shape type prop working
  - set_prop only optimized if type tag known, otherwise host call
  - on simplest benchmark, bitwise-and, produced significant speedup
  - on other benchmarks, marked slowdown, but not completely terrible
    - 4x as many getprops as setprops
- Attempted speculative property writes with fallback
  - surprisingly few fallbacks, few shape changes needed
- Global prop reads can be super optimized, no type read, no capacity check
  - Just one word read
  - Soon, optimized function calls
- Could possibly get rid of type array in objects
  - But GC needs additional complexity when visiting objects

[DONE] TODO: install DMD

[DONE] TODO: use benchmark.py to measure avg host set prop
num set prop: 28566
num set prop host: 28566

[DONE] FIXME: gc bug exposed by cube example
- Issue with Array.prototype.map
  - simplify further, extract map code?
- Save regression test
- Seems like supernumerary arguments might not be getting forwarded

[DONE] TODO: further optimize setProp

[DONE] TODO: specialize getProp for shape type spec
- Type tag only first
- Huge potential benefit for bitwise-and and such

[DONE] TODO: change setProp for shape type specialization
- start with simple case, known type, no host call needed

[DONE] Meeting:
- ~3x faster on getprop loop microbenchmark
- Fixed GC bug
- Fixed static global const resolution bug
- Identified perf issue with obj and array alloc
  - Now fixed, beating old obj system on most benchmarks (but not all)
- Improved register allocator, less phi moves, smaller code
- Ready to attempt shape type spec
- CGO: committee is very much involved in code gen, performance optimization,
  vectorization, GPGPU
  - One member worked on DynamoRIO, which does tracing
  - Rewrote abstract, intro to change spin or article
    - More towards exploration of a new technique, proof of concept
  - Article too long, remove eager vs lazy discussion?
    - May be confusing, not that pertinent?
- ACM Transactions on Architecture and Code Optimization: http://taco.acm.org/
- Lack of collaboration with Baptiste... working separately, publishing separately?
  - Working on very similar projects, but competing?
  - Other professors make students collaborate on publications

[DONE] TODO: try porting 3D OpenGL math lib to Higgs
- tojiro agrees :)
https://github.com/toji/gl-matrix

[DONE] TODO: try earley-boyer with noinline, nopeephole
- with noinline, compile time is halved, exec time goes up 8x
- disabling peepholes increase compilation time

[DONE] TODO: use xorps to zero out XMM

[DONE] TODO: make setProp host function change shape based on type

[DONE] TODO: add num set prop vs num get prop stats
- On average, benchmarks do 15x more getprop than setprop

[DONE] TODO: optimize numberToString a bit, called many times
- who's calling this, too?

[DONE] TODO: fix host set props in v8-raytrace
num set prop host: 66756
- Calls to set prop come from arguments object allocation, "callee" property setting
- May want an inlinable setArrPropNoCheck

[DONE] FIXME: some phi word moves seem clearly unnecessary
./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/loop-global-incr.js

[DONE] TODO: investigate performance of 3bits-byte
./higgs --jit_genasm --perf_stats --e "print(fast3bitlookup.asmString())" benchmarks/sunspider/bitops-3bit-bits-in-byte.js
- multiple reg to reg phi moves
- should compute number of phi word moves dynamically?
- can try to modify getDefReg to minimize phi moves

[DONE] FIXME: redundancy in set_prop, get_prop
./higgs --nostdlib --perf_stats benchmarks/sunspider/bitops-bitwise-and.js
- need to define an objReg
; shape_set_prop $2, "bitwiseAndValue", $23, $22
mov rax, rcx;                           4889C8
mov ebx, [dword rax + 12];              8B580C

[DONE] TODO: look at performance, code for bitwise-and
./higgs --nostdlib --perf_stats benchmarks/sunspider/bitops-bitwise-and.js
./higgs --jit_dumpasm --nostdlib --perf_stats benchmarks/sunspider/bitops-bitwise-and.js
- are there still string value moves? no
- still 1-2 ms slower

[DONE] FIXME: gc/graph test goes into infinite loop?
./higgs --e "test()" tests/core/gc/graph.js
$2 = eq_refptr $5, "PREWS"
- No match for state variable
- state name string is phi node
- Presumably, some string value is not forwarded by the GC?
  - It's a phi argument!

[DONE] TODO: get rid of set_str? could have an IRStringVal?
- Gets allocated during JIT comp
- No more link idx for strings
- Could have a global string constant table in the VM
  - all of the same str consts point to the same IRStringVal
- Pool of IRString objects, mapped by name
  - Don't even allocate in string table if not necessary!
  - Use for set_str
- Problem: getWordOpnd
  - type is a constant, not a problem
  - str ptr value is stored in IRStringVal object
  - IRStringVal ptr needs to be loaded into reg
- What we want is the loaded value, in some reg ***
  - Use alloced reg or tmp reg to load imm IRStringVal
  - Then load from offset into itself
  - Will need to special case getWordOpnd for IRStringVal
- May need special case for phi moves

[DONE] TODO: capture param name with alias in defRTConst

[DONE] TODO: get rid of IRFunPtr?
- Already don't use it in call_prim
- But we do use it in NEW_CLOS

[DONE] TODO: re-test perf with benchmark.py
- faster than master on several benchmarks
- almost as fast on average, but not quite!

[DONE] PROBLEM: new operator doesn't create objects from obj proto...
- 3d-raytrace and access-binary-trees still suffer from slow shape_def_const
- can still optimize for empty shape and __proto__
- but need some kind of dynamic cache
- in setProto, try calling shape_get_def obj, "" on proto val
  - see how much slowdown there is
  - then, can check if valVal has known shape

[DONE] TODO: num shapes stats, increment in ctor
- print next to num blocks

[DONE] FIXME: obj/arr alloc is about 50x slower in dev-maxime
./higgs --nostdlib --perf_stats --e "for (var i = 0; i < 50000; ++i) o = {};"
- D string alloc, maybe?
  - We do use extractWStr(strPtr);
- Try tempStr just to see if speed difference
- The whole of shape_def_const incurs a big slowdown
  - Internal workings, not the call itself per-se
- Could specialize just for proto (main purpose of this instr)
  - check that name is known __proto__
  - Check that obj shape is the empty shape
  - Check that obj is proto with correct shape
    - can check that it comes from get_obj_proto
    - dynamically verify that shape is same as at compilation time
  - If there is a mismatch, do regular call
- Not that simple, doesn't work for new operator

[DONE] FIXME: bug in gc-call-cont
./higgs --nostdlib tests/02-regress/gc-call-cont.js
./higgs --nostdlib --jit_trace_instrs --jit_dumpinfo tests/02-regress/gc-call-cont.js
entering gcCollect
leaving gcCollect
entering gcCollect
Assertion failed (runtime/vm.d@1227): no return entry for return address: 7F8F2B81CEB8
Assertion failed (jit/jit.d@2135): current instr is not null
Segmentation fault (core dumped)
- eval_str instruction causes compilation, compilation causes allocation, GC stack traversal fails
- probably, some function that is currently executing got mistakenly collected
- log traversed functions
- log collected functions
- GC gets triggered during compilation of eval_str...
  - But we haven't really entered the fn yet...
- Fixed curInstr param to compile
- Added GCRoot for fun object to prevent collection

[DONE] FIXME: getGlobalInl not inlined in newObj
./higgs --nostdlib --perf_stats --e "for (var i = 0; i < 50000; ++i) o = {};"
$0 = set_str "$rt_OBJ_MIN_CAP", <link:16375>
$8 = call_prim "$rt_getGlobalInl", <fun:NULL>, $0 => entry(4FF4)
- Didn't remove the call after statically fetching the constant!

[DONE] TODO: why is 3d-cube 2x slower
./higgs --stats benchmarks/sunspider/3d-cube.js
- previously, newArr was inlined
- obj/arr alloc was previously much faster

[DONE] TODO: obj r/w, try to use cmov, see if perf impact
./higgs --perf_stats --nostdlib benchmarks/micro/200m-getprop.js
- Results inconclusive, seems slightly slower!

[DONE] Meeting:
- Global setters working
- Found and fixed latent GC bug
- Added stats to underdstand behavior
- Optimized global object tracking
- Optimized several shape ops
- Looked at machine code
- Making sure that shape info propagates where it needs to and is used effectively
- Implemented property lookup cache (Moz has this), much speedups
- Optimized global property access, property reads/writes
- Some benchs now faster, most slightly slower
  - Confiante que je peux depasser ce niveau de performance
- Shape profiling, want to experiment
- Calls often kill shape info
  - May want more aggressive inlining
  - Only inlining primitives right now
  - about 1.5x known shape per dispatch on average
  - adding type info will bring more benefits
- Started work on paper
  - Initial commit
  - Page limit is 10, 1.25 page above limit
    - Transform related work into background?
  - Anonymity, no hints of identity, use placeholder name for Higgs?
  - Good news: CGO really centered on compilation, more so than CC/DLS
  - Notification on Nov 3, PLDI deadline is Nov 13
    - May resubmit with very light or no modifications
- Typed Shapes paper, Computing Frontier, Jan 2015?
- Side-note: future compilers, BBV should be done at IR-level, not in backend
  - this is becoming more and more obvious as I work on Higgs
  - generate transformed IR block versions
  - no context object, info is embedded in transformed IR, better for mem usage
  - simpler backend, compiles incrementally but doesn't transform code, handle ctx
    - requests new IR be generated when needed
  - better for incremental inlining
  - not planning to refactor Higgs this way, too much work

[DONE] TODO: global obj r/w opt, can guarantee minimum global obj size
./higgs --nostdlib --perf_stats benchmarks/sunspider/bitops-bitwise-and.js
- Small but nice speedups :)

[DONE] FIXME: floating-point parsing error, fix this *on master*
h> .098
0.98

[DONE] TODO: test, property undeletion with defineProperty?
- value should be undefined
- set to undefined on delete
- test this, also in V8

[DONE] TODO: post on dlang.org, can we template based on identifier name? capture id name with a template?
vm.defRTConst("ATTR_CONFIGURABLE"w, ATTR_CONFIGURABLE);

[DONE] TODO: test get + value in defineProperty in V8
Object.defineProperty({}, 'p', { value:3, get:function(){} });
- V8 doesn't allow it

[DONE] TODO: try ./benchmark.py again
- 25% slower on average, but several benchmarks now slightly faster
- compile time much slower, twice as many versions, twice as many blocks

[DONE] TODO: replace is_getset by shape_is_getset in get prop?
- Better specialization
- Eliminates need for getset tag and object type :) ?
- But need to have shape attrib for getset, not so bad
- works well for bitwise-and!

[DONE] TODO: optimize ne_rawptr for shape using knownShape flag
./higgs --nostdlib --perf_stats benchmarks/micro/10m_getprop.js
- Make a little hack for now in ne instruction, see perf impact
- best time for bitwise-and is 7ms, often 8 or 10

[DONE] TODO: implement pxor encoding
66 0F EF /r     PXOR xmm1, xmm2/m128

[DONE] TODO: rt_OBJ_MIN_CAP... This is statically resolvable...
- Could we speed binary trees much by implementing static resolution?
  - makes for > 10% speedup
  - eliminates many host updates
  - but shape profiling would fix this too
- Test by replacing by constant value
- Do this at IR level? ir/inlining?
  - Doing it early is more logical, simpler
- look for static calls to $rt_getGlobalInl
  - assert that prop name is known
- Log resolved constants, undefined should be in there too!

[DONE] TODO: prop lookup cache
- what does this do to memory usage? try and see
  - when extending a shape, should wipe the previous cache?
  - could also count lookups in some variable, implement after n > K
- mostly useful for big depths?
- Adding the cache field does not increase memory usage at all...
- Barely makes a difference in memory usage with caching
- Much speedups, several times faster

./higgs --stats benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js
comp time (ms): 2337
exec time (ms): 3677
peak mem usage (KB): 545116

./higgs --stats benchmarks/sunspider/access-binary-trees.js
comp time (ms): 187
exec time (ms): 243
peak mem usage (KB): 73036

[DONE] TODO: investigate, are the updateCache lookups much slower than "host lookups"?
- Design some microbenchmark to find out ***
- 10M def shape host => 782ms
- 10M def shape update => 1750ms
- def shape host with 5 props => 1741ms
- def shape update with 5 props => 2505ms
- update adds constant overhead over host lookup, but...
- lookup with many props must be cripplingly slow

[DONE] TODO: binary-trees still has many def shape host calls, find out why
- is it all f.prototype lookups? print names
  - For binary-trees, overwhelmingly .prototype needing def shape host
  - For 3d-raytrace, mixed, some .prototype but also others
- .prototype lookup is on a function, goes through fallback path!
- Implement getPrototype
- Not useful, produces bigger code, no real wins

[DONE] TODO: shape dispatch count stats, should be dynamic!

[DONE] TODO: optimize getProto? FN called many times in binary-trees
./higgs --stats benchmarks/sunspider/access-binary-trees.js
    comp time (ms): 188
    exec time (ms): 262
    code size (bytes): 391152
    num blocks: 3400
    num versions: 4102
    max versions: 11
    num def shape host: 43100
    num def shape update: 85970
    $rt_getProto: 42658
    $rt_objGetProp: 42437
    $rt_getProp: 42436
- not a recursive property lookup
- not a getter-setter, we know shape is not null
- already know the prop index, technically
- probably don't want specialization based on many proto shapes
  - don't want shape dispatch there
  - if we already know the obj shape, should be easy to fetch the proto
- shape_get_proto
  - For now, just return the proto value and type
  - Eventually, optimize with shape info
- surprisingly, no perf gains!
- less shape info loss, more versions generated, code size larger

[DONE] TODO: whitelist wrt shape info loss in call_prim
- toInt32, toUint32, getProp, newObj
- should help cordic performance quite a bit

[DONE] FIXME: getprop with null shape, that should never happen?

[DONE] FIXME: segfault on ASM generation, FP output bug
./higgs --jit_genasm --e ""
Segmentation fault (core dumped)
- Float to!string fails in ValuePair.toString
- Maybe it has to do with the floating-point registers???
- stack alignment is screwed somewhere

[DONE] TODO: debug block, verify stack alignment in stubs
- when entering the unit, we align the stack pointer
- then we try to push an even number of things to maintain alignment
- util.checkStackAlign
  - add at unit entry and exit
  - verify before entering host code in stubs

[DONE] TODO: e-mail lazy BBV paper to Erick, Vincent

[DONE] TODO: e-mail Brett

[DONE] TODO: create microbenchmark on master, loop-global-incr
./higgs --nostdlib --stats benchmarks/micro/loop-global-incr.js
comp time (ms): 4
exec time (ms): 16719
total time (ms): 16723
code size (bytes): 39361

[DONE] TODO: optimize shape_is_getset using knownShape flag
- used before set prop, causes many spills
- should reduce code size on ./benchmark.py, bitwise-and
before:
    benchmark.py code size (bytes): 620792
    bitwise-and code size (bytes) : 38216
after:
    benchmark.py code size (bytes): 574649
    bitwise-and code size (bytes): 38006

[DONE] FIXME: get_prop, if def shape is null, value should be undef

[DONE] TODO: look into setOutType with shape, do we use that?

[DONE] FIXME: add knownShape flag to ValType
- Right now, if defShape is null, can't count on that info. Is this a problem?
- Could also use rawptr type tag for null values, make shapes never null?
- Alternatively, have a knownShape flag, and a clearShape function ***
- Issue with type tag? Cannot set shape to null, must set type tag to rawptr
  - Kind of retarded, it is a shape value after all?

[DONE] TODO: optimize shape_is_getset branching
comp time (ms): 6
exec time (ms): 7
total time (ms): 14
code size (bytes): 38195

[DONE] TODO: re-examine ASM for bitwise-and, probably still suboptimal
./higgs --nostdlib --stats bitwise-and.js
    comp time (ms): 6
    exec time (ms): 8
    total time (ms): 14
    code size (bytes): 38216
./higgs --jit_genasm --e "print(test.asmString())" bitwise-and.js
- In the loop body
  - 2x useless ne_rawptr
  - 1x useless shape_is_getset
  - 3x set_str

[DONE] TODO: obj fields still init to missing, is this necessary? nope!

[DONE] TODO: global obj shape tracking, get_global_obj is limiting
- Separate IR value every time! Different value in valMap
- NOTE: improving global obj analysis would probably reduce code size...
  - Affects bitops bitwise-and
  - About 50% of shape lookups are on get_global_obj
- Would ideally like some pseudo-function-argument?
  - Then gets tracked in valMap
- Could also be a phi node that isn't a function argument
  - Pseudo-phi-node
- Modify getWordOpnd?
  - returns mem opnd on vmReg
  - is loaded by getWordOpnd for arg
- Inheriting from Param might prevent spilling
  - But may require argidx?
- need special IR value, $global?
- Adding global_obj argument to fn entry breaks global querying...
  - May be an issue with inlining?
    - Can try logging the fn we are doing liveness analysis of?
  - Problem is instr.block.fun, each fun needs its own global_obj ****
  - IRFunction.globalVal

[DONE] TODO: replace all occurrences of $ir_get_global_obj() by $global

[DONE] TODO: inspect IR for fn with global x + y
- get_global_obj is duplicated!
- Fixed issue with inlining duplicating get_global_obj
- Performance on bitwise-and improved slightly

[DONE] TODO: make test with $global used only in getGlobal

[DONE] FIXME: tagcloud benchmark segfaults
./higgs benchmarks/sunspider/string-tagcloud.js
- GC does execute
  (runtime/gc.d@435): gcForward: object not in from-space heap, ptr : 5
- Find out what value this is
  - in the stack roots
  - trying to forward output of $rt_newObj
  - crash in eval string
- TODO: Try commenting out optimized shape paths
  - not shape_get_def
  - not shape_set_prop
  - not shape_get_prop
  - not shape_is_getset
- TODO: log the failing eval function
  - huge fn to parse JSON
- TODO: what triggers the GC?
  curInstr: $4834 = set_str "tag", <link:8457>
  crashes during compilation of set_str *****
  entered through compileCont...
    normally, live values spilled before call...
    but the pointer we have is wrong !?
- Seems it's the return value that's not written !?
  - on our way returning from $rt_newObj
  - before compileCont, the return value is not written on the stack!
  - should make a regression test for this

[DONE] TODO: test shape_init_empty on obj alloc microbenchmark
- create on master
- shouldn't need to do dispatch in alloc loop
- newObj is not inlined!

[DONE] TODO: shape_init_empty(obj)
- currently, setting shape through runtime call
- lose empty shape of object
- get rid of ir_shape_empty

[DONE] TODO: check how many generated caches are from get_global_obj
- About 50%
- Most cache instances are not known

[DONE] FIXME: exec time for bitwise-and still 40ms, look at machine code
./higgs --nostdlib --stats benchmarks/sunspider/bitops-bitwise-and.js
- exec time for nothing is 1ms, bitwise-and is 25ms
- test exec time for setting a few global props once?
- shape_is_getset is unoptimized! done
- shape_set_prop and shape_get_prop are optimized, but we generate the full
  shape_get_def inline cache every time!
- Problem is it's a global variable!
  - Distinct value with $ir_get_global_obj every time

[DONE] TODO: optimize shape_is_getset for known shape

[DONE] TODO: add test for global setter
- in tests/01-stdlib/global.js

[DONE] TODO: shape dispatch, missing soft spills
- causes bug, Higgs fails to init
  - very confusing, values and CodeGenState should be unaffected
  - missing saveAllocRegs/loadAllocRegs
- regs saved/restored properly, but segfault...
  - potentially spilling the wrong values?
- opnd0 is not spilled...
- in instr st, opnd0 not mapped to a reg, wtf

[DONE] FIXME: passing the CodeGenState to the host fn is problematic
- No live ref... It's a copy of the ver state
- implement ext info pointer

[DONE] TODO: optimize shape_set_prop for prop rewrites, affects bitwise-and
- Need to handle ext table for global vars

[DONE] TODO: shape.isWritable

[DONE] TODO: need a $rt_setGlobal
- Use IR instr for basic bootstrap only
  - in IR/ast, define a setGlobal function
    - IRFunction.isPrim && isUnit?
- How does this affect test time?

[DONE] Meeting:
- Thought about paper further
  - Motivation/thesis, Olin Shiver's advice
  - Contrasting with tracing
- Can you create a repo for CGO2015
- Getters and setters working
- Turing Turtle, for fun
- Started integrating typed shapes into BBV
- Implemented shape_get_def, version cache
  - Initially had lookup loop, now cache as code, code patching
- Tried microbenchmark
  - More than 2x faster on prop read loop
  - Not fully optimized yet
- objGetProp and getProto have many many shapes passing through
  - version limit gets hit often
  - Disabled version cache for uninlined runtime functions
- There are few functions where this is actually a problem
  - A few functions are highly polymorphic, but relatively rare in practice
  - earley-boyer is rather problematic... scheme implementation in
- May want to use a profiling phase, or regenerate the version cache periodically
  - Useless to generate a specialized code path for something that occurs only once
  - May want to not generate any optimized versions until hit sufficiently often
    - But this implies a default version must exist
    - May not impact i-cache much, default may stop being used once specialized
    - Eventually, code compaction
    - Warrants further study
- Global object, pseudo-argument?

[DONE] FIXME: bitwise-and is way slower... analyze this! ***
./higgs --nostdlib --stats benchmarks/sunspider/bitops-bitwise-and.js
num def shape host: 3
num def shape update: 4
num set prop host: 0
- Many prop rewrites that are slow/unoptimized??? no
- SET_GLOBAL is quite effing slow....

[DONE] TODO: check how common def_shape fallback calls are
- numDefShapeHost
    num def shape host: 81703 *****
    look at bitwise-and, see what's up
- Also add a stat for def shape update
    num def shape update: 1517

[DONE] TODO: compare ./benchmark.py with master
- Similar trail off of versions... but more blocks reported
  - Due to setProp inlining? Could also be getGlobal!
- Every benchmark slower, even bitwise-and, which is suspicious

[DONE] TODO: compare stats for 3d-raytrace with master
dev-maxime:
    comp time (ms): 594
    exec time (ms): 257
    code size (bytes): 727816
    num blocks: 7277
    num versions: 9041
    max versions: 10
    num get prop slow: 205
    num heap allocs: 33733
    num call: 79571
    $rt_toPrim: 58194
master:
    comp time (ms): 347
    exec time (ms): 118
    code size (bytes): 566875
    num blocks: 4525
    num versions: 5536
    max versions: 8
    num map_prop_idx: 610727
    num prop cache misses: 178
    num prop slow lookups: 11863
    num call: 76070
    $rt_toPrim: 58194
- Sams number of prim calls, good
- Almost twice as many versions generated
- Code size significantly larger
- Comp time significantly longer

[DONE] TODO: reimplement getPropMethod

[DONE] TODO: check how common slow lookups are
- Will be especially slow for large objects
- not very common in 3d-raytrace

[DONE] TODO: optimize shape_set_prop for new props

[DONE] TODO: utility fn for extracting IR string constants

[DONE] FIXME: shapes often unknown in set_prop
make; ./higgs --nostdlib setprop-test.js 
- Strange situation, as if shape_get_def not working
- Theory: we disable all entries for which the defShape is null...
  - This is unwarranted, fix and test
  - Still absolutely useful to know obj shape

[DONE] TODO: reimplement inlined setPropField and test it

[DONE] TODO: re-enable setPropElem

[DONE] TODO: shape/obj microbenchmarks
- create on master first, compare perf
- Do we already have some?
./higgs --nostdlib --perf_stats benchmarks/micro/10m_getprop.js
dev-maxime:
    comp time (ms): 8
    exec time (ms): 21
    total time (ms): 29
    code size (bytes): 37904
master:
    comp time (ms): 23
    exec time (ms): 52
    total time (ms): 76
    code size (bytes): 39651
- More than 2x faster!

[DONE] FIXME: crash in asmString function

[DONE] TODO: shape_get_def, optimize for when obj shape already known
auto objShape = st.getShape(cast(IRDstValue)instr.getArg(0));
- How often do we already know the obj shape?
  - Not that often, but sometimes

[DONE] TODO: optimized shape_get_prop
- no type info at first

[DONE] TODO: clear obj shape on set prop, set attr

[DONE] TODO: CodeGenState.clearShapes
- SpillRegs should clear shapes too? no, not always!
- clear known shapes on calls

[DONE] FIXME: v8bench/raytrace fails, segfault?
make; ./higgs raytrace-runner.js 
make; ./higgs --jit_trace_instrs raytrace-runner.js 
- Some register gets corrupted, problem with outOpnd?
- Very much a heisenbug, changes behavior with subtle code changes
- Not GC-related
$117 = shape_get_def $133, $110 => shape_cont(3C8F2)
shape_cont(3C8F2):
$0 = ne_rawptr $117, <rawptr:NULL>
if_true(3C8F5):
$119 = shape_get_prop $133, $117
Segmentation fault (core dumped)
- slotIdx is corrupted, shape ptr probably invalid
- shape ptr is some random pointer!
We're missing branch moves if the version is not a perfect match. We can't
just jump to the target block, we need a branch edge...
- Use getBranchEdge yo

[DONE] TODO: mechanism to limit version cache? probably want 1-4 versions at most
- After K versions, should redirect to default impl without even calling updateCache
- Cache entries should probably be compiled code?
RETRY:
mov rax, objShape; cmp rax, inShape; mov outReg, defShape; jmp relAddr;
mov rax, objShape; cmp rax, inShape; mov outReg, defShape; jmp relAddr;
mov rax, objShape; cmp rax, inShape; mov outReg, defShape; jmp relAddr;
mov rax, objShape; cmp rax, inShape; mov outReg, defShape; jmp relAddr;
lea cache rxx
call updateCache
mov ret into output
jmp retry/default?
- Cache as code avoids having to jump over data, avoids lookup loop
- updateCache should return the property idx?
- once K versions reached, overwrite jmp retry, change to jmp default (relative)
  - don't need its address, we know it's the last thing at the end of the block
- Use codeblock to rewrite the ASM!
  - could even use linking facilities

[DONE] FIXME: modulo zero dies, add test
- should produce NaN
- Do this on master branch, then pull

[DONE] FIXME: segfault on return instruction in stdlib/array init
- Multiple returns successfully executed. Last one goes to host.
  - Why does return to host fail?
- wsp and tsp not corrupted
- RSP not corrupted either...
- Array reserve fails
- D code fails later
- Subtle corruption happens somewhere?
- Somehow, genBranch needs to be called, otherwise we get an odd bug
  - But genBranch isn't called after gen_ret, for example
  - Might have to do with the targets array storage, experiment with this...
- Issue with targets array manipulation

[DONE] TODO: assert that no phi nodes along shape_get_def edges

[DONE] TODO: shape dispatch in shape_get_def
// Find the defining shape for this property
// This shifts us to a different version where the obj shape is known
// Implements a "version cache" with dynamic dispatching
Issue: needs list of pointers to new versions
- Probably also want an "unknown" version
- Switch to a var len list of successors? More allocations...
- Also need to know which shape these map to?
  - Should know this at generation time
  - Can possibly just store that in the entry context
Version cache is similar to inline cache
- Looks for matching shape ptr, jumps to corresponding address
- Must also produce defShape

[DONE] TODO: take a break, work on random lib
- setRndGen, internal function/closure pointer
  - By default, Math object is rnd gen, use uint16 function
- random.setSeed
- random.int, random.float, random.index
- random.normal
- random.choice: takes array or arguments, $argc
- announce in chat, r/higgsjs
- use in Turing Turtle
- add on wiki

[DONE] TODO: shape_get_def needs to be a branching instr?
- jumps to successor block, like an unconditional jump
- make it branching for regular case first ***
- special instr flag, is branch?
  - OpInfo.BRANCH and instr has output, break block in genIIR? should work

[DONE] FIXME: call to non-function, missing fn name?
- Add regression test for this
  - Both fn and method

[DONE] TODO: have both a slice and preallocated space for successors!
- Make current code work with this setup

[DONE] TODO: post Turing Turtle to r/higgsjs

[DONE] TODO: read this advice, take notes for paper
http://www.ccs.neu.edu/home/shivers/diss-advice.html

[DONE] TODO: pull from master

[DONE] TODO: expanding heap message, log expanding heap to... XXXMiB

[DONE] FIXME: random seed from float

[DONE]FIXME: getTime broken? test

[DONE] TODO: turing turtle, make it in Higgs, dogfooding!
- Make the draw lib easier to use, add support for pixel plotting
- Previous, next, restart, save
- Do this on the master branch, 3rd workspace ***

[DONE] TODO: JIT, $ir_shape_empty, set shape ptr in setOutType
- modify CodeGenState.setOutType to have an optional ObjShape argument

[DONE] TODO: uncomment getPropElem, getPropLength

[DONE] TODO: complete inlinable getPropField function
- Needed to test typed shapes & BBV

[DONE] TODO: short blog post about rejected paper
- dconf talk online, got positive reception on reddit, attracted more potential contributors
  - embed talk video
- paper unfortunately rejected, mixed feedback, 2 more confs
  - quote some reviews
- next paper to be about typed shapes

[DONE] TODO: performance advice wiki page
- post to r/higgs
- objects
- string concat
- minimize indirection, function calls

[DONE] TODO: getOwnPropertyDescriptor
- add tests

[DONE] TODO: fix rt_getGlobal wrt getters
- add test for global getter

[DONE] TODO: stdlib/set
- uncomment and fix tests

[DONE] TODO: stdlib/set, get rid of numSlots, use array.length

[DONE] TODO: stdlib/map, use power of two sizes

[DONE] TODO: improvements to stdlib/map? make some constant props not writable?

[DONE] TODO: add getter/setter tests

[DONE] FIXME: string-unpack-code segfaults after gc
make; ./higgs benchmarks/sunspider/string-unpack-code-quick.js
- May be due to sub-shape collection? It is!

[DONE] ISSUE: collecting sub-shapes...
- JIT may reference sub-shapes, these may get destroyed because no objects are
  currently using them
- Should probably disable GC handling of shapes for the moment
- No need for shape refs
  - All are referenced through emptyShape anyways!
- How is memory usage affected?
  - Doesn't change much
  - Future shape collect should use some LRU mechanism

[DONE] TODO: getters & setters
- Objects tagged as GETSET...
  - Should probably have their own layout if not already defined
  - Have special alloc code? Simple, null proto
  - newGetSet(get, set)?
- descriptor .get and .set
o = {}; Object.defineProperty(o, 'p', { get: function() {return 5} });
o = {}; Object.defineProperty(o, 'p', { set: function(v) {this.k = v} });

[DONE] TODO: $rt_shape_is_getset
- Let getProp/setProp behave normally/simply, KISS

[DONE] Meeting:
- Frustrating: addressed code size explosion, demonstrated speedup, but
  criticism just as harsh as before, if not more
- Comparing against tracing, means implementing tracing
  - Which variant?
  - Unclear if we can do better as-is
- Resubmit
  - No VMIL this year
  - Intel, very soon => noes
  - CGO => Aug 29, notify Nov 3
  - Computing Frontier => Jan 2015, notify Feb 20
  - CC, PLDI
- Journals? How does this work?
- Funding
- Don't put article online, resubmitting soon

[DONE] TODO: fix defineProperty, see moz spec, writable, enumerable defaults

[DONE] TODO: integrate ValType into ValState
- How does this affect memory usage? Not much :)

[DONE] Meeting:
- e-mailed Dave Herman about internship, got response today
  - Michael Bebenita CCd
  - Bebenita says not time to apply for 2015 yet, may be constraints on when
  - Summer? Recontact Apple?
- shape forking
- typed shapes pass all the tests

[DONE] TODO: extra object tests
- Specific enum of Object.prototype
- Add a test for array enum, should only enum numerical keys

[DONE] FIXME: GC & shapes, need to invalidate propDefs

[DONE] TODO: rename subShapes to propDefs

[DONE] TODO: shape forking implementation
- No redefinition of properties by concatenation ***
- No origShape in defProp? Might be needed for replay of prop additions
- Redefining a property replays property additions
  - Can allow caching transitions for this too
setProp
- looks for defShape, 
  doesn't find it, adds new property by concat
  finds it, but incompatible
  finds it, compatible, reads prop
If found but incompatible, can look for cached transition
- If not cached, need to build reversed list by iteration, push into an array
  - Then pop, and re-add properties at new point

[DONE] TODO: IIR, use introspection to auto-define in iir.d, no addOp?

[DONE] TODO: other prototype props non-enumerable
- Function, String, Boolean, Number

[DONE] FIXME: ./tests/06-sunspider/20-regexp-dna.js...
call to non-function "charCodeAt"
***** FAILED! *****
./higgs tests/06-sunspider/20-regexp-dna.js 
run-time error: run-time error: call to non-function "charCodeAt"
RegExpParser_prototype_advance(EFDD) ("stdlib/regexp.js"@89:24)
this.pattern.charCodeAt(this.index)
- Enumerating array keys enumerates reduceRight, other array methods! ****

[DONE] FIXME: Object.prototype props all non-enumerable
for (p in Object.prototype)
    Object.defineProperty(Object.prototype, p, {enumerable:false})

[DONE] TODO: Object.defineProperty ( O, P, Attributes )
- calling hasOwnProperty segfaults
- hasOwnProperty has been redefined with new attribs...
  - deleted? no
- setPropAttrs is wrong... will assign a new index to the property ****!
    auto newShape = objShape.defProp(
        vm,
        propStr,
        ValType(),
        attrs
    );
- maybe defProp should take an optional origShape argument?

[DONE] FIXME: proto gets enumerated
make; ./higgs --e "o = {x:3}; for (k in o) print(k);"
- enumerable flag set?
- defAttrs is 0
- Proto listed is from Obj proto, created by runtime
  - Doesn't use defConst

[DONE] TODO: for-in support, needed for several benchmarks
- shape_parent, shape_get_attrs, shape_prop_name
  - get_parent should skip already defined shapes? can't
- re-enable tests

[DONE] TODO: shorthand for spillLiveBefore

[DONE] TODO: e-mail Marc, inform about status
- only missing feature to pass tests is for-in

[DONE] TODO: fix bug with gc/globalexc
- curInstr is not set when getGlobal exc is thrown?
  - but this is thrown by the throw instruction...
- throwExc can allocate when setting trace info
- GC collect's liveBefore vs liveAfter might be an issue
  - call arguments are not to be forwarded by the GC, even if calls are at the top of the stack?
  - could try to make the GC always scan from the top during throwExc
- Try calling visitStack to build the stack trace beforehand?
- Could also try to reimplement throwExc in terms of visitStack

[DONE] FIXME: segfault after GC, in regression test
./higgs tests/core/regress/jit_set_global.js tests/core/regress/jit_inlining.js 
entering gcCollect
leaving gcCollect
Segmentation fault (core dumped)
./higgs --nostdlib gc_bug.js
set_global "test", $0
gc_collect 0
entering gcCollect
leaving gcCollect
set_global "i", 0
Segmentation fault (core dumped)
- Shapes mistakenly collected

[DONE] FIXME: GC object next mechanism
- must copy original prop values, shape ptr to ext table
- no need to follow long chain, only one degree, then forward ext table

[DONE] TODO: make is to ext table is large enough for all props, to be next obj
- no slotIdx -= madness

[DONE] FIXME: GC, shapes refer to other shapes? careful about deleting?

[DONE] TODO: objHasProp

[DONE] TODO: object extension

[DONE] TODO: __proto__ should be non-enumerable, non-writable
- use shape_def_const

[DONE] TODO: shape_def_const <obj> <propName> <cstVal>

[DONE] TODO: shape_set_attrs <obj> <propName> <attrFlags>
- Or take defShape as argument? doesn't really matter! use prop name

[DONE] TODO: setProp should do nothing if shape specifies not writable

[DONE] FIXME: defConst can't use setProp?
- Alternative: provide some attrs to be set by setProp on property definition
- Defaults to ATTR_DEFAULT

[DONE] TODO: defObjConsts() in object.d
- Define object layout constants needed by the runtime

[DONE] TODO: vm method to define constants
- Auto adds the $RT_PREFIX
- Enforces allcaps naming
- defConst(wstring name, ValuePair, bool enumerable = false)
- defConst(wstring name, int32 intVal, bool enumerable = false)

[DONE] TODO: defConst method for objects

[DONE] TODO: flag bits
ATTR_ENUMERABLE, ATTR_WRITABLE, ATTR_DEFAULT

[DONE] FIXME: getGlobal, need to throw exception on failure

[DONE] TODO: alias const(ObjShape) ShapePtr
- grep for const(ObjShape)

[DONE] TODO: test make; ./higgs --jit_trace_instrs --jit_dumpinfo --nostdlib --e "x=3; x+4"

[DONE] FIXME: set_prop call conv

[DONE] FIXME: lookup of undef global segfaults
make; ./higgs --jit_trace_instrs --jit_dumpinfo --nostdlib --e "z"
- lookup on object prototype, has empty shape
- but obj proto still shouldn't have size zero!
- value we recurse on is not proto...
- calling convention used by D is effed... 
  - Dec RSP and pass a pointer instead

[DONE] TODO: get VM init without stdlib to complete

[DONE] FIXME: get_prop call conv

[DONE] FIXME: global obj cap is 0???

[DONE] FIXME: VM segfault before any compilation takes place
make; ./higgs --jit_trace_instrs --jit_dumpinfo --nostdlib --e ""
compiling instr: $2 = call_prim "$rt_setGlobal", <fun:NULL>, $0, undefined => call_cont(E02)

[DONE] TODO: need a set_global instr to use for unit globals
- re-get from github, place after shape instrs
- set_global cannot throw exc

[DONE] TODO: srand function, on master branch

[DONE] TODO: try initializing bare VM
./higgs --nostdlib --noruntime --e ""
./higgs --nostdlib --e ""
Assertion failed: cannot inline non-closure "$rt_setGlobal" in "runtime_layout_js(DF5)"

[DONE] TODO: fix up core of runtime.js obj code

[DONE] TODO: fill in ops.d shape code

[DONE] FIXME: set_prop, seems like it might be better all-in-one?
- can cause a shape transition
- useful to know shapes during setProp, will make for a much faster system
- don't want to implement dynamic shape dispatch in setProp
- can't do real shape transition without prop type

[DONE] TODO: deleted flag should produce null in getDefShape

[DONE] FIXME: change shape_prop_idx
- should really produce the shape defining a property, much more useful
- avoid having to do a second lookup in get_prop
- shape_get_def

[DONE] TODO: subtype test function

[DONE] TODO: functions in object.d to manipulate objects
- comment out existing, code breaks here

[DONE] FIXME: don't want to create a new shape on every prop definition
- Need a "defProp" method that does a lookup through sub-shapes

[DONE] TODO: figure out setProp first
- Need some fast way to lookup property additions with names and types

[SKIP] TODO: clos_shape, arr_shape?
- clos has __fptr__, array has __arrtbl__
- but every closure fptr is unique!

[DONE] TODO: get_global, set_global, reimplement these as runtime functions?
- RT calls don't need get_global
- setGlobal(propName, val)

[DONE] TODO: new object layout, is its own ext table
- Is it much different? Still has num props
- next is ext table?

[DONE] TODO: commit before changing object impl

[DONE] TODO: contact Dave Herman, head of research group at Mozilla

[DONE] TODO: begin sketching basic IR instrs for shapes
- KISS for now, unoptimized
- simplest implementation possible

[DONE] TODO: type from value

[DONE] TODO: begin coding simple ObjShape class
- Each ObjShape has a map of wstring field names to property descriptors (idx, type, flags)
- Method to define new property (& type?)

[DONE] Next meeting:
- Contacted Eddy Bruel wrt shapes, got slides & insights
- Removed call_new instr, simplified code in a few places
- Typed shape, came up with basic design, started to sketch out code
  - ObjShape class
  - Operations that cause shape transitions down a "shape tree"
  - New IR instructions
  - Shape-driven versioning
  - Shape changes
- Typed shape milestones, shapes V0
  - At first, BBV won't take advantage of it, just replacing current obj system
  - June, July, August, (september if not CC but PLDI)
- Basic block versioning as my thesis
  - Intra BBV + typed shapes + interproc BBV
  - BBV becomes complete alternative to interproc type analysis
  - More powerful, simpler, faster alternative to Brian Hackett's work
  - No need for on-stack replacement, invalidation of code
- Internship with Paul Khuong in NYC? 
  - Systems programming, micro opt, multithreading
- Should I contact Dave Herman myself?
  - Understand you are busy, I'll have to deal with them eventually

[DONE] FIXME: load(); used in the repl, or with --e "load()", or
in --repl "file.js" - ( when no arg is provided ) === Segmentation Fault

[DONE] TODO: define type struct for BBV & shapes
- Type tags, flag bits, unknown type flag, known shape flag
- For functions, use shape, not IRFunction
  - Function shape will store fptr

[DONE] TODO: investigate earley-boyer slowness further
- Mostly slow when run in the test-runner
- benchmark.js file has 11K blocks
- optIR of the benchmark JS file is the really slow component
  - Just 4 passes executed!?
  - deleting tons of "jump call_cont", "jump call_merge" instructions
- Many many inlined functions?
- delPhi, delBlock sanity checks iterate over whole function!

[DONE] FIXME: eval of non-string type causes segfault

[DONE] FIXME: earley-boyer using large amounts of memory without call_new, very slow
- seems like exec time is unchanged, comp time massively slow
- Are the newThis and ret calls always inlined?
- Profile, find out what's so slow
- Hypothesis: not inlining newThis results in HUGE objects allocated
  - Looks like not, just very long compilation time ***
- Reserving more space for the D GC doesn't improve things

[DONE] TODO: sketch runtime.js implications of typed shapes
- getProp, setProp
- BBV branching w/ shapes (added later?)
- What happens when shapes change from setProp?

[DONE] TODO: sketch ObjShape class functioning

[DONE] TODO: eliminate CallCtx, use IRFunction
- simplify design
- VM pointer is stored in there!
  - Could store VM ptr in IRFunction, simply!

[DONE] TODO: eliminate double function entry point, isCtor
- makes for redundant code, poor design
- before, benchmark.py:
    code size (bytes): 457053
    comp time (ms): 150
    exec time (ms): 67
    num blocks: 2091
    num versions: 2467
- after:
    code size (bytes): 409130
    comp time (ms): 148
    exec time (ms): 67
    num blocks: 2049
    num versions: 2426

[DONE] TODO: put gittip link on blog sidebar

[DONE] FIXME: tests/06-sunspider/18-string-validate-input.js...	
Assertion failed (jit.jit@600)
- Can't find register to spill
- Call with massive number of arguments

[DONE] TODO: eliminate call_new

[DONE] TODO: contact Eddy Bruel wrt shapes, ask for slides
EJPBRUEL@MOZILLA.COM
- ask about multiple successive transitions, constructors

[DONE] TODO: at home, prepare spreadsheet for travel expenses

[DONE] June 10th meeting:
- *** Mozilla internship, contact Mozilla ***
- Interprocedural BBV
  - Issue: who am I calling? If unknown, need to test, if polymorphic, this is an issue
  - Typed shapes would make this less of an issue, make interp BBV more efficient
- Typed shapes: improvement upon inline caching, more powerful generalization
  - Very small code to read/write properties
  - For constants, no code at all
- BBV, maybe should take code size into account, code size budget
  - Blocks that compile to nothing maybe shouldn't count towards version limit
  - Blocks that are very small should maybe count for less
- Laundry list: better inlining
- Reg alloc: one of the big gains is in boxing/unboxing
  - We don't read types from the type stack
- Marc: direct energy on typed shapes
  - if you start now, may be publishable for CC or PLDI
  - Major advance for BBV

[DONE] TODO: push to dev-maxime, then master
- disable analysis always on
- prealloc in main, 256M

------------------------------------------------------------------------------

May 31st, complete paper writing
--------------------------------

[DONE] TODO: log typing info for 3d-raytrace, see what's up
- Why 1500+ versions?
- Grows quickly with int32/float64/unknown
- Every time we have a type test, is_t(x), must also create versions along the
  branch where we gained no type information, even if it's never taken

[DONE] TODO: toString for CodeGenCtx

[DONE] TODO: add timing of run to benchmark.py

[DONE] TODO: test benchmark.py with maxvers=200
./benchmark.py --csv_file="eager.csv" --higgs_cmd="./higgs --stats --jit_maxvers=200 --jit_eager"
- Problems:
  - horrible pathological cases, particulartly due to overflow?
  - compilation time is incredibly long... problematic for benchmarking time with multiple runs
  - searching linearly through versions probably doesn't scale
- Half the benchmarks generate more than 200 versions

[DONE] TODO: test benchmark.py with maxvers=100. See if effect on type tests is
still as pronounced.
./benchmark.py --csv_file="eager.csv" --higgs_cmd="./higgs --stats --jit_maxvers=100 --jit_eager"
- check that no benchmark produces more than 100 vers
  - many reach 100!
- type test effect less pronounced but still present.

[DONE] TODO: test the 4 benchmark.py configs
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20 --jit_typeprop"

[DONE] FIXME: jit_eager segfault on string-tagcloud benchmark
./higgs --jit_eager benchmarks/sunspider/string-tagcloud.js
Assertion failed (runtime/vm.d@822): no free link entries
Assertion failed (jit/jit.d@1978): current instr is not null
- Made link table larger

[DONE] FIXME: segfaults with jit_eager, gc bug
unpack-code, fasta, splay, tagcloud, base64, earley-boyer, valid-input, regexp-dna
- Start with base64, simpler
./higgs --jit_eager benchmarks/sunspider/string-base64.js
- Quick version of benchmarks doesn't segfault... GC?
Assertion failed (runtime/vm.d@1201): no return entry for return address: 7F531C8DB903
- Continuation stub previously set ret entry when compiled
./benchmark.py --higgs_cmd="./higgs --perf_stats --jit_maxvers=20 --jit_eager"

[DONE] TODO: implement eager codegen
--jit_eager
- getBlockVersion should ignore noStub
- What about continuation stubs? Avoid generating
./benchmark.py --higgs_cmd="./higgs --perf_stats --jit_maxvers=20 --jit_eager"
  - Can try maxvers=5 if too slow?
./benchmark.py --higgs_cmd="./higgs --perf_stats --jit_maxvers=5 --jit_eager"
  - doesn't fix segfaults

[DONE] TODO: eliminate noStub flag from getBlockVersion

[DONE] FIXME: string-tagcloud
./higgs benchmarks/sunspider/string-tagcloud.js
run-time error: SyntaxError: parseJSON
$rt_throwExc(2DE6) ("runtime/runtime.js"@128:1)
s_parseJSON(12584) ("benchmarks/sunspider/string-tagcloud.js"@210:14)
benchmarks_sunspider_string_tagcloud_js(122C4) ("benchmarks/sunspider/string-tagcloud.js"@237:15)
- benchmark throws this exception, its own parser fails
- could it be some regexp behavior mismatch?

[DONE] TODO: try inlining div? divIntFloat?
- called 41K times in 3d-raytrace

[DONE] TODO: more complete addIntFloat, subIntFloat

[DONE] TODO: add missing leIntFloat

[DONE] TODO: try more complete ltIntFloat?
before (simple):
    code size (bytes): 428135
    is_f64: 43019
    is_i32: 1451946
    max versions: 5
    num blocks: 1893
    num versions: 2318
    total type tests: 4315730
after:
    code size (bytes): 428161
    is_f64: 42998
    is_i32: 1449662
    max versions: 5
    num blocks: 1893
    num versions: 2317
    total type tests: 4312026

[DONE] TODO: look at shootout benchmarks, anything more working?
- Open issues for those not working

[DONE] TODO: eqInt

[DONE] TODO: check how many calls to String slice & charAt earley-boyer makes
- may be worth optimizing

[DONE] TODO: optimize String.substring

[DONE] FIXME: string-unpack-code

[DONE] TODO: test benchmark.py
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20 --jit_typeprop"

[DONE] FIXME: string-base64 segfaults, gc bug
make; ./higgs benchmarks/sunspider/string-base64.js
gcForward: object not in from-space heap
ptr   : 2
start : 7FEEE1D17000
limit : 7FEEE2D17000
header: ???
Segmentation fault (core dumped)
- Fails after many GCs
- Fails during stack visit
visiting frame for: Function_prototype_call(6A68)

[DONE] FIXME: v8bench/regexp
- benchmark moronically redefines RegExp name

[DONE] TODO: look up how to efficiently copy memory, assembler, ask on reddit?
- rep movsq to copy 8 bytes
  src in ESI, dst in EDI
  size in ECX
- try just using load_u64 and store_u64 to test it out

[DONE] TODO: streq, use memcmp
import std.c.string;
- see perf difference on fasta bench
- huge speedup on splay benchmark

[DONE] TODO: try inlining setProp only in functions with loops
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20 --jit_typeprop"
- does seem to produce some speedup

[DONE] TODO: test efficiency of loop test heuristic
- effect on comp time in benchmark.py?
- not an issue

[DONE] TODO: offset computations, muls by 2, 8?
- Transform these into shifts?
- Does it work for negative nos? yes
- Codegen is inefficient...

[DONE] TODO: many calls to setArrElem in splay benchmark, why?
- may be growing arrays, or using float indices... verify ***
  - not float indices
- seems array initialization is the culprit
  - fix for arguments too
code size (bytes): 410668

[DONE] TODO: implement specialized toBool for method calls
- toBoolConst

[DONE] TODO: study uses of toBool in benchmarks
- in richards, if (x.a)
- deltablue, many prop usages as well
- raytrace, also prop uses
- earley-boyer, uses toBool on method calls
- for prop, test consts first? log values tested
- for properties, often:
  - undefined, true, false
  - null
  - objects and functions

[DONE] TODO: eliminate alloc init loops
- would make alloc faster, permit more inlining
- make it so that MISSING is the 0,0 value
- null should be zero as well
- can then remove init to missing, null
code size (bytes): 414837
comp time (ms): 195
exec time (ms): 29

[DONE] TODO: make missing and null have zero value
- missing/const type should be zero

[DONE] TODO: make GC zero out to-space after allocating it

[DONE] TODO: implement AST->IR for new using runtime functions

[DONE] TODO: gen_new_map

./benchmark.py
code size (bytes): 417413
comp time (ms): 189
exec time (ms): 28

[DONE] TODO: test earley-boyer, v8-raytrace without arg count test
- first see if arg count always matches
- speedup?
/higgs --perf_stats benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js 
comp time (ms): 579
exec time (ms): 471
total time (ms): 1051
code size (bytes): 1696981
./higgs --perf_stats benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js 
comp time (ms): 563
exec time (ms): 449
total time (ms): 1012
code size (bytes): 1674514
- Not a huge difference
- May not have that many calls, more news?

[DONE] TODO: map_prop_idx, optimize fallback with soft spills, smaller code
- may be able to gain much speed
- before, benchmark.py:
    code size (bytes): 542166
- after:
    code size (bytes): 503349
    No noticeable time change...

[DONE] TODO: v8-raytrace, many get props for "prototype"
- Implement getPropProto
- before:
    comp time (ms): 2261
    exec time (ms): 167
    total time (ms): 2429
    code size (bytes): 1362565
    num blocks: 8782
    num versions: 13915
    max versions: 18
    num map_prop_idx: 1523308
    num prop cache misses: 1902
    num prop slow lookups: 378047
    total prim calls: 1408078
    ---
    code size (bytes): 542954
    comp time (ms): 801
    exec time (ms): 27
    total prim calls: 326837
- after:
    reduces prim calls but increases code size further

[DONE] TODO: time v8-raytrace with cache size 3
./higgs --stats benchmarks/v8bench/base.js benchmarks/v8bench/raytrace.js benchmarks/v8bench/drv-raytrace.js
- Almost 10x the misses
- Bigger size doesn't improve

[DONE] TODO: suppress set_str if only one use which is map_prop_idx
before code size (bytes): 512680
code size (bytes): 512644

[DONE] TODO: try benchmarks with setProp inlining?
- Can we do better than 9% speedup?
  - Code size reduction, but only 8% speedup

[DONE] Meeting:
- created dls2014 branch
- slowdown seems to be because D allocator is much slower after many allocations,
  possibly needs to GC during execution
  - some allocations are sometimes needed during execution
  - fairest seems to be to run the analysis for all, even if not using the result
- realized that D GC produces huge slowdown, dilutes our gains
  - pre-reserved 1GB chunk, string-fasta is more than 2x faster
  - implemented D string view on JS strings, less safe but often 2x faster
- looked at reviewer comments, took notes
  - impression: reviewers were extremely critical
  - 2 related work suggestions
  - all 3 complained about lack of running time testing
  - one complained about too much code bloat
- tentative new title

[DONE] Blog: News of Higgs
- Graphics lib
- pong, examples
- OSX support find/progress, Paul Fryzel
- working on paper
  - optimizations, further reduced code size
  - type analysis
  - Correcting anomalies, D GC performance
- typed hidden classes

[DONE] TODO: host original BBV paper, link to it in blog post

[DONE] TODO: look into stack allocating strings, referencing Higgs heap data
http://forum.dlang.org/thread/ustyltiooelhlijcjxma@forum.dlang.org
./higgs --perf_stats --jit_maxvers=0 benchmarks/sunspider/access-nbody.js
pre time: 114ms
post time: 54ms

[DONE] TODO: look into GC reserve
static nothrow size_t reserve(size_t sz);
- check how fasta performs with analysis enabled
- Reserving a 1GB chunk makes fasta over 2x faster
./benchmark.py --higgs_cmd="./higgs --perf_stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --perf_stats --jit_maxvers=20"

[DONE] TODO: create dls2014 repo branch
- disable analysis in release first, push to master, then create branch
git checkout -b dls2014
git push -u origin dls2014

[DONE] FIXME: invalid lhs in assignment
true?email='foo':email='bar';

[DONE] TODO: basic TGA image input
- update img lib test to read back and compare img

[DONE] FIXME: CodeGenState.setType should also mark the type as written, for IsTypeOp?
- only if the type operand is mem?
  - could just check what current state is? if type is unknown, set as written
- test on benchmark.py, multiple variants
after code size (bytes): 422722
before code size (bytes): 422843

[DONE] TODO: determine why some benchmarks are much slower with the analysis
- nbody, fasta, date-xparb, richards, deltablue, earley-boyer
- nbody takes almost twice the time
./higgs --perf_stats --jit_maxvers=0 benchmarks/sunspider/access-nbody.js
./higgs --perf_stats --jit_maxvers=0 --jit_typeprop benchmarks/sunspider/access-nbody.js
- type tests reduced, code size reduced, num blocks same, num calls same, prim calls same
  - exec time twice slower!
- slightly less moves, but type not accounted for
FIXME: running the type analysis affects the code size, even without using the result
make; ./higgs --perf_stats --jit_maxvers=0 --e ""
make; ./higgs --perf_stats --jit_maxvers=0 --jit_typeprop --e ""
- The code size is different... How can this be???
- Code block alignment doesn't change
- Values encoded, absolute pointers could be different...?
  - Could cause accesses out of alignment
  - supposedly, same amount of values encoded through ptr()
- Check movAbsRef? No, always 64-bit
- Do a comparative dump, diff it... ***
  --jit_dumpinfo --jit_dumpasm
make; ./higgs --jit_maxvers=0 --jit_dumpinfo --jit_dumpasm --e "" > asm_mv0.txt
make; ./higgs --jit_maxvers=0 --jit_typeprop --jit_dumpinfo --jit_dumpasm --e "" > asm_tpa.txt
- Enabling inlining of setProp prevents slow getPropIdx, which allocate memory

[DONE] FIXME: analysis creates a new BranchEdge object
auto entryEdge = new BranchEdge(null, fun.entryBlock);
cfgWorkList ~= entryEdge;
- create surrogate object if necessary, but avoid this!
- code size discrepancy seems fixed

[DONE] Meeting:
- Booked DConf flight + hotel, total ~1200
- Got invited to midwest.io, Kansas City, refused
- Got invited to Polyglot Conf, Vancouver, refused
- Fixed GC/regalloc bug, added typeWritten flag to reg alloc state
  - Slightly smaller code size, less redundant type writes
- Removed type tagging of hidden args during call (closure, argc, ra)
- Fixed analysis slowness using liveness info
  - Very bad scaling with many SSA values
- Type analysis working on all benchmarks
  - implemented type set
  - performing fairly poorly
  - implemented type set, negative information prop
  - getProp loop, new obj output not tagged
  - tag result of some call_prims? BBV doesn't really need this, but could help
- Paper
  - Resized graphs
  - Added type refinement citation
  - Added highlighted notes
  - Issue: perf stats, interfering with measurement
  - What do we do with graph scales?
- Added octane benchmarks to repo
  - May get some working
  - void operator
- Added missing SunSpider benchmarks to repo

[DONE] TODO: try not adding type info to branches when maxvers=0?
- does speed things up somewhat, but not quite enough!

[DONE] TODO: why is "num blocks" not the same for diff vers counts, 0 vs 10
- 3bits benchmark has this, find out which block is different
- start by seeing if accounting is correct
- ctor blocks may not be properly counted?
- even with everything using getBlockVersion, still get discrepancy
./higgs --nostdlib --jit_maxvers=5 benchmarks/sunspider/bitops-3bit-bits-in-byte.js | sort | uniq > 3bit-mv5.txt
- Accounting appears correct
- Versioning may be able to detect that some paths will be always executed?
  - some of these paths may be in ctor call, actually irrelevant (not executed)

[DONE] TODO: --perf_stats, code size + time
- test with ./benchmark.py

[DONE] FIXME: issue with untagged clos/this?
./higgs --jit_maxvers=0 --stats benchmarks/sunspider/3d-raytrace.js 
run-time error: TypeError: unsupported types in strict equality comparison
$rt_throwExc(2DE6) ("runtime/runtime.js"@128:1)
$rt_se(2F96) ("runtime/runtime.js"@1538:6)
Array(9654) ("stdlib/array.js"@62:36)
benchmarks_sunspider_3d_raytrace_js(129E6) ("benchmarks/sunspider/3d-raytrace.js"@187:12)
- $argc shows up there, type info probably cleared away

[DONE] TODO: calls shouldn't need to tag argc
code size (bytes): 421854

[DONE] TODO: book DConf trip, plane, hotel

[DONE] TODO: calls, shouldn't need to tag RA, closure

[DONE] TODO: work on conf paper, add TODO notes

[DONE] TODO: fetch missing sunspider benchmarks
- string-tagcloud, string-unpack-code, string-validate-input, regexp-dna
code size (bytes): 431337

[DONE] TODO: read/skim you a paper
- Download DLS13 paper

[DONE] TODO: modify resolveVars to capture all parent locals if usesEval is set

[DONE] TODO: implement usesEval flag

[DONE] TODO: analysis, remove type on false branch
.subtract

[DONE] TODO: refactor TypeVal into TypeSet, uint32_t
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop --jit_maxvers=20"

[DONE] TODO: remove bool prop from TypeProp, for simplicity
- Have IsTypeOp do queueSucc, as in BBV

[DONE] TODO: run experiments, where are we at, performance-wise, w/ type analysis?
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20"
- No TA, no BBV
    code size (bytes): 404265
    total type tests: 6479992
- TA
    code size (bytes): 402910
    total type tests: 5560845
- BBV
    code size (bytes): 423263
    total type tests: 2922633

[DONE] FIXME: nextProp, redundant captvars
- list contails many duplicates
code size (bytes): 423263

[DONE] TODO: void expr, unary prefix operator, produces undefined
- needed by zlib benchmark
./higgs --e "runZlib()" benchmarks/octane/base.js benchmarks/octane/zlib-data.js benchmarks/octane/zlib.js
- add parser & core tests

[DONE] TODO: check type analysis code, very bad perf
- are we eliminating much type tests?
./higgs --jit_maxvers=0 --stats benchmarks/micro/10m_getprop.js
20M tests
is_object: 10000782
is_const: 10000275
./higgs --jit_maxvers=0 --stats benchmarks/micro/10m_getprop.js
10M tests
is_const: 10000275
./higgs --jit_typeprop --jit_maxvers=0 --stats benchmarks/micro/10m_getprop.js
20M tests!

[DONE] TODO: add noted citations to paper

[DONE] TODO: copy octane benchmarks into repo, as-is

[DONE] TODO: get type analysis working on ./benchmark.py
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop --jit_maxvers=20"
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20"

[DONE] TODO: succ state gen should decide if phi type is written
- do as the predecessor, save moves
- code size (bytes): 430232

[DONE] TODO: check if toStack is missing writeType(s)

[DONE] FIXME: typeWritten causing GC bug
- typeWritten... setting it to true in writeType causes errors... why?
  - type unwritten???
- Problem might be with block transitions
  - Don't need to take sync into account in diff, but must account for it
  - clear sync flag when creating default version
  - transition into sync should cause write

[DONE] TODO: try rescaling graphs in paper
- Take a break to work on the paper

[DONE] TODO: try removing type write in setOutType
- rename spillRegs to spillValues

[DONE] FIXME: make; ./higgs --jit_typeprop --jit_maxvers=20 benchmarks/sunspider/string-fasta.js
Assertion failed (runtime/gc.d@435): gcForward: object not in from-space heap
ptr   : 3
start : 7F689B14A000
limit : 7F689C14A000
header: ???
- Fails during first GC, visiting stack for nextProp
- with just maxvers=20, works fine
- with just typeprop, works fine
- errors even if prop result not used...
  - even if not queried, just running the analysis causes issues
- type tag is wrong while visiting phi value
  - type string, but value seems to be undef
  - meant to be integer, string length?
- quite possibly, we normally don't test the type tag
  - type tag was probably not written
- during phi moves, type tag is set as const, known type
  - do we not spill it?
Phi to phi moves... Won't spill value if it wasn't in a reg
setOutType: if value is on stack, we write the type to the stack as well
Could change this so spillReg takes care of it?
- Maybe not? Type can become unknown? If it becomes unknown, it must be
written, so long as the value is live

[DONE] FIXME: core_md5 seems stuck in an infinite loop
- function has 1324 blocks
- gets increasingly slow as typeMap grows past 2400+ values
  - typeMap size keeps slowly growing
  - no way so many values are live!

[DONE] TODO: get type analysis working on simple benchmarks
- runs really really slow on nbody's NBodySystem.prototype.advance
- many temps and blocks to propagate along?
  - each condition needs to be evaluated, opens a floodgate for values to propagate through

[DONE] FIXME: math-cordic, analysis assertion failed
make; ./higgs --jit_typeprop --jit_maxvers=20 benchmarks/sunspider/math-cordic.js 
- Problem is that constant value has no type inf
  - Should we be able to eval its type on demand?
  - Just store all arg types, already using that space anyways! ***

[DONE] TODO: get type analysis working on higgs init

[DONE] TODO: check that type analysis doesn't know more than BBV, warn

[DONE] TODO: open issue for lib/plot, specify requirements

[DONE] Meeting:
- looked at more machine code
  - array iteration
  - getProp
- more code generaton tweaks
- reconstructing input operand after add with overflow fixes issue
- obj alloc benchmark, tried with literal
  - primary slowness comes from function calls
  - setPropElem not inlined, 75% of exec time
  - obj_alloc not inlined
- function calls probably bulk of overhead in many benchmarks
  - benchmarks with no or few function calls run very fast
- Began setting up paper, adapting template
- Octane: seems meant to run in a browser
  - V8 benchs in the V8 and SpiderMonkey repos
  - May be able to get some of it working with extra effort
- type analysis
  - can't do much wrt overflow... no recompilation, no ignoring of ovf blocks
  - analysis will necessarily lose very badly in terms of eliminating int/float type tests
    - right now, analysis made to work similarly to the way BBV propagates types
    - should we modify it to use a more advanced type repr, type sets? best type analysis we can come up with?
      - {int, float}, not int means float
    - do we care much about analysis execution time?
      - analysis is flow-sensitive, currently quite slow
- DConf, book plane and hotel, extra days?

[DONE] TODO: convert analysis to "query at given point" model

[DONE] TODO: modify IsTypeOp to use type analysis results
- check for contradictions between type prop and BBV

[DONE] TODO: explain type analysis issues to Marc
- Focus on core concerns
  - slowness
  - should we change to type sets

[DONE] TODO: add assert for unhandled instructions to type analysis

[DONE] TODO: make type analysis run for Higgs init
./higgs --jit_typeprop
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
- store typeMap on IRFunction, like LiveInfo
- for now, get it to work as it was
- beware of unhandled instructions

[DONE] TODO: add missing instructions for Higgs init to type analysis
unhandled instruction: t_41BD = f64_to_str arg_4
unhandled instruction: t_12940 = alloc_refptr 25
unhandled instruction: t_129A4 = is_object t_128F8
unhandled instruction: t_12835 = make_map <map:NULL>, 0
unhandled instruction: t_12837 = new_clos <fun:encodeURIComponent(12831)>, t_12833, t_12835
unhandled instruction: t_129EE = map_num_props t_12921
unhandled instruction: t_129AF = map_prop_idx t_129AE, t_12900, false

[PASS] TODO: download Octane benchmarks
- V8 and SpiderMonkey clearly use v8 to test offline

[DONE] TODO: look at Tom's dev branch, commit log

[DONE] TODO: add test for shifts by negative value
d8> 1 << -1
-2147483648
d8> 1 << -2
1073741824
d8> 1 >> -1
0
d8> 1 >> -2
0
- Shift val is truncated, low bits are used
- Check to see if already present

[DONE] FIXME:
./higgs --jit_genasm --e "print(fast3bitlookup.asmString())" benchmarks/sunspider/bitops-3bit-bits-in-byte.js
; $60 = rsft_i32 59796, $54
mov rbx, rcx;                           4889CB
mov eax, 59796;                         B894E90000
mov cl, dil;                            4088F9
sar eax, cl;                            D3F8
mov rcx, rbx;                           4889D9
mov esi, eax;                           89C6
code size (bytes): 434887

[DONE] TODO: handle lhs constants in RMMOp
./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/loop_array_itr.js
- still need to handle 2 imm ops
- may want to just bite the bullet, handle all cases
code size (bytes): 434937

[DONE] FIXME: gen_ret, this can be simplified
mov rax, [qword r14 + 640];             498B8680020000
sub eax, 1;                             83E801
cmp eax, 0;                             83F800
cmovl eax, ebx;                         0F4CC3
code size (bytes): 443550

[DONE] FIXME: $rt_sub called 1M times in obj literal benchmark...
code size (bytes): 443579

[DONE] TODO: create repeated obj alloc microbenchmark, look at ASM
http://js.datamu.com/index.html
./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/create_obj_literal.js
- quite slow
- setPropElem is not inlined, more than 10x faster if inlined

------------------------------------------------------------------------------

April 15th, milestone: sufficient performance
---------------------------------------------

[DONE] TODO: gc/new test, constructor call with one field set to a constant

[DONE] FIXME: $rt_getProp === 'length', super inefficient
code size (bytes): 444003

[DONE] FIXME: gc/graph, gcForward: object not in from-space heap
ptr   : 2AF975CDC040
start : 2AF9793FB000
limit : 2AF9794719C0
header: 2
make; ./higgs --e "print(test())" tests/core/gc/graph.js
- multiple GCs happen before this problem occurs...
- visiting frame for Node ctor, "this" value
  - who triggers the GC?
- Changing code for Node makes it disappear
- The pointer is right after the heap limit...
  - Already forwarded!

[DONE] TODO: look at ASM for array iteration with counter
./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/loop_array_itr.js
- still have issues with lhs constants

[DONE] TODO: look at ASM for 3bit
./higgs --jit_genasm --e "print(fast3bitlookup.asmString())" benchmarks/sunspider/bitops-3bit-bits-in-byte.js

[DONE] TODO: rebuild x value after overflow
./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/loop_big_incr.js
./higgs --nostdlib --stats benchmarks/micro/loop_big_incr.js
exec time (ms): 2208
exec time (ms): 1783

[DONE] FIXME:
; $2 = mul_i32 8, $1
mov eax, 8;                             B808000000
mov ebp, ecx;                           89CD
imul ebp, eax;                          0FAFE8
mov edx, ebp;                           89EA
code size (bytes): 444717

[DONE] Meeting:
- soft spills for get_global
  - not as much gains as hoped, but some
- optimized codegen for several instructions
  - removed redundant instructions
  - optimized branch ordering
- made add reuse arg reg when possible
  - problem: overflow branch still uses input
- reduced code size by 3.8%
  - from 466599 to 448547
- various bugfixes
- read type refinement paper
  - use type tests in conditionals to refine type information
  - doesn't seem like it has cloning or duplication or extra context

[DONE] FIXME:
; ret $15
mov rax, [qword r14 + 120];             498B4678
mov bl, [byte r13 + 15];                418A5D0F
mov rcx, rax;                           4889C1
mov dl, bl;                             88DA
code size (bytes): 448547

[DONE] FIXME:
; $14 = make_value $0, $4
mov r9, rsi;                            4989F1
mov [byte r13 + 14], r8l;               4588450E
- allow reusing input reg
code size (bytes): 448696

[DONE] TODO: look at $rt_getPropObj ASM

[DONE] FIXME: parseInt(-1) produces 1
- sub is not commutative, cannot reuse right arg reg

[DONE] TODO: look at having getOutOpnd reuse input arg reg
- look at code for loop_big_incr
- phi has a move
- add has a move
code size (bytes): 449623

[DONE] TODO: read type refinement paper

[DONE] FIXME: bug with pong example
make; ./higgs ../examples/pong.js
- GC does not occur
$2 = load_u64 $13, $1
140149759872824
  strProto_get_fid(3EC3E)
load done
$2 = load_u64 $20, $1
140149759872824
  strProto_get_fid(3EC3E)
load done
$0 = load_u64 $10, $25
0
  strProto_get_fid(3EC3E)
- this.font.get_fid()
- Loading from a null pointer
- font.handle is null
- Font fails to load?

[DONE] FIXME:
; $269 = map_prop_idx $0, $44, false
...
mov rbp, [qword rax + 16];              488B6810
mov r12d, [dword rbx + 8];              448B6308
mov r12, r12;                           4D89E4
cmp [qword rbx], rbp;                   48392B
code size (bytes): 462500

[DONE] FIXME:
; $47 = set_str "writeTGA24", <link:NULL>
mov rax, [qword r15 + 168];             498B87A8000000
mov rax, [qword rax + 53704];           488B80C8D10000
mov rcx, rax;                           4889C1
code size (bytes): 463719

[DONE] FIXME: 
; $0 = is_object $376
mov al, [byte r13 + 376];               418A8578010000
cmp al, 9;                              80F809
code size (bytes): 465922

[DONE] FIXME: 
; $0 = ge_i32 $288, 0
cmp edi, 0;                             83FF00
mov eax, 14146;                         B842370000
jge branch_and_sec(33B7C);              0F8D05000000
jmp branch_if_join(33B7A);              E97EA0F2FF
branch_and_sec(33B7C):

./benchmark.py
code size (bytes): 466599
comp time (ms): 178
exec time (ms): 41
total time (ms): 263

[DONE] TODO: tga image lib test? are we fast enough?

[DONE] FIXME: remove alloc op reg spills before GC?

[DONE] TODO: optimize load_u32, one superfluous move to out opnd

[DONE] TODO: look at asm for strcat prim
./higgs --jit_genasm --e "'a'+'b'; print(\$rt_strcat.asmString())"

[DONE] TODO: spillTestFn should get liveInfo as argument

[DONE] FIXME: issue with GC and global exc allocation...
- Do we unwind the stack before we allocate the exception?

[DONE] TODO: new test, gc/globalexc.js

[DONE] TODO: optimize get_global spills?
- Should have way to spill live after instr or arg regs only
  - move into cargReg can easily corrupt allocated reg
- exc can trigger GC
- soft spill possible

[DONE] TODO: optimize code size for get_global
./higgs --stats --e "print(test.asmString())" --jit_genasm benchmarks/micro/10m_getglobal.js
- see how execution time and code size change across benchmarks
- before: get_global takes from 165 to 213 bytes
- after: 74 to 128 bytes (includes spills)
- code size improved, exec time improved, compilation time much improved!

[DONE] TODO: improve move listing, only list executed moves

[DONE] TODO: blog post about optimization, results
- use meme image
- 200 stars on github
- reg alloc speed gains
- difficulty of optimizing self-hosted code
- compile time now dominates execution time on several benchmarks
- 3d-raytrace, prop access > 30% execution time, inline caching
- graphics lib
- need help wrt profiling compilation time
  - profiling, you don't actually know what's going on, complex codebase

[DONE] TODO: try benchmark.py with maxvers=0

[DONE] TODO: remove redundant setOutType moves
before (laptop):
    code size (bytes): 509475
    comp time (ms): 266
    exec time (ms): 65
    total time (ms): 386
    3d-raytrace code size (bytes): 733500
after (laptop):
    code size (bytes): 499986
    comp time (ms): 269
    exec time (ms): 65
    total time (ms): 396
    3d-raytrace code size (bytes): 715096

[DONE] TODO: remove redundant edge moves

[DONE] FIXME: segfault in gc/closures
make; ./higgs --e "print(test())" tests/core/gc/closures.js
- nostdlib fixes it
- segfaulting ref is in the test function, strangely
- trying to forward result of current call

[DONE] TODO: try implementing GC liveness awareness, might be simpler than you think
- save many moves, reduce code size

[DONE] TODO: verify that we spill everything that's live before GC'ing instructions
- We currently do
- call_new can trigger a GC while creating the new object
- we already make sure not to copy the args before makeThisObj

[DONE] TODO: undo changes to liveness analysis, can't assume hidden args are always live
- doesn't correspond to primitive semantics

[DONE] FIXME: visitStack: for GC, need current instruction
- currently passing callInstr, instr that called the current frame
- could change setCallCtx to setCurInstr?

[DONE] TODO: add isPrim method to IRFunction

[DONE] FIXME: mov rcx, rcx??
./higgs --e "print(fast3bitlookup.asmString())" --jit_genasm benchmarks/sunspider/bitops-3bit-bits-in-byte.js
- redundant move to ret reg

[DONE] TODO: "this" value should have known object type
- should affect code size, cmp count of access-binary-trees
- noticeable reduction in type tests on some benchmarks

[DONE] TODO: try moving regexp in commonjs module inside function, see impact on init time
- saves 300ms

[DONE] TODO: don't inline in global functions, unless inside loop?
- Higgs init very slow since setProp inlining added!
  ./higgs --stats --e "", comp time (ms): 912
- IRFunction.hasLoop?
- this might be extra beneficial, big functions that run only once
- somehow this causes a major slowdown in compilation time?

[DONE] FIXME: loop_big_incr, several jumps to immediate successor
./higgs --stats --e "print(test.asmString())" --jit_genasm benchmarks/micro/loop_big_incr.js
- produced by is_i32, direct jump, no comparison
- jump is probably never rewritten?
- does is_i32 even know how to handle successor next?

[DONE] Meeting lundi 7 avril: Marc wants to look at machine code, start simple, microbenchmark
- Biasing reg alloc towards "assigned reg" caused huge perf gains, code size reduction
- Added more specialized inlined primitives
  - Will probably not add more, as they can increase code size, comp time
- Idea: can implement "GC map" without too much difficulty
  - Eliminate many redundant moves, reduce code size
  - Will probably require some debugging
- 200m_add
    ./higgs --e "print(test.asmString())" --jit_genasm benchmarks/micro/200m_add.js
- loop_big_incr
    ./higgs --e "print(test.asmString())" --jit_genasm benchmarks/micro/loop_big_incr.js
- something w/ function call, bitopts-3bits-in-byte?
    ./higgs --e "print(fast3bitlookup.asmString())" --jit_genasm benchmarks/sunspider/bitops-3bit-bits-in-byte.js

[DONE] TODO: make inlined setPropField
./higgs --stats benchmarks/sunspider/access-binary-trees.js
- before:
    comp time (ms): 358
    exec time (ms): 100
    total time (ms): 458
    code size (bytes): 527329
    num blocks: 2159
    num versions: 2424
    total prim calls: 255053
    total type tests: 740561
- after:
    comp time (ms): 914
    exec time (ms): 25
    total time (ms): 939
    code size (bytes): 665077
    num blocks: 4314
    num versions: 4815
    total prim calls: 2311
    total type tests: 530259

[DONE] TODO: modify liveness analysis to make hidden arguments live at every point

[DONE] TODO: total time stat

[DONE] TODO: investigate why some benchmarks have a different prim call count
- may want to test the output of those further
- nondeterminism?
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=20" --csv_file="maxvers20.csv"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0" --csv_file="maxvers0.csv"
- crypto-aes shows slight difference, uses getTime

[DONE] FIXME: does -- call sub? should have a subInt
- slight decrease in code size, prim calls, type tests

[DONE] TODO: bias values towards dst phi reg
- check if hasOneUse, use is a phi node
- look at code size, exec time on ./benchmark.py
- small reduction in code size, perf results mixed

[DONE] FIXME: optimize intToStr, calls to sub, ++

[DONE] TODO: bias allocReg towards defReg
- optional argument to freeReg

[DONE] TODO: spillReg, take reg argument

[DONE] FIXME: def reg biasing causes segfault?
./higgs --nostdlib --jit_trace_instrs regress-cat-str.js
- 'foo' + 1 segfaults, create regression test, test with --nostdlib
- div!!! corrupting RAX, RDX

[DONE] Meeting:
- phi type prop tweak results in slightly less versions
- another tweak brings us more type info from IsTypeOp
- reg alloc:
  - comp time unaffected, sometimes slightly slower
  - code size significantly smaller, ~23% on avt
  - exec time significantly faster
    - up to 10x on microbenchmark
    - 2x on some benchmarks
- It's not the mem writes that kill you, but the reads?
- on average, we eliminate more than 50% of type tests, 84% on 3d-raytrace
- BBV now wins on most benchmarks (on exec time)
- Effets de cache subtils? petits changements font qu'un benchmark gagne/perd avec BBV

./higgs --stats benchmarks/sunspider/3d-raytrace.js 
comp time (ms): 829
exec time (ms): 155
code size (bytes): 897205

[DONE] TODO: benchmark once again
- Winning on average if excluding comp time
- code size increase marginal

[DONE] TODO: avoid parameter spills

[DONE] FIXME: IsTypeOp doesn't add type info!
- some value ends up undefined with maxvers=0...
- setProp not working?
- we're spilling an argument value
  moving zero into it to preserve consistency...

[DONE] FIXME: live vars analysis bug, wrong IR
- illegal, circular value definition:
  for_test(1DC66):
    t_1DC68 = load_refptr t_1DC68, 0
    t_1DC69 = eq_refptr t_1DC68, null
    if_true t_1DC69 => for_exit(1DC6B), for_test(1DC66)
- probably, the phi node was eliminated because nobody enters this loop

[DONE] FIXME: infinite loop causes infinite loop in IR transform

[DONE] TODO: slowdown, identify sunspider benchmark that doesn't get speedup
- focus on this one
- crypto-md5 is the worst case, exec goes from 92ms to 124ms
- code size increases by about 80%

[DONE] TODO: optimize call spills
raytrace code size: 904082, 727ms, 137ms
after: 900230, 657, 122ms

./higgs --nostdlib --stats benchmarks/micro/200m_add.js
./higgs --jit_genasm --e "print(test.asmString())" --stats benchmarks/micro/200m_add.js
comp time (ms): 17
exec time (ms): 172
code size (bytes): 36003

[DONE] TODO: optimize phi moves
- Phi moves from reg to stack (should be relatively uncommon?)
  - must write type
- Phi moves from reg to reg with unknown dst type?
  - must write type (automatic)
  - must write zero if the type is pointer

[DONE] TODO: rework edge moves
- Always writing type to the stack is wrong... Value may die and not be spilled! ****
- Look at old code for setOutType, moves

[DONE] TODO: improve phi reg alloc
- if val mapped to reg is not live, use the reg

./higgs --nostdlib --stats benchmarks/micro/200m_add.js
./higgs --jit_genasm --e "print(test.asmString())" --stats benchmarks/micro/200m_add.js
comp time (ms): 17
exec time (ms): 344
code size (bytes): 36068

[DONE] TODO: phi node known types from constants

[DONE] FIXME: Running: ./tests/01-stdlib/global.js...
Assertion failed (jit/x86.d@1417): immediate too large for dst reg
- Probably trying to move a large constant into a phi node
- Possibly FP

[DONE] TODO: re-enable phi nodes in regs

[DONE] FIXME: gc bug, crash in bigloop
./higgs tests/core/gc/bigloop.js
- try to run outside of make test
- disabled phi nodes in regs but problem persists!
- some move is there that wasn't there before we mapped stack args?
  - Bug not caused by new moves, or stack mapped vals...
- Caused by regSave? Nope!
- Doesn't fail with --nostdlib
  - Suggests old vars left on stack
  - Problem indeed found while visiting stack
- The value is integer 1, but tagged as a pointer!
  - Value spilled, but type isn't?
  - Or type written, but not value
- Writing zero word and type stack values on getOutOpnd fixes the problem
  - Writing just zero type values does not
- Old type tags are found on the stack
  - Writing a word value without a type can create false pointers
  - At some point, we must be writing some type, but no word value ***
  - Doesn't seem like it's a phi node

[DONE] FIXME: segfault bug in stdlib/math test
- trace the instructions
- storing a value in an array, initializing it to undefined
- opnd0 is RCX, value is 0
Value is loaded twice, never spilled? What the fuck.
Randomly lose the mapping to $15 at the beginning of for_test
- Missing value in valMap
  - Argument never set
  - Zero written on stack while in reg
  - Value not moved from reg to stack cause not seen
  - Value re-loaded from zero stack value

[DONE] FIXME: GC bug in many_globals3.js
(runtime/gc.d@432): gcForward: object not in from-space heap
- GC is manually triggered when extending the global object
- Old pointer from previous GC

[DONE] TODO: phi nodes, alloc reg if possible, currently always on stack
- issue: allocReg expects instr argument
- generalize hasArg to dstValue? don't want virtual method
- For phi nodes we don't really need to worry about not spilling other args!
  - Try to alloc same reg as incoming? Force same reg?
- It's not the same code? I decide that some phi node has reg X
  - If anything else has reg X, I move it to another reg
  - For now, just say stack if reg taken
  - DONE

[DONE] TODO: phi node ASM comments
./higgs --jit_genasm --e "print(test.asmString())" --stats benchmarks/micro/200m_add.js 

./higgs --nostdlib --stats benchmarks/micro/200m_add.js
comp time (ms): 17
exec time (ms): 359
code size (bytes): 36131

[DONE] FIXME: v8/navier-stokes test failing, segmentation fault
- Affected by very subtle details
- Issue with spilling liveAfter vs lifeBefore, stolen scrReg

[DONE] FIXME: string-base64 fails
/higgs tests/06-sunspider/14-string-base64.js
run-time error: run-time error: global property not defined "Components"
base64ToString(1DE27) ("benchmarks/sunspider/string-base64-quick.js"@86:1)
- Make small regression test
- Probably an issue with spills or operating on 64-bit when it should be on 32
  - check bitwise and, left shift
- Not loading all 64 bits when loading value

[DONE] TODO: verify that all extern (C) host calls have the proper spilling

[DONE] FIXME: test fails, ./tests/06-sunspider/05-access-nbody.js
make; ./higgs --jit_trace_instrs benchmarks/sunspider/access-nbody.js
- segfault at $35 = map_prop_idx $34, $68, true
- string pointer is corrupted
- pointer is passed as an argument to $rt_objSetProp
- get_time_ms is lacking spill code!

[DONE] FIXME: bug wrt call_ffi, *heisenbug*
- incorrect return value
- could also be caused by invalid arg

[DONE] TODO: change spills to spill live before, safer
- fixed a bug!

[DONE] TODO: complete adding spills for calls and host code, modify jit/ops.d
- KISS at first, spill all live, do it naively, optimize spills later

[DONE] FIXME: segfault after compileBranch in property delete test
"o = {x: 5}; delete o.x; return !o.x;"
- crash is in objGetProp
- the NOP padding fails on rewriteBranch

[DONE] TODO: add zero write for phis
- If the dst is in a register and the dst type is unknown, write zero

[DONE] FIXME: segfault, make; ./higgs --nostdlib --jit_trace_instrs tests/core/many_globals/many_globals3.js
- possibly due to lack of spilling logic
- add spilling logic!
- may also need additional phi/val move logic
  - writing zeroes and type tags properly?
  - may be missing zero writes

[DONE] FIXME: test fails, "a = 1; b = 2; return a+b;"
make; ./higgs --nostdlib --jit_dumpasm --e "a = 1; b = 2; return a+b;"
- Probably has to do with added spill logic in get_global
- not the same opnd

[DONE] FIXME: "typeof x" causes segfault
make; ./higgs --nostdlib --jit_trace_instrs
- map_prop_idx may be to blame, call to host without spills

[DONE] FIXME: "false & 1" produces 1 instead of 0
make; ./higgs --nostdlib --jit_trace_instrs
- Probable cause: registers not spilled before call!
  - Try just spilling all for now
- This doesn't fix the problem!
- Some other op might need spills?
- retWordReg and retTypeReg are both allocatable registers ***
 - Should printStr info in gen_ret, see what's happening
 - doesn't seem to be the problem
- allocReg used liveAfter to pick reg, two args with same reg

[DONE] FIXME: runtime init fails?
make; ./higgs --nostdlib --jit_trace_instrs
- new_clos needs to spill regs before doing host call

[DONE] FIXME: x = 7; if (\$ir_eq_i32(x, 7)) return 1; else return 0;
- segfault 
- compileBranch?

[DONE] FIXME: "x = 7; return x;", getting a zero value back

[DONE] FIXME: get_global, "x" segfaults
./higgs --noruntime --nostdlib --jit_dumpasm --jit_dumpinfo

[DONE] TODO: setOutType, both variants
- If we have an unknown output type but the output operand is a register, need
  to write a zero to the stack. This is rare-ish.
- When setting a known out type, if the value is in a register, avoid writing the type

[DONE] TODO: getWordOpnd
- Put code in place to alloc regs, but leave disabled for now

[DONE] TODO: getOutOpnd
- Put code in place to alloc regs, but leave disabled for now

[DONE] Meeting:
- sketched out reg alloc
- more runtime and inlining tweaks
- better exec time accounting
- tested hypothesis: inline cache, more misses, icache invalidation
  - a few more misses, but doesn't explain problem
  - most benchmarks have very very few misses (e.g.: 100-300)
- almost all benchmarks still slower with BBV
  - shorter/simpler benchmarks sometimes faster
  - these have less code, also less compiler calls, context switching
- bitops-3bit-bits-in-byte.js is not slower
  - its own code fits within 4KB or so, fits in the icache
  - ~300 additional context swaps for compilation, significant
- fasta is very long running, still significantly slower
  - comp time relatively small, less than 3d-raytrace
  - code size, num versions is much less than 3d-raytrace, but...
  - slowdown seems to have scaled upwards with execution time ***
    - suggestive of icache effect
- strangeness: with BBV, one would expect less *hot code*?
  - but only executed versions compiled
  - more code does mean more icache interference
- should probably focus on trimming the biggest instructions
  (e.g.: get_global, calls)?
  - get_global can be optimized with external fallback code
  - could optimize global calls speculatively

[DONE] TODO: getTypeOpnd

[DONE] TODO: spill saved registers for GC in compileBranch
- Go through incoming context, spill values appropriately for GC safety
- iterate through valMap, spill known types as well
- no need to change status of written values

[DONE] TODO: save registers in getBranchStub
- Save register values before entering compileBranch
- When going back to new compiled code, need to restore values into registers
- Want to write regs to a designated memory area, not difficult
- Word[allocRegs.length] VM.regSave

[DONE] TODO: spillReg helper function

[DONE] TODO: allocReg helper function

[DONE] TODO: ValState.toReg, toStack

------------------------------------------------------------------------------

[DONE] TODO: try measuring execution time separately, see if issue persists
- May be that time issue is due to cleanup time, allocated memory?
  - We're measuring the whole program execution time, which is bad
- 3d-raytrace still slower with this change
- slower across benchmarks
- even fasta is slower... seems ridiculous?
- some very short/simple benchmarks are faster or the same?
  - might support the idea that this is a cache effect
  - these benchmarks should also do less compiler calls

[DONE] TODO: sketch simple reg alloc

[DONE] TODO: add inline cache miss stat, compare 3d-raytrace with and without BBV
- num prop idx misses
- very few misses
- this is not the problem wrt BBV code being slower!

[DONE] TODO: optimize genBoolEval
- Don't need toBool for !, instanceof, in

[DONE] TODO: specialized $rt_setPropElem, see access-fannkuch
- before: 4.3M prim calls, 13.2M type tests
- after: 604K prim calls, 7.4M type tests!

[DONE] Meeting this week: examine machine code again, Wednesday or Thursday
- Detailed primitive call stats, sorted by decreasing frequency
- Various improvements to runtime code
- More inlined primitives
- Basic BBV working with inlining
  - Eliminating large proportion of type tests
  - >78% on 3d-raytrace
- Perf results not fully clear
  - May be that on short benchmarks, more versions means more interruptions to compile
  - icache trouble
  - reg alloc may help with more compact code, better icache perf?

[DONE] TODO: specialized $rt_geIntFloat, see access-fannkuch
- before: 4.3M prim calls, 13.2M type tests
- after: 3.1M prim calls, 12.0M type tests

[DONE] TODO: $rt_gtIntFloat
- before: $rt_gt has 90K calls
- eliminates a fair amount of primitive calls and type tests

[DONE] TODO: make setProp more efficient, eliminate === calls
- before, 75K se calls, 5.90M tests
- after, 71K, 5.88M

[DONE] TODO: make $rt_toString more efficient, eliminate === calls
- currently 113K se calls, 6.12M type tests in 3d-raytrace
- now 75K se calls, 5.90M tests

[DONE] TODO: rt_lt... Should probably handle lhs float + rhs int case?

[DONE] TODO: load i8, signed 8 bit int
- add test

[DONE] TODO: command-line option to record primitive call frequency, --prim_stats
- display sorted count
- only way to know what's relevant to optimize
- not that hard to implement, call some host primitive with a pointer to the D string

[DONE] TODO: eq... specialized version for null? rt_eqNull
- 37K calls in 3d-raytrace
- eliminates calls but doesn't reduce type tests

[DONE] FIXME: maxvers=0, something gets up to 3 versions on 3d-raytrace
make; ./higgs --stats --jit_maxvers=0 benchmarks/sunspider/3d-raytrace.js

[DONE] TODO: inline version of rt_mod, integers only, rt_modInt

[DONE] TODO: inline version of rt_sub, rt_subIntFloat

[DONE] TODO: examine runtime type tests, why so many int tests in 3d-raytrace?
- print where they happen

[DONE] FIXME: still missing versions on loop_big_incr, 4B tests
make; ./higgs --nostdlib --stats benchmarks/micro/loop_big_incr.js
make; ./higgs --jit_genasm --e "print(test.asmString())" --stats benchmarks/micro/loop_big_incr.js
- No versioning happening
- Is removeDead killing all the type info? No
- Useless type tests still present
- Might have to do with phi types not getting set? Yes
- 3d-raytrace type tests go from 20M to 7M

[DONE] TODO: implement CodeGenState.diff
- Needs to compare typeKnown flag, types

[DONE] TODO: examine behavior of BBV on loop incr, look at machine code
make; ./higgs --nostdlib --stats benchmarks/micro/loop_big_incr.js
- 4B type tests still!
- primitives inlined properly
- code not optimized

[DONE] TODO: implement known types in both variants of setOutType
- 27M to 21M type tests
- code size 1157K to 1229K
- versions 5024 to 5027

[DONE] Meeting:
- Fixed codegen bugs outlined at last group meeting
  - suboptimal direct jump
- Completed wider type tags refactoring
  - Fixed bugs, added more tests
- Added back stats for number of block versions
- Began smaller primitives for inlining
  - getPropField, getPropMethod, getPropElem, getPropLength
  - addInt (++), addIntFloat
  - ltIntFloat
  - fallback to old, complete primitives
- 3d-raytrace
  - primitive calls: 16.6M to 1.06M         *** update number
  - code size: 937K to 1157K                *** update number
  - 37M type tests, most of them is_i32
  - compilation time now about 60% of total time
- BBV eliminates >75% tests on 3d-raytrace, should make noticeable perf difference
  - new tag scheme will also eliminate is_object, is_array, is_string
  - but: block versioning will increase compilation time
  - can we exclude compile time for the paper?
- Ran DMD's profiler
  - liveness analysis is slow, quadratic
  - getProp makes > 30% of exec time
- Implemented basic inline caching, 23% speedup on 3d-raytrace
- Marc says: focus on generated code performance

[DONE] TODO: rt_se usage in 3d-raytrace
- benchmark itself doesn't use se!
- called 282K times

[DONE] TODO: total time vs exec time in stats

[DONE] TODO: getPropMethod
make; ./higgs --stats benchmarks/sunspider/3d-raytrace.js
- before:
    exec time (ms): 846
    comp time (ms): 388
    code size (bytes): 1111224
    num call_prim: 1369740
- after:
    exec time (ms): 1003
    comp time (ms): 608
    code size (bytes): 1160565
    num call_prim: 1250309
- compilation time now really dominates
- exec time went down but total time went up!

[DONE] FIXME: map_prop_idx produces idx 0
- obj proto map id is 0!

[DONE] FIXME: exceptions thrown by eval can't be caught in JS

[DONE] TODO: stat for all version counts, 1 version, 2 versions, ...
- Can compute this incrementally
- When going from 3 to 4 versions, remove 1 from 3, add to 4

[DONE] TODO: num blocks vs num versions stat, remove num instances

[DONE] TODO: compare ./benchmark.py times to CC2014 branch, to show Marc
- Much faster on some benchmarks, but slower in others
- Compilation time seems to be the problem

[DONE] TODO: check that we're measuring comp time properly

[DONE] TODO: specialized getPropIdx with basic inline caching
time ./higgs benchmarks/sunspider/3d-raytrace.js    real 1.123s
time ./higgs benchmarks/sunspider/3d-raytrace.js    real 0.869s
- Pass a pointer to the D string from the string constant if known
- Give the maps a 64-bit id as you do for instrs, have a few cache slots (4?)

[DONE] FIXME: block.getName, CodeFragment.getName called when not generating ASM?

[DONE] TODO: profiling
- getPropIdx quite slow
- liveInfo is ~10% of exec time
- getPropIdx is ~30%

[DONE] TODO: getPropElem for array elements
- currently 1.8M primitive calls
- now 1.37M

[DONE] TODO: specialized getPropLength primitive

[DONE] TODO: getPropField with first level obj access inlined
- keep small so just this gets inlined
- inline only where appropriate in ir/ast.d
- slows down compilation time hugely, unexplained by minor code size bloat

[DONE] TODO: rename getPropObj to objGetProp

[DONE] TODO: smaller lt for inlining, ltIntFloat

[DONE] TODO: log prim call names for 3d-raytrace
- lots of getProp
- lots of lt
- lots of add from ++ (fixed)

[DONE] TODO: $rt_addInt for ++ operator
- check stats for 3d-raytrace

[DONE] FIXME: mulIntFloat decreases perf on 3d-raytrace
./higgs --stats --e "print(numC); print(numF);" benchmarks/sunspider/3d-raytrace.js
- could we be hitting the fallback case often?
- collect stats using global vars
  - number of calls vs number of fallbacks
- mulIntFloat: 301K calls, 6K fallbacks
- addIntFloat: 317K calls, 4K fallbacks
- will have to wait until type prop to know

[DONE] TODO: $rt_mulIntFloat
- test perf on 3d-raytrace

[DONE] TODO: $rt_addIntFloat, smaller primitive for inlining
- doesn't make a big difference on 3d-raytrace

[DONE] TODO: peephope opt, see $rt_getPropObj
time ./higgs --jit_genasm --e "print(\$rt_getPropObj.irString())"
not_exit(3986):
$15 = phi [if_true(3965):0 => false, if_true(3965):1 => true]
if_true $15 => if_true(3981), or_sec(3984)
- Should be the only phi node in this block
- Should be no other instructions

[DONE] FIXME: GC/segfault bug with v8bench/crypto... heisenbug
- run outside of tests
- log when GC happens
- segfaults before GC!
$0 = is_const $10
$0 = eq_const $9, $10
ret $0
if_true $2 => if_true(12273), if_false(12274)
Segmentation fault (core dumped)
- Stack overflow

[DONE] FIXME: empty fun, cmp eax, 0
- see 200m_calls

[DONE] FIXME: irString followed by call crashes
- add test for this

[DONE] FIXME: loop incr, redundant jump to immediately following block
time ./higgs --jit_genasm --e "print(test.asmString())" benchmarks/micro/200m_loop_incr.js 
- not a stub, shouldn't happen
- naive writing, never rewritten?

[DONE] TODO: 200m_loop_incr microbenchmark

[DONE] FIXME: [1,2] == [1,2]

[DONE] TODO: proper struct for ValuePair
- methods, toString, isHeapPtr, isNull, isLayout, etc
- constructor taking a refptr & type

[DONE] TODO: examine uses of valIsLayout, refIsLayout in D code

[DONE] TODO: eliminate valIsString from D code

[DONE] TODO: add more logging for this error
Assertion failed (runtime/vm.d@697): invalid stack slot index
core.exception.AssertError@runtime/vm.d(697): invalid stack slot index
----------------
./test-higgs(onAssertErrorMsg+0xb0) [0x6ba054]
./test-higgs(_d_assert_msg+0x45) [0x69a065]
./test-higgs(runtime.vm.Word runtime.vm.VM.getWord(int)+0x9b) [0x6241a7]
./test-higgs(compileEntry+0x43) [0x681647]
[0x2aff3d1ee80f]
./test-higgs(runtime.vm.ValuePair runtime.vm.VM.exec(parser.ast.FunExpr)+0x6e) [0x6253a2]
./test-higgs(runtime.vm.ValuePair runtime.vm.VM.load(immutable(char)[])+0x83) [0x625537]

[DONE] FIXME: esprima test fails
- add new regression test

[DONE] TODO: eliminate valIsString from JS code

[DONE] Meeting:
- New wider type tags
- More debugging tools, tracing instrs, stack printing
- Conf invite in Sweden
  - rejected, suggested that Tom may apply, promote Higgs

[DONE] TODO: use ValuePair more in runtime/object.d, for safety?
- who uses getPropObj, newObj, newClos?
- might make most sense for newObj, newClos
- newObj should definitely take a ValuePair for the proto value

[DONE] FIXME: segfault on Higgs init
jump => for_test(3729)
$10 = load_refptr $9, 0
$0 = eq_refptr $10, null
$0 = load_mapptr $9, 16
$11 = map_prop_idx $0, $22, false
Is the map null?
- Seemingly not null, but getPropIdx segfaults
- str ptr seems corrupted
- gotta log who's calling getPropObj
  - can you traverse the stack using VM.visitStack?
- stack overflow is the problem

[DONE] TODO: util, as.printStack

[DONE] FIXME: $rt_getProto not working? proto value we get is corrupted, zero type tag
- value properly set in newObj
- seems to work with object in the console
- proto corrupted during object expansion
- minNumProps wrongly handled wrt reserveSlots

[DONE] FIXME: prototype needs a type tag
- store in slot 0?
- need to move closure pointer to slot 1
- newObj, newArr need to reserve a hidden prototype slot too

[DONE] TODO: adjust D uses of newObj, newClos
- grep for REFPTR

[DONE] Meeting: to be shown: disassembly for fib, microbenchmark results
- completed and debugged new stub scheme, branch rewriting
- various machine code optimizations
  comp time     -42%
  exec time     -19%
  code size     -14%
- made disassembly strings much much faster
- ran microbenchmarks
- recuperated inlining, type analysis code from cc2014 branch, basic inlining working
  - even only inlining small primitives generally doesn't pay for itself
  - does win out on 3d-raytrace, cuts prim calls by more than half
- started looking at IR, ASM for prop access, optimizing inefficiencies
- idea: shape system with types for object fields
  - by testing for a specific shape, instantly gain invaluable info about an object
  - could insert shape test instruction, generate many basic block versions (up to 4?)
    s = obj_get_shape o (s is say int32)
    v = obj_get_val(o, s, propStr)
    In optimized case, shape idx and prop idx gets us a constant, or
    a constant type.
  - could work for the global object too
  - solves the undefined problem, advantage over TI!
- the plan:
  - first basic inlining, tweak heuristics
  - get type prop, type analysis working
  - rewrite new primitives with smaller inlinable part, hand-inlining, hand-tuning
  - 1st level type tags for objects, arrays, closures
  - see how much time is left
  - reg alloc, some gains, but probably not that much
  - global prop access idea, known not missing?
  - shape system?
    - may want to leave type spec out until next paper
    - may be too much to explain
    - but, could start with inline caching
- Marc says: prioritize inlining of add, sub, mul, etc.
  - rerun microbenchmarks
- Marc says: aim for having satisfying perf a month from now
  - set milestone

[DONE] TODO: adjust GC code for new type tags

[DONE] TODO: isHeapPtr(Type type), useful for sanity checks
- grep for REFPTR

[DONE] TODO: change layout system to use new alloc instructions

[DONE] TODO: tweet that presence at dconf is confirmed #dlang #dconf
It's official, Higgs and I will be returning to DConf in 2014! dconf.org #dlang #dconf

[DONE] FIXME: test runner, FFI depend on type tag values?
- grep for get_type

[DONE] TODO: fetch type analysis from cc2014 branch, make it compile

[DONE] FIXME: getProp calls toBool, this is wrong!
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
- Can we assume that if (prim) produces a boolean? should be able to
  - don't design primitives that have weird polymorphic return types
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
exec time (ms): 3200
comp time (ms): 12

[DONE] TODO: upgrade dmd to 2.065

[DONE] FIXME: segfault on throw_in_finally
make; ./higgs --nostdlib "tests/core/exceptions/throw_in_finally.js"
- Doesn't have to do with the peephole
- Don't want to inline $rt_throw
  - but why does it segfault?
- Not inlining throw doesn't fix it
- doesn't get to throwExc
- something screws up during IR gen
- inlining + exc produces empty block

[DONE] TODO: --jit_trace_instrs

[DONE] FIXME: $rt_obj_ofs_next not inlined in $rt_obj_get_next, why?
- IR gets doesn't get generated when entry stub is hit, no entry stub for primitives!
- move inlinePass call into astToIR!

[DONE] TODO: peephope opt for IsTypeOp with constant

[DONE] TODO: simple ad-hoc, rule-based inlining
- benefit: keep the old type analysis
- inling once at IR gen time, no recompilation
- inling specific primitives
- to begin, only inline small runtime primitives
- should be able to speedup getProp hugely

[DONE] TODO: if call has no uses, no need to copy ret regs to out slot

[DONE] TODO: grab ir/inlining.d and jit/inlining.d from CC branch

[DONE] TODO: simplify return from primitive functions?
- Are we doing frame size checks in there?
- test 200m primcalls again
time ./higgs --nostdlib --stats benchmarks/micro/200m_primcalls.js 
- hack it for now
- before
  exec time (ms): 1810
  comp time (ms): 1
  code size (bytes): 40890
- no noticeable time difference!

[DONE] TODO: microbenchmarks, big loop with either getProp, getGlobal, fn call
- also run with --stats, look at num prim calls
time ./higgs --nostdlib --stats benchmarks/micro/10m_getprop.js
  10M getprop
    exec time (ms): 4884
    comp time (ms): 10
    num call_prim: 210000041    *** 210M primitive calls, inlining will help
    num map_prop_idx: 10000001
    is_refptr: 20000002
    is_const: 20000001
    type tests: 40000005
  10M getglobal
    exec time (ms): 154
    comp time (ms): 3
    num call_prim: 0
    num map_prop_idx: 0
    type tests: 0
  200M add
    exec time (ms): 3637
    comp time (ms): 2
    num call_prim: 200000000
    type tests: 400000000
  200m primcalls
    exec time (ms): 2120
    comp time (ms): 2
    num call_prim: 200000000
    type tests: 0
- worth studying, discovered some hidden type tests
- getProp does about 20 calls per access, about 50% exec time is prim calls
- inlining will be crucial, especially inside getprop

[DONE] FIXME: getprop does 10M is_f64 tests?
- use of $rt_ns in getPropObj

[DONE] TODO: fix num prim calls stat

[DONE] TODO: compare speed against master branch with ./benchmark.py
new
  comp time (ms): 95            -42%
  exec time (ms): 512           -19%
  code size (bytes): 618873     -14%
old
  comp time (ms): 163
  exec time (ms): 631
  code size (bytes): 715050

[DONE] TODO: memberOpnd? could optimize call code further

[DONE] TODO: as.comment, try avoiding calling if jit_dumpasm is false

[DONE] FIXME: branch rewriting did not shave end of blocks in getPropObj
make; ./higgs --jit_genasm --e "print(\$rt_getPropObj.asmString())"
call_cont(3D2B):
; $0 = eq_refptr $7, null
mov rax, [qword r14 + 56];              498B4638
cmp rax, 0;                             4883F800
je branch_if_true(3D2D);                0F848C000000
nop1;                                   90
nop4;                                   8D742600
branch_if_join(3D2F):
if_join(3D2F):

Clearly branch_if_join is immediately after. Should be immediately queued.
Will need to log things specific to getPropObj branches

What those jumps have in common is that neither of the targets are stubbed.
They got rewritten twice.
Most likely, the first rewrite simply did not remove the mov...

[DONE] TODO: getBranchEdge, should probably avoid:
  - generating succState
  - doing getBlockVersion to get a successor version
  - immediately doing move generation
- wastes time and memory on unexecuted targets
- only store the predState and target block at first
- can lazily generate moveList when compiling branch edge
- if isNoop, eliminate the branch edge
- want to do repatching in compile loop, when compiling branch edge

[DONE] FIXME: call_prim to rt_obj_get_next taking 3 constant args, why?
- only needs one argument
- we don't check if the hidden arguments are needed
- could just assert they have no uses
- argc seems necessary to traverse the stack

[DONE] FIXME: does the GC need the closure argument?
- closure argument not needed per-se
- GC fails to find return address in ret addr map
- leftover corrupted data with the wrong tag?
- Do we ever write values on the stack without a type tag?
  - odd interation with a regression test...
- bug in get_ir_string, missing setOutType

[DONE] TODO: optimize branch edges
- if target is directly next, not write jump?

[DONE] TODO: optimize if_true branch shape

[DONE] TODO: asmString log call cont stubs
make; ./higgs --jit_genasm --e "print(\$rt_getPropObj.asmString())"

[DONE] TODO: optimize branch shape for integer less-than

[DONE] TODO: optimize direct jump shape

[DONE] TODO: asmString, display gaps!
; ### NN bytes gap ###

[DONE] TODO: if we're the last block, don't pad with nops!

[DONE] TODO: avoid writing blockIdx when neither target is a stub
- need to check if queued for compilation also
  - workList.canFind(b)
make; ./higgs --jit_genasm --e "print(\$rt_add.asmString())"

[DONE] FIXME: issue with neither targets being stubs
- not writing blockIdx causes segfault
- problem happens with is_i32, right when compiling a stub
- error with nop() function causing stack overflow

[DONE] TODO: optimize final jump ordering when rewriting final branch
- BranchShape
- again need to check if successors are queued?
just compare startIdx... value is max if stub!

[DONE] TODO: way to remove code block strings in specific range, delStrs
- Needed when rewriting branch or patching stub
- range [startIdx, endIdx[

[DONE] TODO: asm strings, reimplement using an array of indices to lists of strings

[DONE] TODO: make blockIdx 32-bit so move is smaller

[DONE] TODO: pushfq, popfq for debugging w/ printInt, printStr
9C PUSHFQ
REX.W + 9D POPFQ 

[DONE] FIXME: problem with tests/core/ffi/ffi.js
- FFI call borking, issue with stubs?
- Might be an issue with the return value handling, call continuation
- FFI probably does not need genCallBranch... Better served by plain genBranch

[DONE] FIXME: throwExc needs to JIT compile the exception branch

[DONE] FIXME: stdlib init fails
label "FALSE2" already defined at position 410858
- call does a conditional jump to compute the total frame size
- should try to move this computation out of the final branch part

[DONE] Meeting:
- contribs, multiple fronts:
  - self-hosting
  - type tagging scheme
  - BBV
  - incremental compilation
  - incremental inlining
- incremental inlining decreases execution time on `make test`
  - right now, even with poor inlining, doesn't make benchmarks slower
  - old aggressive inlining might be slower, increase compilation time
- paper-wise, might be better to do simple rule-based inlining
- proposal: simple inlining for DLS paper
  - focus on BBV, improving code gen, fixing incremenetal compilation quirks
- stubs: might be able to have one stub for all branches
  - truer to the lazyness goal
  - allows better contiguous code
- CC or PLDI paper on incremental compilation?
- Bourse DIRO!

[DONE] FIXME: issue with recursion, start position is already marked
- may need to patch the cont stub, still used for deeper calls

[DONE] FIXME: 1 + 2 doesn't produce the right output
- Return not working?
- Are we manging the return type reg?
- Value+type correct after add...
- Value+type correct at first level return
- Second return gets incorrect value and type

[DONE] FIXME: 1 + 2 doesn't work
make; ./higgs --nostdlib --e "1 + 2"

[DONE] TODO: --noruntime flag, useful for debugging, with --jit_dumpinfo
- make it automatically imply nostdlib
- debug simple expressions, make test produces too much output

[DONE] FIXME: setRetEntry, calls getCodePtr to get a pointer to the call
continuation code. The call continuation branch is not yet instantiated.
- Can we make call returns go to BranchStub?
  - doesn't really work
- Should force cont branch to get compiled?
  - what about exception branch... don't want to force that to be compiled
- For exceptions, can probably trigger compilation manually during exception handling
- If we say call cont must be compiled, we still don't get an address immediately
    auto retAddr = retCode.getCodePtr(vm.execHeap);
    vm.retAddrMap[retAddr] = RetEntry(callInstr, callCtx, retCode, excCode);

[DONE] For efficiency, probably want returns to go to special stubs
- Compile whole sequence after return all at once, more elegant and optimal
- ContStub will:
  - patch its calling block version, rewrite its final branch
  - queue the proper return branch to be compiled
  - remove the old RetEntry for the ContStub
  - create a proper RetEntry for the compiled return branch
- Could use a unique return stub?
  - Since we patch the calling block
  - Could set the call blockIdx in a special register
- Probably don't want a unique stub
  - Want to have some specific RA we can track!

[DONE] FIXME: we hit a branch stub, but the blockIdx is corrupted
- Seems to contain a pointer value instead
- corruption during reference patching because of getBranchStub

[DONE] TODO: rework genBranch
- block idx is available when compiling block (fragList.length)
  - store in scrReg[0]? be careful wrt calls
  - check if either target is a stub first
- may need to pad until endIdx with noops
  - also assert that we aren't going past endIdx if rewriting

[DONE] TODO: rewrite srcBlock final branch in compileBranch

[DONE] TODO: refList patching, if jumping to uncompiled block, jump to branch stub instead

[DONE] TODO: generate code for BranchCode in code gen loop
- Add call to prelGenFn

[DONE] TODO: BranchCode should store a closure that generates its code
- Deferred codegen
- Also store list of moves

[DONE] TODO: rework compileStub
- only write branch edge to execHeap once stub is hit, unless we know it will be taken
- store pointer to BranchCode as outgoing target

[DONE] TODO: generate stub[i], getStub(targetIdx)
- don't need special spill code for now, no reg alloc yet
- Receives blockIdx in scrReg[0]

[DONE] FIXME: string interning, no cleanup on GC? Can we make splay faster?
- This is already done correctly!

[DONE] TODO: try creating smaller versions of slow benchmarks for unit tests
    shootout/lists
    sunspider/string-base64
    sunspider/string-fasta
    v8bench/splay
- at least keep them tested!
- name with _quick

[DONE] TODO: move loop_big_incr into benchmarks/micro?

[DONE] FIXME: jump removal opt, conditional or not, doesn't matter
- Don't check if jmp

[DONE] TODO: Modify CallCtx for improved inlined stack management
CallCtx.extraLocals => obvious from fun
Add: CallCtx.spOffset, CallCtx.totalLocals? Maybe just extraLocals

[DONE] Meeting:
- IRFunction.asmString, see generated code
  - Found bugs and issues with ASM comments, markEnd logic
  - visualization useful
- Redundant jump opt
- Now obvious: stubs should probably be out of line
  - But should we implement this later?
- DLS Paper, coming soon, what do we absolutely need?
  - Objective: show less checks, better running times
    - Run benchmarks in a loop?
  - Inlining, type prop, eliminate type checks
  - Type analysis
  - Reg alloc? basic
- Bourse DIRO

[DONE] FIXME: corrupted ASM comment in the middle of stub
    branch_if_join(36CC):
    jmp if_join(36CC);
    if_join(36CC):
    ; Stub of if_join(36CC)
    mov [qword r15 + 48], r14;              4D897730
    mov [qword r15 + 56], r13;              4D
    ; if_true $0 => if_true(36CA), if_join(36CC)896F38
- Try disabling jmp opt, see if it helps
  - Seems to fix the problem, but now the commend is just before if_join?
    if_true(36C3):
    $0 = is_i32 $22
    if_true $0 => if_true(36CA), if_join(36CC)
- The if_true compiles to nothing because is_i32 generates branches,
  the ASM comment gets placed after the branch code

[DONE] TODO: resume projet for bourse DIRO
- Mention github stars, Mozilla continues funding us, interest from Facebook

[DONE] TODO: asmString, don't print blocks with zero length?
make; ./higgs --jit_genasm --e "print(\$rt_add.asmString())"
- or just no whitespace after ***

[DONE] TODO: try optimizing away empty branch edges
- Time the result
- can we integrate this in genBranchEdge?
- Simpler alternative: if block immediately follows branch edge, 
  don't write jump.
  - Query code gen queue to know if jump is necessary
  - Have special utility function just for generating final jumps ***
time ./higgs tests/core/regress/loop_big_incr.js
before: 36.4
after: 31.3

[DONE] TODO: IRFunction.asmString()
- Order by address
  - no need to sort, just keep track of traversed, do smaller addr first
- Branch code too
- This should be quick to code

[DONE] TODO: LocalIdx => StackIdx
- Not unsigned

[DONE] TODO: partial support for `quasis` as multi-line strings only

[DONE] TODO: update CV for bourse DIRO

[DONE] TODO: wiki, add enum of missing features

[DONE] TODO: in About Me on pointersgonewild, link arxiv paper, mention it's a tech report

[DONE] TODO: look for JS FFT implementation
- there is one in kraken 1.1
- ask on Twitter if someone knows of a simple JS FFT

[DONE] TODO: e-mail Marc about bourse DIRO. Mention e-mail suffices.

[DONE] TODO: take a look at Mozilla regression tests
http://hg.mozilla.org/mozilla-central/file/8c5a94ba1096/js/src/jit-test/

[DONE] TODO: if to same if opt pattern, see $rt_getPropObj, $6
- if testing the same value and value is not from succ, will branch the same way

[DONE] FIXME:
h> try { 'foo' + $nullptr } catch (e) { exc = e }
h> exc.toString()
object
Needs to inherit from Error.prototype

[DONE] TODO: add trace info to exception objects
- throwError already allocates in heap, fair game
- can make helper functions in throwExc to set the current position at each
  call level

[DONE] TODO: probably want to be able to set a target for throw?
- Want to unwind the stack, set the position on the exception value
- Call some runtime function that does throw
  - Eliminates need to set srcPos on throw instrs
  - genRtCall("throwExc");

[DONE] TODO: add source position info for call instructions and throw instruction
- Do this in genCallTargets?
- Modify stack trace code to show source positions
- Map of call sites to source pos in IRFunction
  - Might want to just have sourcePos ptr on IRInstr, simpler wrt inlining
  - More robust with IRInstr

[DONE] FIXME: block cap hit... Block version map needs to be per-callCtx?
- uncomment block cap hit print, put in version(debug) block
- see $rt_getPropObj, $6

[DONE] TODO: migrate esprima parser test from Tachyon

[DONE] TODO: move some of the misc Tachyon tests to the new test runner

[DONE] FIXME: peephole opt bug
- streamline failing test
- add new test to core/regress

[DONE] TODO: prepare beta mloc/midiro talk

[DONE] TODO: call to non-function, try to recover fn name from IR
- make a function for that in ir/ir.d, getCalleeName(IRInstr callInstr)

[DONE] TODO: move SunSpider tests to test runner

[DONE] TODO: move shootout tests to test runner

[DONE] FIXME: enumeration issue, duplicates
h> a = { x:1 }
object
h> b = Object.create(a)
object
h> b.x = 2
2
h> for (k in a) print(k)
x
h> for (k in b) print(k)
x
x
- Need a way to check if somewhere in the inheritance hierarchy an enumerable
prop of the same name exists
- Make regression test, tests/regress/for_in_dup.js
- When solved, add for_in test, close github issue

[DONE] TODO: move V8 tests to test runner

[DONE] TODO: make sure to mention arxiv paper on wiki, basic block versioning

[DONE] TODO: make test-higgs not skip main
- Run test runner with same binary
- Notify Tom of change

[DONE] TODO: fix unsupported base issue
- add test, stdlib/object
- Tom is working on it

[DONE] TODO: blog, use subheaders? (More talks coming, new contributors, more seriouser)
- paper on arxiv
    http://arxiv.org/abs/1401.3041
- Budapest talk imminently
  - expect detailed blog post on BBV & incremental JIT
- DConf 2014
- incremental JIT in master branch, no reg alloc, perf about the same
- working on incremental inlining
- bug fixes, thanks to toledo chess
  - more bug fixes, unary + and -, regex, thanks to zimbabao, toledo
  - Higgs now more JS compliant
  - new test framework, moz/v8 tests
- travis test system
- contribuse OSS, DOM-free JS code, help us test & debug Higgs
  - always looking to grow our collection of tests

[DONE] FIXME: missing runtime primitive segfaults?
- Does indeed segfault in the shell

[DONE] FIXME: Higgs REPL, should return value of last expr if several

[DONE] TODO: simple tests for csv lib?
tests/lib/csv/ csv.js, infile.csv

[DONE] TODO: move basic FFI tests to test runner
tmpnam, make sure that returns string of length > 0

[DONE] TODO: look at link issue pointed out by zimbabao
function set_get_test_function() {
    var link = $ir_make_link(0);
    var s = "1234";
    print($ir_get_type(s));
    $ir_set_link(link, s);
    var val = $ir_get_link(link);
    print(val + " : " + $ir_get_type(val));
    val = $ir_get_link(link);
    print(val + " : " + $ir_get_type(val));
}
set_get_test_function();

[DONE] TODO: proper 1 / (-1 * 0) handling, negative operator as -1 times zero,
multiply handling of 
If the multiplication isn't truncated (by one of the many ToInt32()/ToUint32()-coercing operators),
then we dynamically branch for both overflow and negative*zero.  We can also special case various
multiply-by-constant cases to avoid one or both branches.  (Note, even when multiplication is
truncated it can overflow making * kindof a lame duck.  In asm.js, we give it the type (doublish,doublish)->double
and then we separately define multiplication by small-enough constants as having type int->intish.
This suckiness is what motivates Math.imul.
We just branch on zero to an out-of-line path that does the signed check.

[DONE] FIXME: killing of values in removeDead... Doesn't account for recursive
inlining. Should traverse chain of ctxs to test if callee is in the chain.
- CallCtx.contains(IRFunction fun)

[DONE] TODO: pull from master

[DONE] FIXME: sunspider/3d-raytrace borks with inlining enabled
./higgs benchmarks/sunspider/3d-raytrace.js
run-time error: unsupported types in strict equality comparison
- Invalid base in property read
- Inlining of getProp is wrong?
- base argument of getProp seems wrongly mapped
- localIdx is correct at time of call to $rt_se
- The type we get is retaddr... We seem to be off by 2?
... Draw this specific situation on paper
When calling getProp, the this/base type tag is already corrupted.
- Sometimes gets a zero type tag too...
Why is the this value of Triangle.prototype.intersect corrupted???
The argc value is correct, so is the type tag!
- Only the this value is corrupted
This problem happens with getProp a lot, in several places... wtf is wrong with getProp?
- Should probably assume that getProp gets inlined wrong somehow?
- getProp tends to have other functions inlined inside it? Is the inlined return wrong?
  - Many many things get inlined in getProp, then we get a failure
Hypothesis: getProp needs to be inlined for this to fail?
Seems to be getPropObj that's inlined in getProp that fails?
phi move seems to be at fault:
move from: $17 = arg 4 "obj"
move to: $17 = arg 4 "obj"
  src: [qword r14 + 136]
  dst: [qword r14 + 800]
No mapping of arg in src, but mapped in dst...
Killed by removeDead...
Might indeed really be dead!
Moving from callee argument to caller argument slot, bad

[DONE] TODO: integrate new test system

[DONE] TODO: pull zimbabao's PR

[DONE] TODO: exception handling in inlined context
- Can use regular exception handler, however? Yes
  - Takes the exc value off the stack
  - This is a BranchCode object
  - Could also just generate our own, avoids need to keep JIT objects in CallCtx

[DONE] FIXME: seem to now be failing in exceptions test
./higgs --nostdlib tests/exceptions/try_loop_getprop.js
- Does getprop to null, fails
- When inlined, throw becomes a jump?
  - can use exc handler also, performance not so important
- All the ops that can throw need throw handler code, including get_global
  - Need some kind of getExcHandler fn?
  - Returns a code fragment
  - Problem: need to compile handler after throwing instr
  - Ideally, compile at throwing instr, store in CallCtx???
  - Only call_prim can cause this
- CallCtx.getExcHandler(curHandler = null)?
  - seems like that would work!

[DONE] FIXME: no handling for two levels of inlining
- loop test that uses getProp?
    make; ./higgs tests/regress/jit_getprop_arr.js
- use extraLocals from previous level when computing current extraLocals
- still segfaults, probably want simpler test
    make; ./higgs loop_test.js
We crash at the second inlined call to str_ofs_data...
- We aren't getting the same entryVer object
- extraLocals... can't pop them all at once when returning if multiple levels
- want extraLocals and totalLocals...
- Also want to be able to map arguments across *multiple levels* of inlining

[DONE] Meeting:
- Sent submission for DConf
- New contributions, regexp fix, missing array functions
- Multiple bugfixes
- More conformance bug fixes
- Inlining, slight perf gain, ~12%

[DONE] TODO: test full higgs init with inlining

[DONE] TODO: getBranchEdge shouldn't need assembler argument

[DONE] FIXME: benchmark inlining on for incr loop (see existing tests)
make; time ./higgs --nostdlib tests/regress/loop_big_incr.js 
noinline: 40s
inline: 36s
- seems to infinite loop, need to look at return values, args
- loop i stops being incremented at 5000
- try printing return value of add
- Not executing phi nodes after the return? ***

[DONE] FIXME: foo.irString() before foo() fails
- irString causes odd things to happen
- make regression test for this too

[DONE] FIXME: bug found by zimbabao
- something with phi nodes, liveness?
    while (size-- > 0)
    $5 = phi [call_cont(ED8A):0 => 4, call_cont(EDB9):0 => $0]
    $0 = set_str "sjhsjsh", <link:NULL>
- There is no call to rt_sub! test expr wrongly evaluated
  - some phi simplification might be failing
- Problem is with tmp alloc, tmp escapes block, used by phi node
  - But used within same block
- sunspider/crypto-aes still not working properly!

[DONE] TODO: integrate regexp fix PR

[DONE] TODO: see how far along we get in make test
- global object test, goes into infinite loop, possibly 2-level inlining

[DONE] TODO: test on trivial loop example first, with --nostdlib
for (var i = 0; i < 10000; ++i);
- Inlines call to lt, but execution stops immediately (lt returns false)
- lt returns false, arguments are probably mapped wronge (inverted?)

[DONE] TODO: connect the inlining bits in call_prim
- setup new CallCtx
  - store contSt
- setup new CodeGenState
  - map args to parent values
- adding of extraLocals
- jump to entry

[DONE] TODO: email Marc, Laurie, Clark about ref letter

[DONE] TODO: start with return handling for inlining, no exceptions yet
- Probably don't want to jump to regular return branch from inlined call
  - Don't want to use the move register, want to get a branch edge for the call cont
  - Need to track the IR branch edge object
  - Generate efficient code upon return
- can test on 3d-raytrace

[DONE] TODO: write/send submission for DConf 2014 , title + abstract
- Deadline Jan 31st
- 21-23 May, Menlo Park

[DONE] FIXME: +{} should be NaN, +[] should be integer 0
- currently does 0+x
- what does the spec say?
ToNumber(GetValue(expr))

[DONE] TODO: get_ir_str

[DONE] FIXME: X86Opnd(-1) doesn't fit in 8 bits?
- see getWordOpnd

[DONE] TODO: proper system to map values to stack slots in CodeGenState
- Needed for handling of inlined args
- Need to be able to map a value to a specific stack slot ***

[DONE] TODO: inform Andrei
- Marc willing to pay for travel + hotel

[DONE] TODO: liveness information during inlining
- fix removeDead
- Do we even need to query this??? Can probably ignore parent values in removeDead

[DONE] TODO: send toledo chess link to Marc

[DONE] Meeting:
- added generated code size stat, num call_prim, num dynamic calls
- large majority of calls are primitive calls (>70x more) in several benchmark
- began inlining work
- have system to trigger recompilation of call sites on inlining, code patching
- working on stack value tracking in inlined calls, branch and exc edges
  - all managed in backend, IR not transformed
- DConf 2014. Could replace Australian conf, coincide with Mozilla visit?

[DONE] TODO: --jit_noinline flag
- 3d-raytrace inline:
exec time (ms): 2698
comp time (ms): 436
code size (bytes): 1151903
- noinline:
exec time (ms): 2528
comp time (ms): 420
code size (bytes): 919875

[DONE] TODO: test, long loop with getProp and try, eventually set base to null,
throws an exception in an inlined context

[DONE] TODO: patching mechanism for when recompiling
- VersionInst needs a next version var
- BlockVersion method for patching?
- put next var in base class?
- should assert that the patch code can fit within the current block length
- assert that the endIdx is set in length computation

[DONE] TODO: sketch recompilation mechanism for inlining
- spill regs, call?
- need to set the CallCtx, contained in BlockVersion

[DONE] FIXME: code size statistic, sum up generated code
- markEnd should do this?
- adding counter/recompilation code makes code size go from to 0.9 to 1.15MB

[DONE] TODO: add counter variable (uint32) on VersionInst
- Implement incrementation code in call_prim, test performance

[DONE] TODO: ask on Twitter if people have DOM-free JS code to help test & benchmark the Higgs JS JIT
Do you have any DOM-free JS code to help test & benchmark the Higgs JS JIT? https://github.com/maximecb/Higgs

[DONE] TODO: look at incremental inlining notes, new notes file specifically on this
2014-01-16 Inlining.txt
- what did we say wrt fn arguments?

[DONE] FIXME: chess program, The other bug is because you changed the 'ply' variable
to be 1 (validate legal movement) instead of 2, the chess program only does
search when ply is 2 or higher. So the game works after changing it to 2 and
solving the other bug temporarily (using Math.floor(B/x))

[DONE] FIXME: bitwise operators OR, AND and XOR, your compiler rounds the operands
with Math.round instead of Math.floor
also happens with the bitwise complement operator
For example, 3.5|0 gives result 4

[DONE] TODO: double to signed integer conversion using truncation
F2 REX.W 0F 2C /r
CVTTSD2SI r32, xmm/m64
- revise toInt32, toUint32

[DONE] TODO: add some basic lib tests that just do require('lib/stdio') and stdlib...
- easy to call stdlib/stdio fn?

[DONE] FIXME: Number + Boolean fails, 0+true generates "0true" instead of 1
- check every operator where Boolean can be used with Number
  0 + true == 1
  1 + null == 1
  1 + false == 1
  null + true == 1
  true + null == 1
  true + true == 2
  true + undefined == NaN
- once working, push to master, notify Oscar Toledo

[DONE] TODO: re-fetch improved $rt_add, $rt_sub, etc from cc2014

[DONE] TODO: Inlining heuristic... counter?
- could have inline counter with threshold, eg: 10K
  3d-raytrace does 68M call_prim
  assuming 500 main ops, 136K calls per op on average
  10K probably reasonable
- Try instantiating counter, and logging how many times it gets hit, source location
  - for 3d-raytrace, 10K gets us around 190 call_prim instances, 20K gets 122, 5K 221
  - hot call sites fairly well spread, may need to put threshold lower
    - find optimal threshold based on benchmarks

[DONE] TODO: how many getPropIdx calls do we do in big benchmarks, how many calls?
- add counter for getPropIdx, call_prim, call
- much less getPropIdxs than type tests, but these are probably much slower
- number of call_prim dwarves even number of type tests
  - over 100x as much as dynamic calls
- counters make a noticeable difference in execution time, good news

[DONE] TODO: put paper on arxiv.org? Yes

[DONE] Meeting:
- next priority: type prop, inlining, reg alloc, jump opts, inline cache
- next paper will probably be about type prop... but would also like better perf
- how many getPropIdx calls do we do in big benchmarks, how many calls?
- usenix
- Mackenzie scholarship, possibly
- going to need to start on mloc.js talk soon, beta due by end of month
  - Marc: give practice talk at MiDiro

[DONE] TODO: create wiki FAQ page, why D
https://www.youtube.com/watch?v=hJUNHX0vakI&feature=youtu.be&t=20m12s

[DONE] TODO: add benchmarks/kraken-1.1/ai-astar.js to parser tests
- can we also parse ai-astar-data.js reasonably fast? yes

[DONE] TODO: talk to Tom about JITted FFI

[DONE] TODO: make dummy codegen function for JITted FFI

------------------------------------------------------------------------------

[DONE] Milestone IV: All tests and benchmarks working
- Will require GC

[DONE] TODO: push to master branch once all benchmarks working

[DONE] TODO: inform Marc of progress

[DONE] TODO: run ./benchmark.py, get first results, compare to past
- comp time slightly slower, but more inclusive (ast to IR)
- bigger benchmarks generally faster
- this is with no inlining!

[DONE] TODO: pass all tests

[DONE] FIXME: earley-boyer fails after GC
./higgs benchmarks/v8bench/base.js benchmarks/v8bench/earley-boyer.js benchmarks/v8bench/drv-earley-boyer.js 
run-time error: undefined base in read of property "car"
- GC triggered by makeThisObj
- Create a new regression test
- Bug does seem to have to do with GC
- If we get undefined base, it's probably cause we got a getProp producing undefined
  - confirmed, both car and cdr are missing
  - propIdx is -1
The value we get for the base seems to be a number?
lst gets the number 0 as argument...
This should probably be the null value
Changing the code seems to affect when the bug happens!
- Changing the frame size?
Hypothesis: we write args above wsp/tsp before creating the this object
- These args do not get forwarded

[DONE] FIXME: GC during array allocation fails
- pushJITRegs not done, wsp/tsp not set

[DONE] TODO: implement get_heap_free instruction
- Generalize GetValOp? Not for this, need to compute value

[DONE] TODO: pass basic gc_collect test

[DONE] TODO: implement gc_collect instruction

[DONE] TODO: fixup GC code

[DONE] TODO: blog, Contribute to the Higgs JS Compiler
- No need to know how to program in D
- List of things people can contribute
  - Trying it out, finding bugs
  - Writing useful libraries
  - Implementing new JS features
  - Profiling to improve compilation speed
  - Support for ES6 features
- Link to wiki
https://github.com/maximecb/Higgs/wiki
- Link to issues page, link to wiki in post and in Higgs page
- Open issues on GitHub for
  JIT compilation time profiling
  Finding new benchmarks, adding them to "make test"
  Repackaging JS libs to be shipped with Higgs
- Link to contribution instructions on wiki
- Explain the Higgs roadmap
  Batteries included, easy canvas window, easy input lib

[DONE] TODO: fix ops to use setCallCtx
gen_get_str, gen_map_prop_name, gen_new_clos, op_get_ast_str, FPToStr, gen_call_new

[DONE] TODO: update wiki, reporting bugs, mention source/tests directory, PR

[DONE] TODO: split /programs into /benchmarks and /tests

[DONE] TODO: valIsLayout vs refIsLayout

[DONE] TODO: rename state.ctx to state.callCtx

[DONE] TODO: modify throwExc to take CallCtx argument

[DONE] TODO: test undef | 0, shift by undef, etc

[DONE] FIXME: "function() {} b = 0" fails to parse
- function is parsed as expression statement
- could we check that last tok was } ?
- the closing brace should end the statement parsing

[DONE] TODO: when entering compileStub or compileEntry, set callCtx pointer in the VM
- could use a function to set/unset, enforce null on entry, non-null on exit
  setCallCtx(ctx)
  setCallCtx()

[DONE] TODO: RAEntry should have CodeGenCtx pointer
- Rename to CallCtx, move to ir/ir?

[DONE] TODO: add canvas lib to open issues
- Detail some basic sample usage

[DONE] TODO: Supported JavaScript Features page on wiki
- link on PGW

[DONE] TODO: link to Quickstart guide, wiki on PGW

[DONE] TODO: reporting bugs Wiki page

[DONE] TODO: fill in stdlibs in list of libraries on wiki

[DONE] TODO: increase default str table size, use power of 2 sizing, eliminate modulo
- Initial size should be 16K

[DONE] TODO: eval a throw test

[DONE] TODO: load, eval instructions
- Need to compile a new unit, then jump to it, return to caller continuation
- May want to split compileUnit, generate special return code separately?
- Want a callUnit function?
- compileUnit could do a more minimal compilation of a unit, return VersionInst
- or maybe don't use compileUnit at all!

[DONE] TODO: unit test for global property access of prop from Object.prototype
- Need simple fallback for when prop isn't on global obj
- Won't this require spilling everything?
- Property could get deleted

[DONE] FIXME: unresolved global, no exception thrown
- We aren't checking for that...
- Default can spill all, have fallback

[DONE] FIXME: programs/regress/new_array, bug in toUint32
run-time error: unsupported value in toUInt32: 128
- Does this fix crypto benchmarks?

[DONE] TODO: factorize a genCallBranch wrapper for genBranch
- in jit/ops, before all the call instructions
- boolean flag to generate call throw path

[DONE] TODO: add new null(), new undefined() tests

[DONE] FIXME: segfault on null() call

[DONE] TODO: make call throw on non-closure work
- needed by 4 tests
- spill all, call throwExc
- jump over this code normally?
- how do we get the exc version addr?
  - could have wrapper host function with less arguments
    - actually want to call throwError anyways, not throwExc
  - pass vm, call instr, exc handler version
- define a throwCallExc function

[DONE] FIXME: many_globals test produces call to non-function
- check what type comes out of get_global

[DONE] TODO: refactor getProp/putProp to use wstring for propName

[DONE] TODO: test basic exceptions, throw

[DONE] TODO: implement throw
- calls throwExc, passing exc val, then jumps to address returned

[DONE] TODO: make call instructions do vm.setRetEntry
- Also need to generate exc path

[DONE] TODO: throwExc needs to set exc object
- If call instr is null, set exc object, use return branch

[DONE] TODO: refactor compileUnit
- KISS, return CodePtr for entry branch edge
  - setup stack manually
  - callable only once
- No longer need callFun in VM.exec
- set return address, exc handler at end of compileUnit
  - ra should be custom return BranchEdge
  - exc handler is also custom BranchEdge

[DONE] TODO: rewrite throwExc
- Need map of RAs to <VersionInst callVer, CodeFragment excHandler>
- Exception traversal needs current IRFunction
  - Throw/unwind code returns exc handler addr to jump to
  - If stack fully unwound, set exc value ptr in VM
  - Value passed to host is a D RunError object
- Normal call exc handler generates moves
  - Host places exc value on VM stacks before returning
  - Handler removes ret value, places in callInstr.outSlot

[DONE] TODO: define CodePtr type in CodeBlock

[DONE] TODO: VM.compile(), VM.queue(version), VM.addVerRef(), etc?
- grep for .refList, .compQueue
- split jit.d into jit/state, jit/util, etc

[DONE] TODO: rename Interp class to VM
- rename uses and interp directory as well
- Grep for interp, Interp, interpreter

[DONE] TODO: get_ast_str

[DONE] TODO: remove interp/ops.d
- move useful contents to jit/ops.d and interp/interp.d

[DONE] Meeting:
- new, apply working
- all of stdlib initializing
- all stdlib tests working
- most benchmarks working
  - missing some because of GC, exceptions
- compilation time stat, about twice as fast

[DONE] TODO: re-add compilation time stat
- try on 3d-raytrace, v8/raytrace
- about twice faster

[DONE] TODO: get_time_ms

[DONE] FIXME: stdlib_number test returns 402
if ((0.5).toFixed() !== "1")

[DONE] TODO: call_apply
- Change callFun return address? Currently expects IRInstr

[DONE] TODO: map_prop_name

[DONE] TODO: establish fourth milestone
- All benchmarks running?

------------------------------------------------------------------------------

[DONE] Third milestone: standard library initialization

[DONE] TODO: make_link, needed by commonjs lib
- Why is it needed? What uses it?
  - set_str
  - regexp
- Easier to just keep supporting this for now

[DONE] TODO: add test for ctor with less args than needed, test for undef

[DONE] FIXME: segfault on ./higgs --e "test()" programs/stdlib_map/stdlib_map.js
- try with --jit_dumpinfo
- trace instructions
- Fails in Map.prototype.set
- call with integer 1 for closure value
- Missing argument init was wrong for new and regular call

[DONE] TODO: support for return from new
- enable unit tests

[DONE] TODO: new/constructor support
- Implement using host function first

[DONE] Meeting:
- Objects, arrays, closures, argument object, floating-point
- Fixed various bugs
- Almost all of stdlib loading
- Most unit tests working
- Missing features: exceptions, GC
- Higgs init time comparable to before, with interpreter
- Compiling ~300KB of code to init
- Idea: can recompile inline caches (at Moz, inline caches are linked-lists)

[DONE] TODO: mod_f64, using fmod

[DONE] TODO: f64_to_str, f64_to_str_lng

[DONE] TODO: cos_f64, sin_f64, sqrt_f64, log_f64, exp_f64, mod_f64, ceil_f64, floor_f64
- template unary FP host fun? HostFPOp(fun)
- enable unit tests
import std.c.math;

[DONE] FIXME: bug in merge sort test?
- has to do with cycle resolution in moves.d?
- issue with regress/loop_swap too?

[DONE] FIXME: higgs init time is quite slow
- profile it
- how much faster if we don't load regexp lib?
- add options to log functions being compiled?
execHeap = new CodeBlock(EXEC_HEAP_INIT_SIZE, /*opts.jit_dumpasm*/true);
- Disabling ASM comments gives us a huge speedup

[DONE] FIXME: arg_obj test segfaults
make; ./higgs --jit_dumpinfo --e "print(test())" argobj.js
- ret 0 instruction from test() segfaults
- is it return with extra args that's defective?
  - pushing 8 slots, as expected
  - popping wrong number of values
  - argc is way off... 64-bit issue? no
- Popping wrong number of args... 7 instead of 8
- extra args computation in gen_ret was wrong

[DONE] FIXME: assertion failed in stdlib/number test

[DONE] TODO: try enabling stdlib/math.js
- comment out loading of other libs for now

[DONE] TODO: array element access

[DONE] TODO: work towards object property access
- gen_map_num_props
- gen_map_prop_idx

[PASS] TODO: implement wrapper for static function ops
- HostOp(alias op, alias fun)(...)
static if( i < T.length - 1 && is( r1 == void ) )
static assert( a1.length != 1 || !is( a1[0] == Variant ),

[DONE] TODO: try to optimize call logic. Can some operations use 32-bit opnds?
- Can we use a second scratch reg to compute extra args?
- Can now count on delegate for scratch regs

[DONE] TODO: use delegates for the branch generation function
- No context object if no variables captured
- remove instr argument

[DONE] TODO: reimplement test-then-if optimization
- Test needs to generate the branching directly
- If suppresses its own code generation

[DONE] TODO: eq_f64, ne_f64, lt_f64

[DONE] TODO: look into D traits for function pointers
- Not clear from traits page, ask on D forum

[DONE] TODO: ask on dconf about closure opts
- make thread: Memory usage of delegates
  - Will it allocate extra objects or context if no shared variables?
  - Are closures heap-allocated, or by value?

[DONE] TODO: support for div_i32
- Needed for int to string conversion
- enable corresponding tests

[DONE] TODO: get_str
- try enabling string concat tests, try in the REPL first
- template one arg instructions like this? not yet

[DONE] TODO: function to save special jit registers

[DONE] FIXME: fix as.printStr
- test with heapAlloc

[DONE] TODO: lea instruction encoding
- only need to support 64-bit version

[DONE] TODO: closure variable support
- needs heap_alloc

[DONE] TODO: get_word, get_type, make_value
- needed for closure cells

[DONE] TODO: heap_alloc

[DONE] TODO: blog
- specifics of incremental JIT
- progress
  - REPL, static calls, primitives, tests
- stress/discomfort of having to take many important design decisions at once
  - exploratory programming
- compiler architect may be a great career move
- conference invites (mloc.js, Web Directions Code)
    http://mloc-js.com/
    http://code13.webdirections.org/
- book invite, AOSA vol 4
    http://aosabook.org/en/index.html

[DONE] TODO: store op

[DONE] TODO: support for print(), useful for debugging
- Needs regular calls, string functions

[DONE] TODO: load, needed for print

[DONE] TODO: compileEntry, log function being compiled for --jit_dumpinfo

[DONE] TODO: $ir_get_arg, needed for print(), others

[DONE] TODO: log call block size in bytes
- 330 bytes

[DONE] FIXME: call version has branch code marked as inside of it!
- genBranch should do markEnd?

[DONE] FIXME: segfault on too many arguments

[DONE] FIXME: identity function doesn't get its argument
- seem to be pushing the right number of locals

[DONE] TODO: transition regular call and new stub to unique shared stubs
- separate compileEntry function
  - ast-to-ir
  - adjust topmost stack frame, add undef args
  - compile entry block
  - set entry block ptr
  - no stub patching
- remove handling of null block ptr
  - just have special EntryStub code fragment

[DONE] TODO: init numLocals, numParams before ast-to-ir

[DONE] FIXME: some instructions have no disassembly?
- lost our alignment somewhere?
  - when patching a stub?
- try disabling rewriting of comments, see if it fixes the issue
  - doesn't seem to fix the problem
- seems we often get a misalignment after "jmp rax"
- problem could be in the selection of comments for versions/fragments
- the code being printed is some unit function entry...
  - no matter what's being printed
  - it's the machine code that's wrong, not the comments?

[DONE] TODO: regular function calls
- Need to do AST->IR conversion
  - May need special kind of stub?
- Should also store code ptr on IRFunction
- Entry stub?
  - could have one regular call stub and one new call stub
  - check the IRFunction, do the AST->IR?
  - issue: num locals, clos local varies
  - this is an issue for the GC too? Not really?
  - stubs may have to be specific to the function
  - how much code are we talking? everything already spilled
- call needs to:
  - get IRFunction ptr from clos
  - get numArgs
  - loop, pushing extra undef params (if not enough args)
  - get numLocals, push space for locals
  - push RA (linked)
  - get entry version ptr, jump to it (not linked)
- If not a closure, need to throw an exception ***
  - Make sure all is spilled, call an interpreter function
  - Can mostly ignore this for now

[DONE] TODO: modify new_clos to generate entry stub

------------------------------------------------------------------------------

[DONE] Second milestone: load runtime, working REPL with --nostdlib
- No GC yet
- Still no reg alloc
- Support for runtime primitives

[DONE] TODO: $ir_print_str

[DONE] FIXME: !0 should produce true, not infinity
- same for 0 && 2
- phi node problem? All of these have phi nodes
- execMoves is unimplemented!

[DONE] TODO: port/fix execMoves

[DONE] TODO: basic phi node handling
- without reg alloc, everything on stack
- need to implement allocState

[DONE] TODO: combine allocMap + typeMap
- Use struct with bit field inside, enum?

[DONE] TODO: set_str

[DONE] TODO: --jit_dumpinfo, write the exec heap position / size
- Do we have stat counter for total number of stubs and number of versions?
- Should log all this at end of compile() invocations

[DONE] TODO: CodeBlock toString needs start and end offsets

[DONE] TODO: jit_dumpasm, print only compiled code
- CodeFragment.toString

[DONE] TODO: enable all working unit tests

[DONE] TODO: log when phi nodes are used

[DONE] TODO: not_i32

[DONE] TODO: left shift, right shift

[DONE] TODO: less-than comparison

[DONE] TODO: mod_i32

[DONE] FIXME: invalid offsets
linking fragment ref, offset=18446744073709549282
- Log what the reference is to
- Negative offsets

[DONE] TODO: more complete return support
- but not yet return from new
- start with plain return, no return from new

[DONE] TODO: support for call_prim
- retWordReg, retTypeReg
- Return BranchCode object

[DONE] TODO: getCtx(IRFunction fun, bool newCall)
- Add ctx equality to state comparison
- Problem: two generic contexts?
  - Examine getBlockVersion
  - When does the generic state get created? Can we create one with matching ctx?

[DONE] TODO: reimplement add_i32_ovf, etc.

[DONE] TODO: reimplement if_true

[DONE] TODO: jcc instructions using reflist... Need to template this

[DONE] TODO: add compiled fragments to fragList
- Add compiled versions and also branch code

[DONE] TODO: reimplement gen_jump

[DONE] TODO: For end of block encoding, may be able to just use a function pointer (not a closure)
- Function takes enum indicating target 0 next, 1 next or neither next
- Function does the encoding of necessary branches
- Creates version refs as appropriate
- For call, can do the RA push, then jump to call entry
- Should simplify things, expose the logic in the appropriate places!

[DONE] TODO: May want to have branch edge moves in their own "code fragment" objects
- More flexible, these then become movable
- More efficient
- Can handle unit call/return more elegantly
- For return, can place ret word/type in special registers
- Return address is return branch edge
- Return branch edge moves ret val into stack slot (or not)
Fragment
BranchCode
BlockVersion
VersionStub
VersionInst

[DONE] TODO: genBranchEdge could return a BranchCode object?
- Can call method genCode(as, predState) at end of block?
- For return, write special moves, then call genCode

[DONE] TODO: implement setWord, setType

[DONE] FIXME: when compiling stub, should not be creating new block version in list
- replace stub entry instead
- don't use getBlockVersion
- array replace function?

[DONE] TODO: support for add_i32_ovf
- sufficient to compile basic add lazily
- add simple unit test

[DONE] TODO: low-level int & FP instructions

[DONE] TODO: need support for loading f64 imm to XMM
- Could use move to r64, then movq?
- For now, special case for zeroing out?
- pxor xmm, xmm?
66 0F EF /r PXOR xmm1, xmm2/m128
- general case, can jump over an inline constant
  - need one constant for our usage!
- try implementing limited IPR?
  movq(XMM0, X86Opnd(64, RIP, 2))
  jmp8(8) ; 2 bytes long
  ...64-bit imm...
  ...code resumes...

[DONE] TODO: limited IP-relative addressing, RIP + offset
- Use bit fields to pack mem loc representation

[DONE] TODO: jmp8

[DONE] TODO: div_f64, needed for NaN

[DONE] TODO: new_clos instr

[DONE] TODO: make_map instr
- Can allocate the map at JIT time!

[DONE] TODO: assert minimal space before compiling block
- 1 << 18 bytes (256KB)

------------------------------------------------------------------------------

[DONE] First milestone: no interp, basic incremental codegen
- No inlining
- Stubs
- Bump write pos to allocate, no code compaction

[DONE] TODO: IsTypeOp + unit test

[DONE] TODO: direct jump, add new if test for this

[DONE] FIXME: stub code not getting generated
- compQueue not mutated properly?

[DONE] TODO: CodeBlock.label should add a comment

[DONE] TODO: CmpOp
- For first version, always use cmov to produce a boolean

[DONE] TODO: setOutType with constant Type value

[DONE] TODO: genBranch
- For now, just switch on test type, do jump if false

[DONE] TODO: define a constant for JMP_REL32_OPCODE

[DONE] TODO: where do we set codeLen?
- Need to mark the inner code end explicitly

[DONE] TODO: versionRefs, compQueue...
- Add to Interp object directly
- Assert compQueue empty when entering compile

[DONE] TODO: could we merge ASMBlock, ExecBlock, compile directly in the execHeap?
- bool exec, bool comments
- Threads: just acquire a lock
- What if we exceed the bounds of the exec heap?
  - Need to do an exec heap compaction
  - This could conceptually happen mid-codegen
  - Could overestimate the max size of instructions + moves? Not obvious?
    - Can h4xx it, fix threshold at 1MB
- How do we deal with branch moves?
  - Could do a simple, direct encoding of final branches
  - At the same time, give block version useful annotations
- get rid of BlockVersion.write

[DONE] TODO: X86Reg.opnd(size)

[DONE] TODO: think about branches at end of blocks
- Can specifying operands to test and targets be enough?
  - e.g.: ilt, ieq, fgt, 64-bit, overflow
  - direct jump
- Works for if-type branches, type tests
- Calls are handled separately
- Look at old jit ops

[DONE] TODO: movsd encoding
Enc(opnds=['xmm', 'xmm/m64'], prefix=[0xF2], opcode=[0x0F, 0x10], rexW=False),
Enc(opnds=['xmm/m64', 'xmm'], prefix=[0xF2], opcode=[0x0F, 0x11], rexW=False),

[DONE] TODO: try implementing set_global, get_global
- Seems we don't need register allocation for this
- Problem: there is no cached global property index
  - Need to get those at JIT time
- Can get rid of the cached idx on the instruction
  - Get rid of IRCachedIdx as a whole

[DONE] TODO: setOutType w/ reg arg

[DONE] FIXME: return doesn't deal with mem arg
- tmpReg not properly implemented in getWordOpnd

[DONE] FIXME: odd assertion error involving comment strings
- Happens inside writeBlock, while merging strings
- Seems assumeSorted fails
- execHeap is not cleared everytime

[DONE] TODO: look at add_i32
- Should we implement reg alloc now?

[DONE] TODO: patch stubs once compiled
- create external compileStub and compileUnit functions?
  - both call internal compile function, not extern (C)

[DONE] TODO: patch version refs, refList

[DONE] FIXME: return 1 unit test fails
- test more encodings
- fixed bug in push/pop encoding
- reading from interp object causes segfault
- found bug in encoding of mov r15, imm

[DONE] FIXME: duplicate ret asm string, missing comment string
- Something wrong in CodeBlock.toString?
  - dump all the strings to verify
  - strings are as presented, ret is there twice at the same position!
- Found bug in clear function

[DONE] TODO: --jit_dumpasm

[DONE] FIXME: segfault while compiling unit entry
- Bug in getWordOpnd

[DONE] TODO: make Interp compile/call unit functions

[DONE] TODO: return op generation for unit-level functions
- Also need entry generation for unit-level functions
  - static template flag to compile?

[DONE] TODO: basic implementation of getWordOpnd/getTypeOpnd
- Needed for return op, other ops

[DONE] TODO: initial genBranchEdge(edge, predState)

[DONE] TODO: stub generation
- stubs call the JIT with block and state object ptrs
- Need special class for stubs
call compile
jmp RAX

[DONE] TODO: begin sketching compile(block, state)
- Should start with all values always on the stack, no type info
- How do we deal with requests for other versions?
  - Compilation queue?
  - Finalize blocks into execHeap at the end?

[DONE] TODO: interp, add new fields
- execHeap
- blockVersions list
- map of blocks to versions

[DONE] TODO: xmm arith op encoding
- No immediates
- Some have L vs R encoding
- Some have two opnd sizes supported
- Do template but keep it limited
  - add, mul, sub, sqrt, ucomisd
  - writeXMM64

[DONE] TODO: shift encoding

[DONE] FIXME: crash bug in movsx test
- code causes crash
- bug in mov mem8, imm8 encoding

[DONE] TODO: movsx, movzx encoding

[DONE] TODO: think about how compilation starts in interpreter
- Setup call stack
- Create ctx for unit function
- Create state for entry block
- Call compile(bloc, state)
  - returns code ptr
- Call into entry block
- Call and return from unit functions can be special
  - Setup stack properly, use ret instr on return
- When stubs are hit, further compilation occurs

[DONE] TODO: idiv, not, inc, dec encoding
- Make template for this, writeRMUnary

[DONE] TODO: CodeBlock, specialize into ASMBlock and ExecBlock
- ASMBlock has auto-expansion

[DONE] TODO: sketch BlockVersion class in jit.d
- BlockVersion: block, state, startIdx
  - state at entry
- VersionStub: no length, instance ref
- VersionInst: branch descs, move code idxs
  - Final branches and associated moves
  - May need to be specific about what conditional branches are testing
  - Target BlockVersion objs

[DONE] TODO: imul encoding

[DONE] TODO: begin testing code execution

[DONE] TODO: sub encoding

[DONE] TODO: conditional jump, jcc encoding
- Template it based on jmp

[DONE] TODO: cmov encoding
- TODO: template with opcode?

[DONE] TODO: mov encoding

[DONE] TODO: support for labels in assembler
- Write code in the code block
- Write empty patchable gap for address
- Store label ref in a list in the assembler object
- Need linkage pass to match refs to labels in table

[DONE] TODO: should also have option to record assembly strings
- Maybe this should be at the code block level
- Allows carrying over when writing code block
- Store pairs of indices and strings
- Have some asmComment function that checks for jit_dumpasm
  - Should take mnem and args as params
  - Could have 4 versions for different arities (0,1,2,3)
    - Template that, yo
  - Should also disable if not in debug mode

[DONE] TODO: template encoding of add for sub/cmp/or/xor/etc

[DONE] TODO: begin testing instruction encodings
- Test with CodeBlock or with Assembler?
- Need assembler objects if we have labels
- Could test both kinds separately
- Start with CodeBlock only

[DONE] TODO: instruction encoding, use templated function?
- Can have templated fn with many template parameters
- The two arguments are the only actual parameters
  - One of the arguments may be "none"

[DONE] TODO: deny 32-bit base or index registers, for simplicity?
- Simplify mem opnd, use reg no only, smaller size

[DONE] TODO: X86Opnd struct with union inside
- Needs a special none value

[DONE] TODO: begin with simple instruction encodings in x86.d
- No intermediate structures for instrs, just encode directly
- First goal is basic system working, don't write all encodings now
  - But begin testing early
- Lower-level encoding functions should work with CodeBlock objects
- Some op like move, cmp, jz should work on CodeBlock
  - But can be aliased for Assembler (possibly with an easy macro!)
- Some ops only fit in innerCode, should apply to Assembler only
nop(CodeBlock cb, size_t length = 1)
jmp(CodeBlock cb, Label label)

[DONE] TODO: x86 opnds
- Want to avoid allocating big objects for mem opnds, etc.
- Want operand structs
- Could use regno values in mem opnds to avoid infinite rec
- Could maybe have a big X86Opnd union for when needed?
  - Or just one big struct implementing it all?
  - Multiple structs are probably more expressive, more specific

[DONE] TODO: sketch CodeGenState, CodeGenCtx in jit/jit.d
- CodeGenState has ctx object pointer
- CodeGenCtx should have:
  - IRFunction, 
  - num extra locals, 
  - parent context (for inlining)
  - inlineSite (call site, if inlined)

[DONE] TODO: CodeBlock class

[DONE] TODO: comment out assembler tests, remove encodings

[DONE] TODO: compute fun liveness info in ast-to-IR

[DONE] TODO: remove JIT entry point, block exec count from IR

[DONE] TODO: comment out JIT code
- Comment out contents of jit.d, ops.d

[DONE] TODO: comment out interpreter ops
- Remove superfluous ops

[DONE] TODO: comment out interpreter unit tests

[DONE] Meeting:
- Conference
- Internships
- Incremental code gen
- Clever stack alloc & inlining

------------------------------------------------------------------------------

[DONE] TODO: unit test that checks object == and === equality after extension
- Push to master once done

[DONE] TODO: unit test that extends global object through indirect pointer
- globalObj = this; ...
- Loop with property names to 5000
- Once extended, try setting global prop, reading global prop

[DONE] FIXME: delete as property name not supported
- Special case of . member operator
- Add parser test
- Test map
- Does Tachyon have map unit tests?
- Push to master

[DONE] TODO: add map.js to Higgs stdlib
- Impact on make test time?
- Make more ES6 conformant

[DONE] TODO: think about lazy code gen, make new codument

[DONE] TODO: custom D assert handler
- Even more useful if no more interpreter
void setAssertHandler(errorHandlerType h);
alias AssertHandler = void function(string file, size_t line, string msg) nothrow;
throw new AssertError( msg, file, line );

[DONE] TODO: ask StackOverflow about 4GB executable alloc
- Want to guarantee 32 bit relative jumps always work
- Does any OS allocate the pages you don't touch?
=> yes, probably safe, but not clear that this is necessarily what we want
    how will our memory GC work?
=> limited to 2GB machine code, not that great anyways?
=> probably want to prefer 32-bit offset, but support 64-bit if needed?

[DONE] Monday meeting:
- Higgs roadmap
- Benchmarks using arrays
- Unifying theme for thesis
- Internship possibilities for the summer *****

[DONE] TODO: look at benchmarks using arrays
- How are the arrays used? Do we always loop over all elements
- Submethods mutating elements? ***
- SunSpider:
    spectral norm might work
    3d-cube, many matrix/vector ops, most not in a convenient form
        may be able to tag on creation, however
    3d-raytrace, has 3D vectors, but loops pre-unrolled
        could also test on creation and write
    fannkuch, integer arrays, but no clear "i < length"
    nsieve, boolean array, same problem
    cordic, float array, same problem
    crypto benchs use byte arrays
    string-base64 also has arrays of ints
- V8:
    crypto uses arrays with constants instead of .length for size
    navier-stokes, uses width, height which aren't array length
- Many benchmarks use arrays of integers and floats, especially in SunSpider
- Sensible way is to test when writing to array, not when reading

[DONE] TODO: think about unifying theme for thesis
- Lazy compilation?
- Versioning?
- Dynamic compilation? Dynamic languages need dynamic compilers
  - Versioning and laziness fit under this umbrella
- Dynamic, delayed compilation for better performances
- Many ways to be dynamic
- Argument why this is good

[DONE] Group meeting:
- Higgs refactorings
- Map system on the host side
- Created a dev branch
- Higgs roadmap

[DONE] TODO: new document, Higgs roadmap
- Lazy JIT plans
- Local profiling
- Inlining, should be more aggressive in hot code
- Type representation
- Interprocedural JIT
- Lazy prop? How to make this practical

[DONE] TODO: make print accept var arg, use $argc

[DONE] TODO: re-run ./benchmark after map introduction (on desktop)
is_i32: 4925933
is_const: 73248
exec time (ms): 1187
comp time (ms): 180
interp cycles: 535948
code size (bytes): 90032
is_rawptr: 28
call bailouts: 6
is_i64: 1
type tests: 7825131
unjit instrs: 55799
ret bailouts: 5
is_refptr: 297776
is_f64: 14666

[DONE] TODO: shootout/hash2, class capacity exceeded, should work now

[DONE] TODO: create dev-maxime branch

[DONE] TODO: rename ClassMap to ObjMap?

[DONE] FIXME: obj_get_map, need load_mapptr

[DONE] FIXME: segmentation fault
instr: ret $2 ($rt_arrtbl_alloc(14FF))
instr: $0 = map_num_props $8 ($rt_newArr(2B3C))
Segmentation fault (core dumped)

[DONE] FIXME: interp.interp.RunError: call to non-function
RegExp(AB62) ("stdlib/regexp.js"@864:1)
- Probably method lookup failing?

[DONE] TODO: GC must scan ctor map in closures

[DONE] TODO: new ctor map, set at new_clos time? Should be the same for all "new" operators
- Just lazily create in new

[DONE] TODO: $rt_getPropEnum
- Need way to get prop names, null if none?
$rt_class_get_prop_name => $ir_map_prop_name

[DONE] TODO: $rt_getPropIdx, IR instr should return false if not found

[DONE] TODO: $rt_class_get_num_props(classPtr) => $ir_map_num_props?

[DONE] TODO: look at link creation in ir/ast.d

[DONE] TODO: MAKE_CLASS, minNumProps, numRsvProps

[DONE] TODO: gc, when scanning IR, scan IRMapPtr, visitMap!

[DONE] TODO: interp/ops, make MAKE_CLOS, newArr, newObj use IRMapPtr instead of IRLinkIdx

[DONE] TODO: GC, when traversing object, visit map ptr, visitMap

[DONE] TODO: rework map creation in interp.d for newObj, global obj
- Add ref to mapRefs
- newMap(Interp interp)? getMap?

[DONE] TODO: remove map layout

[DONE] TODO: map accessor instructions
- Mostly just getPropIdx for now?

[DONE] TODO: gc support for maps
- mapRefs, liveMaps

[DONE] TODO: run ./benchmark before refactoring (desktop times)
is_i32: 4981024
is_const: 75589
exec time (ms): 955
comp time (ms): 220
interp cycles: 624630
code size (bytes): 102622
is_rawptr: 29
call bailouts: 6
is_i64: 1
type tests: 7884795
unjit instrs: 6746
ret bailouts: 5
is_refptr: 299946
is_f64: 14909

[DONE] TODO: MAKE_MAP instr
- Make classes host/VM objects
- CLASSPTR type tag
- needs caching, IRClassPtr

[DONE] TODO: implement class map

[DONE] TODO: can we eliminate setTarget with branch desc argument, have only block arg?

[DONE] TODO: IR, attach branch descs to branch instructions instead of pred blocks?
- examine use cases
  - grep -R "\.pred" .
- might need to rework remInstr, remBlock?

[DONE] TODO: remove type prop from master branch

[DONE] TODO: pull changes from cc2014 branch

[DONE] TODO: add music.js to lib/

------------------------------------------------------------------------------

[DONE] Oct 11th: CC Paper Submission Deadline
- 20 page limit, LNCS format

[DONE] TODO: create cc2014 branch on github
- put inlining limit very high, 50
- reduce min call frac

[DONE] TODO: typeProp improves upon versioning results on 3d-cube, why?
- Identify smaller benchmark where typeProp catches cases
./higgs --stats --jit_maxvers=50 --jit_typeprop
- bitops-nsieve-bits also
- beats us on phi nodes *** why???
Flow into self might be tricky?
- We can enter mid-loop... Have no type info
- Very little difference when enabling type prop over versioning in practice

------------------------------------------------------------------------------

[DONE] TODO: test --jit_typeprop with ./benchmark.py
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
- Works, successfully reduces type tests

[DONE] TODO: use typeMap in IsTypeOp

[PASS] FIXME: programs/sunspider/crypto-aes
- Nondeterministic behavior, decryptedText.length varies between runs
- Does it work with --jit_disable? Same number of interp cycles, same string length?
- Nope!
- Problem with interpreter u16 load/store semantics?
  - Not load, check if store changes value
  - Store: value properly truncated, but u32 always different
- Why are the int32 values not always the same...
- Nondeterminism comes from usage of date, but length should be the same as V8...
- Faulty regexp implementation may be at fault, skip for now

[DONE] TODO: test typeProp with ./benchmark.py

[DONE] TODO: store typeMap on CodeGenCtx

[DONE] TODO: examine typeProp code, do transfer functions all make sense?
- Found one bug

[DONE] TODO: email Marc, notes:
- Added type test breakout by type
- Tried tweaking inlining heuristics to further reduce type tests, not very successful
- Began implementing intraprocedural representation analysis, based on SCCP
- Will add command-line flag to enable analysis

[DONE] TODO: test --jit_typeprop
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"

[DONE] TODO: add command-line option to enable type prop, --jit_typeprop

[DONE] TODO: complete type prop implementation

[DONE] TODO: document csv module, example

[DONE] TODO: begin work on intraprocedural representation analysis (SCCP)
- ir/typeprop.d
- Same type model as backend
- Must be able to gain info from type tests
- Fixed-point

[DONE] TODO: read_i8, read_i16, notify Tom
- Ask to use load_u32 for load_i32

[DONE] TODO: try inlining all the adds/subs/muls first
- 3d-raytrace is very sensitive to the inlining of arithmetic primitives
- Do it one-level only: make list of adds/subs/muls in CFG, inline them
- Does this reduce the number of type tests? Check effect with ./benchmark
- Before, growth factor 30x:
    is_i32: 2141245
    is_const: 20976
    exec time (ms): 1465
    comp time (ms): 402
    interp cycles: 1267749
    code size (bytes): 138314
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3717303
    unjit instrs: 5992
    ret bailouts: 8
    is_refptr: 291458
    is_f64: 10210
- After, growth factor 30x:
    is_i32: 2136726
    is_const: 20977
    exec time (ms): 1485
    comp time (ms): 425
    interp cycles: 1270943
    code size (bytes): 139407
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3712645
    unjit instrs: 5997
    ret bailouts: 8
    is_refptr: 291435
    is_f64: 10199
- Doesn't do much!

[DONE] TODO: try smaller growth factor for just primitives, eg: 3x
- Still many type tests to eliminate
- Unfortunately doesn't help at all

[DONE] TODO: copy over Tachyon SCCP code into ir/typeprop.d, create bare module

[DONE] TODO: breakout of specific kinds of type tests with counts

[DONE] TODO: try scrapping min call frac heuristic
- See effect on global type tests, code size, exec time
- Before, budget 3x
    exec time (ms): 621
    comp time (ms): 133
    interp cycles: 675989
    code size (bytes): 108567
    call bailouts: 0
    type tests: 7957747
    unjit instrs: 0
    ret bailouts: 0
- Before, budget 40x
    exec time (ms): 880
    comp time (ms): 235
    interp cycles: 1270519
    code size (bytes): 142653
    call bailouts: 0
    type tests: 3540466
    unjit instrs: 5998
    ret bailouts: 0
- After, budget 3x, frac 50
    exec time (ms): 681
    comp time (ms): 142
    interp cycles: 662441
    code size (bytes): 109442
    call bailouts: 0
    type tests: 9063187
    unjit instrs: 7688
    ret bailouts: 0
- After, budget 10x, frac 50
    exec time (ms): 825
    comp time (ms): 249
    interp cycles: 879796
    code size (bytes): 133343
    call bailouts: 0
    type tests: 5866077
    unjit instrs: 8144
    ret bailouts: 0
- After, budget 40x, frac 50
    exec time (ms): 1091
    comp time (ms): 345
    interp cycles: 1240329
    code size (bytes): 153116
    call bailouts: 0
    type tests: 3693675
    unjit instrs: 6118
    ret bailouts: 0

[DONE] Meeting notes:
sort log_tests_3d_raytrace.txt | uniq -c | sort -n
- FP comparisons improved based on GCC
- Added CSV output to benchmarking script
  - For paper, command-line tools, latex csv package
- Discuss specific metrics to gather
  - currently: 
    - total generated code size
    - JIT compilation time (*JIT only*)
    - Total execution time including compilation
    - Number of type tests executed by the JIT
- Toutes les statistiques (incluant le temps d'excution) devraient se faire
  mesurer lorsque le code s'est "stabilis" (plus de nouvelles versions de BB).
  - Difficile a faire, invalidation de code pendant execution, somewhat incremental
- Dans l'article on pourra complter avec des statistiques plus globales (incluant
  le temps de compilation, le temps pass dans l'interprte, etc).
  - I have usec counter, but lots of context-switching happens, won't be fully precise?
  - Could design timer mechanism based on state machine, events, count time in each state?
  - Could try using CPU cycle counter (but will include *some* OS context-switching noise
- Il ne faut pas perdre de vue qu'on doit dcoupler autant que possible l'tude
  du versionnement de BB de son implantation dans Higgs
  - Optimal case, compilation time is irrelevant?

[DONE] TODO: log JITTed type tests executed, examine what happens in 3d-raytrace
- needs inlining budget of ~20X to eliminate most type tests...
- can we annotate functions? how can we help this?
- can do JIT trace, see where types tested come from
- with 3x budget:
    3d-raytrace : is_i32 tests in rt_add and rt_lt
    3d-cube     : is_i32, is_f64 in add, lt, ge, some inlined in DrawLine
    earley-boyer: se, getProp, setProp, all uninlined
    still many calls to uninlined primitives
- with 40x budget: 
    3d-raytrace : is_i32, is_f64 Triangle.prototype.intersect, many getProp, still some rt_lt, rt_ns
    3d-cube     : almost all is_i32 and is_f64 in drawline. Why are these not all eliminated???
    earley-boyer: many in getProp, ns, some inlined

[DONE] TODO: benchmarking script, add cmd line options for higgs CMD, csv out file
- Keep default command
- Does Python have some option parsing module?

[DONE] TODO: look into CSV command-line tools
- transpose, concat, etc
- use python CSV package, program util fns

[DONE] TODO: look into CSV to latex tool
\documentclass{article}
\usepackage{csvsimple}
\begin{document}
\csvautotabular{scientists.csv}
\end{document}

[DONE] TODO: benchmarking script, generate CSV output

[DONE] TODO: get updated stats
exec time (ms): 1004
comp time (ms): 234
interp cycles: 675941
code size (bytes): 108613
call bailouts: 0
type tests: 7958803
unjit instrs: 0
ret bailouts: 0

[DONE] FIXME: growth factor issue, functions grow at every invalidation

[DONE] TODO: use "growth factor" based on initial size for inlining budget
- Special provision for small functions
- Allow 3x, shrinkage after peephole

[DONE] TODO: sort call sites by exec frequency for inlining
- Go through call sites, find most executed eligible call site
  - implement in separate function
  - could check caller and callee size at the same time
- Eliminates need for current min frequency heuristic
- Log performance before and after
- Keep minimum call threshold for inlining, useful for primitives

[DONE] TODO: threshold on block stubs before immediately invalidating
- Might save compilation time, allow for more useful profiling

[DONE] TODO: get mean exec times and type tests
exec time (ms): 1146
comp time (ms): 175
interp cycles: 801596
code size (bytes): 93926
call bailouts: 0
type tests: 7174455
unjit instrs: 7948
ret bailouts: 0

[DONE] TODO: benchmark script, geo mean of type tests, cut out decimals

[DONE] TODO: benchmarking script, display mean times (exec time (ms))

[DONE] TODO: stats, shorten names

[DONE] TODO: examine inlining decisions in bitwise-and, run with --nostdlib
- Way too many type tests!
- purportedly inlines rt_lt, rt_and, rt_add
- Need to look at ASM output
- The problem is that we're operating on global values!

[DONE] TODO: peephole opt for if_true of constant

[DONE] FIXME: 3d-raytrace segfaults with maxvers=0
./higgs --jit_maxvers=0 --jit_dumpinfo --stats programs/sunspider/3d-raytrace.js
- Crashes during GC, invalid ref?
  - Forwarding clearly integer or const value

[DONE] TODO: test nsieve-bits, 3d-cube, 3d-raytrace with maxvers=0

[DONE] FIXME: segfault with maxvers=1 on bitwise-and
./higgs --jit_maxvers=1 --stats programs/sunspider/bitops-bitwise-and.js
- crashes somewhere in stdlib?
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
Segmentation fault (core dumped)
num blocks: 20
num versions: 21
compiling function $rt_getPropObj(2D2F)
compiling block: entry(3305) (execCount=252)
compiling block: for_test(330C) (execCount=801)
block cap hit: 1
compiling block: for_body(330D) (execCount=801)
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
for_test(330C) ($rt_getPropObj(2D2F))
if_true true => for_body(330D), for_exit(330F)
for_body(330D) ($rt_getPropObj(2D2F))
$2 = call_prim "$rt_obj_get_next", <fun:$rt_obj_get_next(12F8)>, $1 => call_cont(331F)
entry(336D) ($rt_obj_get_next(12F8))
$0 = load_refptr $5, 0
Segmentation fault (core dumped)
Note: we're entering getPropObj mid-loop, at for_test, and the block cap is hit...
- Take a look at ASM dump!
- When we jump from the exported entry point, we don't load anything into r10
- Probably because we don't treat entry points like block transitions ****

[DONE] TODO: implement cap on number of block versions
- Add command-line options, jit_maxvers=n
- If we request things like known phi types, will get mismatch
  - Once we reach the vers limit, compile general version, will match all
- General vers can have custom regs, but no known types and values
  - Strip pred map of known types and values

[DONE] FIXME: issue, function entry contexts have no locals, will give perfect match score?
- Should have penalty if pred map has more entries than succ map?
- Or maybe do another scan for pred maps, check for missing info in succ

[DONE] TODO: CodeGenState.diff(that), distance function
- returns size_t, size_t.max if incompatible, 0 if perfect match
- Sums up penalties

[DONE] TODO: implement get_link instruction in JIT
- pre unjitted ops, 3d-raytrace: 59713, 3d-cube: 104491

[DONE] TODO: implement floating-point comparison instructions
- 3d-raytrace, 3d-cube dominated by FP comparisons
- use UCOMISD instruction
- Pre-opt times, 3d-cube: 1796ms, 3d-raytrace: 2193ms
- Time not really improved

[DONE] TODO: genBoolOut

[DONE] TODO: release target with no asserts for performance testing
- the -release flag disables assertions

[DONE] FIXME: 3d-cube segfaults with lt_f64
- Do we need to use JB, JA, etc? with UCOMISD?

[DONE] TODO: get_arr_proto JIT instr

------------------------------------------------------------------------------

Goal: perf gains on loop increment microbenchmark 

[DONE] FIXME: earley-boyer segfaults when run on its own
$40 = add_i32 $18, 1
jump => arg_test(18645)
$0 = lt_i32 $18, $92
$19 = get_arg $18
Segmentation fault
sc_list(13F29)
0
sc_list(13F29)
139998753980417

[DONE] FIXME: JIT bug wrt call_prim, crash on stdlib init

[DONE] TODO: optimize calling primitives by name
- Time improvement on all benchmarks, code size reduced
- Number of type tests not always reduced

[DONE] TODO: Record new stats for 3d-cube, 3d-raytrace, earley-boyer

3d-cube:
total execution time (ms): 1948
total compilation time (ms): 563
machine code generated (bytes): 240666
type tests executed: 8724951
unjitted instructions executed: 346907
call bailouts executed: 0
return bailouts executed: 2626
interpreter cycles executed: 1569272

3d-raytrace:
total execution time (ms): 2844
total compilation time (ms): 968
machine code generated (bytes): 405845
type tests executed: 23950271
unjitted instructions executed: 192498
call bailouts executed: 0
return bailouts executed: 2544
interpreter cycles executed: 1106456

earley-boyer:
total execution time (ms): 5775
total compilation time (ms): 822
machine code generated (bytes): 354933
type tests executed: 24255101
unjitted instructions executed: 473302
call bailouts executed: 4143
return bailouts executed: 266451
interpreter cycles executed: 3638773

[DONE] TODO: add Marc's microbenchmark to repo
programs/jit/loop_decr_sum.js

[DONE] TODO: blog about inlining
- perf
- basic heuristics
- making inlining more selective
- many bugs in 300 lines of code
- testing with interpreter only
  - interpreter is robust, easier to debug
- benchmark loop incr to 500M with and without inlining

[DONE] TODO: phi of phi peephole opt
- pred has phi and then jump, succ has one phi which uses our phi
- make our incoming jump to succ, pass phi arguments directly
- big incr down to 3.2s, 409 bytes

[DONE] TODO: Redundant jump peephole
- Block ends in a jump, successor has no phi nodes, successor has only one incoming
- Might enable further phi elimination. 7 phis before. 7 after, but some opts!
- big incr down to 4.3s, 412 bytes

[DONE] FIXME:
mov rbp, [qword r14 + 200];             49 8B AE C8 00 00 00
mov [byte r13 + 23], 0;                 41 C6 45 17 00
mov [qword r14 + 184], 0;               49 C7 86 B8 00 00 00 00 00 00 00
Don't need to write the value 0 if we just wrote a non-pointer type tag
- Measure big_incr perf before and after
    5.9s    411 bytes
    5.1s    462 bytes

[DONE] TODO: add asm comment with function name for asm dump

[DONE] Meeting notes:
- Fixed many bugs, system now much more stable
- Inlining increases compilation time, but decreases execution time significantly
- Made inlining more selective
- Implemented static calls, significant performance gains
- Implemented propagation of known types through phi nodes
- Implemented OSR for top of stack functions mid-loop execution
- Enabled peephole opts mid-loop execution
- Tried loop to 2B, decreased type tests from 4B down to 1

[DONE] TODO: enable peephole opts mid-function?
- Need current target and liveness info
- Don't remove the current block (assert delBlock doesn't do this)
- Don't remove live phis or instrs (just skip?)
optIR(fun, IRBlock target)
- Don't delete the current target block
- Can't replace an instruction that's live by a value that's not live

[DONE] TODO: look at IR from big_incr, can we eliminate phi nodes easily?
- 7 phi nodes in total
- several possible improvements, worth looking into

[DONE] TODO: don't inline when compiling primitives? No!
- will make their compilation faster
- should result in better inlining overall
- do we have an isPrimitive, isRuntime test?
  - add method to IRFunction?
- What's the difference in compilation time?
- Performance is worse on every benchmark, even though comp time is smaller

[DONE] TODO: propagate types through phi nodes
- Could save type byte moves, generate better code in loop microbenchmark
- Reduced code size, reduced type tests on benchmarks
- Not much type test reduction on some benchmarks
  - Possibly, unjitted instructions are causing spills
- One type test executed in big incr (mid-loop entry), down from 4B

3d-cube:
total execution time (ms): 2223
total compilation time (ms): 599
machine code generated (bytes): 253236
type tests executed: 8998583
unjitted instructions executed: 344956
call bailouts executed: 0
return bailouts executed: 2426
interpreter cycles executed: 1820808

3d-raytrace:
total execution time (ms): 3052
total compilation time (ms): 909
machine code generated (bytes): 386667
type tests executed: 31909720
unjitted instructions executed: 190284
call bailouts executed: 0
return bailouts executed: 2494
interpreter cycles executed: 1310769

earley-boyer:
total execution time (ms): 6509
total compilation time (ms): 863
machine code generated (bytes): 362126
type tests executed: 32377182
unjitted instructions executed: 470606
call bailouts executed: 3725
return bailouts executed: 266251
interpreter cycles executed: 3885102

[DONE] TODO: modify IsTypeOp comparison + branch to add info to context?
- Loop microbenchmark does is_i32 twice, once for lt, once for add
- Could save 6 instructions in loop benchmark
- Pre-opt exec time : 8.45s
- Post-opt exec time: 6.78s
- Less type tests in 3d-cube and 3d-raytrace, but more code, slightly slower...

[DONE] TODO: look at code for the for loop test
- write this code in a JS file, programs/jit/big_incr_loop.js
time ./higgs --nostdlib --jit_dumpinfo --jit_dumpasm programs/jit/loop_big_incr.js
- phi nodes make optimization difficult... Should look at IR, try to enable peephole opts mid-exec?
- not passing type info through phi nodes, problematic for loop opt

[DONE] TODO: add comments for phi node moves... Hard to decipher as is

[DONE] FIXME: dumpir fails, segfault

[DONE] TODO: --jit_dumpir

[DONE] TODO: ASMInstr.nextNC?
- Modify peephole to ignore comments

[DONE] TODO: make inlining take advantage of static calls
- avoid placing conditional block when inlining call_prim

[DONE] TODO: implement call_prim in JIT
- funOnStack segfaults...
- only one call_prim occurs, to rt_lt, corrupts frame

[DONE] TODO: implement static calls for runtime primitives
- call_prim "str" ptr, cached IRFunPtr instruction
  - check that the function has no closure variables
- modify runtime call generation in ir/ast
  - call with IRFunPtr directly, no closure object

[DONE] TODO: optimize init loops in layout.js, use lt_i32, add_i32
- benchmark
- improves times of both 3d-cube and 3d-raytrace

[DONE] TODO: in collectFun, nullify instruction args, remove uses
- See if mem usage is improved, maybe a bit

[DONE] FIXME: sunspider/3d-cube segfaults
- Crashes just after rewriting the frame for MMulti
$5 = heap_alloc $23
$6 = get_global "$rt_arrtbl_set_cap", <idx:164>
$7 = get_global_obj
if_eq_fun $6, <fun:$rt_arrtbl_set_cap(1611)> => entry(100C2), call_reg(100CA)
$0 = get_global "$rt_arrtbl_ofs_cap", <idx:154>
$1 = get_global_obj
$27 = call $0, $1, $5 => call_cont(100C6)
ret 12
store_u32 $5, $27, $109
The offset is correct
The pointer is invalid
$5 gets corrupted?
- Bug in JIT heap_alloc implementation

[DONE] FIXME: jit crashes after inlining 
entering fn: $rt_obj_set_type(1301) (entry(3BD9))
- Store offset in store instruction is corrupted
- Need to zero-extend the offset

[DONE] FIXME: rework inlining to create return phi in special call merge block
Creating a return phi in a loop header is problematic. Can't know what the
initialization conditions should be for blocks that already have incoming branches

[DONE] FIXME: jit/jit.d(1186): no reg mapping for instr:
$26 = load_refptr $177, $52 (no uses)
./higgs --e "test()" --jit_dumpinfo programs/gc/graph.js
- peephole currently disabled when doing mid-execution OSR

[DONE] FIXME: top-level OSR faults after jit_inlining2
- op_set_str fails with refptr out of heap, odd!
  - possibly, a function was GCd, its link table entries collected?
- Possibly need to be careful when collecting link table entries
  - Should make sure they have no uses before removing them

[DONE] TODO: make load throw proper JS exception when failing to load file
- Test in interpreter
- Add test for this

[DONE] FIXME: top-level OSR segfaults 
- Could try again disabling JIT, letting interp run, problems will be more obvious
- ops.d(389): invalid operand 2 type in op "auto r = x * y;" (int32)
  - Log function where this occurs
- Phi value is not rewritten, skipped as dead
- Only 4 values written, none overwritten
- Log the values we're rewriting, to see if they make any sense
  - Values appear sensible
- PROBLEM: when at target, we already made the jump, we're *past* the phi nodes
  - Must check liveness after the phi nodes
- Still have an issue in 3d-raytrace
  rewriting frame for Array(5EE4) at for_test(E893)
  - Newly created array value is not rewritten
  - Array value not marked live after first block instr?
The $rt_newArr call was inlined
$20 = phi [call_reg(120B1):0 => $51, call_cont(120AE):0 => $50]
$20 is used in the loop body
$20 is returned
But somehow we don't see $20 as live at the for_test block
Do we even query for $20? Probably not... $20 was live before the
transformation, but isn't anymore!
Still a problem... We've created a phi node for the array (return phi), but
this phi node was not executed because it didn't exist!
Would need to check, for live values being rewritten, which ones are inputs to
phi nodes from our block, and the phi node wasn't rewritten (is new)
- Catches the case where we have a new phi node
- Idea is: I have a value that is live, does it go into some phi node that is
  also live here?
- Try this and see if it works in practice...
Do we actually want liveness info from before inlining? ***
Could we be in some situation where some phi node needed to have been executed
way back, because of some other inlining? The value was replaced by a phi node? ***
- Seems like we could
- Can detect what phi nodes are newly live, see which of their inputs were live previously
  - If multiple inputs were previously live???
  - In the case of inlining, might be impossible that multiple inputs were previously live,
    because the inlined case didn't exist
- store mapping of call sites to ret phi nodes, process phi nodes based on
post-inlining liveness info

[DONE] FIXME: inlining should not create return phi if there are no uses of the call site

[DONE] TODO: implement top-level OSR mid-function
- Save current stack frame into temp arrays
- Redo liveness info if necessary
- Pay attention to liveness and IP when doing peephole
  - For first version, probably shouldn't do peephole in this case

[DONE] TODO: IRBlock.moveInstr(dst)
- Want to maintain instruction identity when possible
- Stack frame translation post inlining will be problematic otherwise
- remove/unlink from current block
- add/relink in new block
  - update instr.block
- if branch, change descs to point from current block, replace old block in preds

[DONE] FIXME: sunspider/string-base64, jit/jit.d(1073): no reg mapping for instr:
$25 = and_i32 $1, -8
- Is this instr not used, is it from the wrong function?

[DONE] TODO: revise Higgs page on pointersgonewild
- add new supported benchs
- remove runtime redefinable prims as language feature

[DONE] TODO: IRValue.addUse if use is dstval, check that from same fn
- Put in assert or debug block

[DONE] TODO: enable JIT pathos test

[DONE] TODO: alloc state cleanup code
- After each instr, should check if its uses are now dead, if so, remove all
type and alloc info. For branches, should pass branch instr to the 
genBranchEdge function, this function should cleanup any uses of the
branch instruction itself.
- cleanup fn should just remove output type of instrs if immediately dead ***
- May want to add liveAtEntry and other helpful functions to liveness info class.

Meeting notes:
- Inlining bugs fixed, now fully working with JIT
- Found some language shootout benchmarks
- With inlining, compilation time is much longer, but benchmarks still faster
- More selective inlining, less useless inlinings
  - Faster compile time, less machine code generated, better execution time
- Pathological case, now we inline more useful code, but seem to get exponential blowup
- Probably need block version cap

[PASS] FIXME: function: safe_add(EF0C)
machine code bytes: 2798357
num locals: 108
num blocks: 106
num versions: 35294
- Doesn't even contain a loop, unclear why so many versions
  - Might have a string op in there?
  - No for_ blocks or obvious loop blocks
- In less bloated case, 10 versions of call_cont(FF89)
  - Are these legitimately different? Probably so
- Try to design a pathological case? Add of add of add...?

[DONE] TODO: make inlining more selective
- Don't inline calls with relatively small execution frequency
- Favor inlining of more likely calls
- Log data first to get an idea of call site ratios when inlining
  - Scheme seems to very much make sense
  - Place threshold at 1/3?
  - const CALL_MIN_FRAC = 3
- 3d-cube (pre)
    total execution time (ms): 2551
    total compilation time (ms): 737
    machine code generated (bytes): 338787
- 3d-raytrace (pre)
    total execution time (ms): 3839
    total compilation time (ms): 1230
    machine code generated (bytes): 571490
- Small but significant improvement on all factors

[DONE] TODO: handling of parsing new without parens
- Should enable 2 shootout benchmarks

[DONE] FIXME: inline test is wrong
- not testing the type of the callee value
- not testing that it's a function object
- should make special callee check comparison?
  - problem is, need multiple comparisons
- if_eq_fun <clos> <IRFunPtr>

[DONE] FIXME:
Tom: try importing the stdio lib
Tom: interp/ops.d(626): ref ptr not in from space in load op

[DONE] TODO: add shootout benchmarks to tests
- set arguments[0] before running each one

[DONE] FIXME: unit function arguments handling
- arguments should refer to the global variable, not the arguments object

[DONE] FIXME: regular JIT call doesn't check that callee is a function
- enable jit_call_exc test
- try to pass test with --jit_noinline first

[DONE] TODO: make JIT regression test that catches exceptions, change callee
- call instr should throw an exception if the callee is not valid

[DONE] TODO: re-enable IR opts after inlining

[DONE] FIXME: inlining bug, we replace uses of the call by uses of a phi node in
call_ret. This is incorrect. Must take the value of the call from call_reg
into account.
- Add the ret phi node to call_cont directly, as before.
- Add a value to ret phi from call_reg as well (the new call site).
- Add new phi arguments at inlined rets to *all phis*
  - if arg was call site, replace by ret value
- Need to do replacement of call site uses manually before inlining?
  - skip phis in the call cont block?
  - could replace all, then go over call con't block and replace by new call instr?
- There may be existing preds to the call_cont
  - ret phi should have incoming values for these too

[DONE] TODO: basic const prop for mul_i32
$2 = mul_i32 1, $10
$0 = mul_i32 2, 6
- inlining makes opportunities appear

[DONE] TODO: write adversarial JIT test where inlined call gets changed, new call
returns something different

[DONE] FIXME: 
sunspider/crypto-md5
global property "error" is not defined
programs_sunspider_crypto_md5_js(23C306) ("programs/sunspider/crypto-md5.js"@1:1)
- no GC
- make regression test
- str concat seems to be broken
  - try making JIT strcat test? replicates the problem
- something in strcat is broken (by the JIT) after inlining?
  - first bytes written are zeros
- We compile theAdd, and then our loop fails to execute... i remains undefined
  - Maybe it was never initialized to zero? Set to undef on some path?
- Still have bug in inlineCall wrt phi nodes in call cont block

[DONE] FIXME: Inlining, a stub is produced for call_ret... Give call_ret the same
execCount as the call continuation
- function gets invalidated every time a call_ret is hit!

[DONE] FIXME: assembler.d(395): invalid instruction: imul r10d, 0;
- Inlining now working with interpreter only

[DONE] TODO: in debug mode, try encoding instructions immediately when added to assembler
- X86Instr.isValid()

[DONE] FIXME: inlining causes GC crash?
./higgs --e "test()" programs/gc/strcat.js
visiting frame for: $rt_str_alloc(11BA)
- top stack frame, we get to a value tagged INSPTR, seg fault
- ra slot is 32, but the insptr is found at 21
- many functions just inlined into rt_str_alloc
- instr.block is null...
  - must have been an old call site, now inlined

[DONE] FIXME: es5_comparisons, 4 >= 34 ==> false (expected true)
inlining $rt_refIsLayout(2B6A) into $rt_valIsString(2B7A)
inlining $rt_obj_get_header(12A2) into $rt_valIsString(2B7A)
- problem: replacing call uses by ret phi, but uses can be phi in call continuation!
- can't directly put the ret phi in the call continuation, needs its own block

[DONE] TODO: if no inlining happened, don't re-allocate stack slots

[DONE] FIXME: missing phi argument for:
$87 = phi [, call_reg(EBA3):0 => $295, call_cont(EB9F):0 => undefined]
in block:
if_join(E83B):

[DONE] FIXME: nsieve-bits segfaults
- Try logging executed instructions again
- Inlining itself fails for $rt_valIsString(2B7A) into $rt_setProp(2D02)

[DONE] FIXME: copying eliminates phi args

[DONE] FIXME: phi node is missing arg from one branch post inlining
- missing phi arg from call_reg

[DONE] TODO: rework inlinePass
- KISS, top of stack replacement only for when at call entry

[DONE] TODO: add interpreter cycle count, add to stats?
- move stats out of jit namespace?
- --stats option

[DONE] TODO: refactor inlining function

[DONE] TODO: implement heap_alloc in JIT?
- interp.allocPtr + size > interp.heapLimit
- if past heap limit, bailout
- increment interp.allocPtr
- align interp.allocPtr
  - align: +7 & -8
  - + (ptrSize - 1) & -ptrSize
  - drops the low 3 bits
- if the size is a multiple of ptr size, no need to align :)
- fasta unjitted instrs, 541366 vs 853500
  - but not much faster!

[DONE] TODO: better JIT ret handling for too few or too many args in call & ret
- Special handling branches should go out of line, return to main line
- ret bailouts
    3d-raytrace     3.3K    2.4K
    string-fasta    4.8K    0
    earley-boyer    271K    266K

[DONE] TODO: think about different inlining strategies
- Can create new IRFunction & replace in closures, but...
  - Still need to mutate an IRFunction during inlining
- Current scheme might still be best
- Can simplify for now by avoiding top of stack replacement, gets most gains

[DONE] FIXME: bug in earley-boyer
core.exception.AssertError@ir/ast.d(162): cannot add instr:
jump
current block already has final branch:
call_cont(1BC38):
  ret t_1BC37
in function "anon(1AECE)"
./higgs(void ir.ast.stmtToIR(ir.ast.IRGenCtx, parser.ast.ASTStmt)+0x1181) [0x575dfd]
./higgs(void ir.ast.switchToIR(ir.ast.IRGenCtx, parser.ast.SwitchStmt)+0x3a2) [0x5768be]

[DONE] TODO: jit.stats, total size of machine code generated

[DONE] FIXME: bug with 3d-raytrace introduced by stack slot opt
- only happens in context of make test
- crashes while during GC, while visiting stack roots
    forwarding object 3 (false)
- Probably, stack slot gets corrupted somewhere in the JIT
- A single phi node is producing this value ***
  - Uses values from a call and from another phi ($30)
  - $30 was already forwarded
$119 word: 3
$119 type: INT32
$30 word: 47386518933928
$30 type: REFPTR
Type comes from $30...
Value comes from $119
On path from $119 (call cont), phi is assigned to r11
REFPTR type is written to the stack
On path from $30, phi is also assigned to r11
When doing GC deep down the stack, need to have spilled r11
May not ever spill this phi node if it isn't live after the call ***
This is a peculiar situation... Type is on the stack but value is in a reg

[DONE] TODO: all instrs whose value is not used can share one stack slot

[DONE] TODO: get_arg for V8/raytrace
- 782K unjitted, 3.3s
- 620K unjitted, 3.2s
- still many many ret bailouts

[DONE] TODO: blog
- JIT complete, now with SSA
- Difficulties encountered, phi nodes, reg alloc bugs, call/ret bugs
- For now reg alloc simple
- Better code quality, speedups (table?)
- Higgs would ideally need fuzz testing

[DONE] TODO: StoreOp
- 3d-raytrace at 2.4s
- V8 raytrace now fast enough

[DONE] TODO: add call bailout and ret bailout JIT stat, try on string-fasta
- 3d-cube and 3d-raytrace have a few thousand ret bailouts
  - wasting time in the interpreter
- string-fasta has about 4K ret bailouts only
  - might still amount to a lot of time in the interpreter

[DONE] FIXME: some kind of phi node bug in $rt_getPropIdx
- once mod_i32 introduced, value gets de-incremented?
- spilling a register, but the value is mapped to the stack
  - mapping of reg to values got broken
- bug when phi node reg is in use by said phi node

[DONE] TODO: mod_i32 op
- 3d-raytrace unjitted ops down to 7.1M, string-fasta down to 17.9M

[DONE] TODO: gen_call, accept type imm

[DONE] TODO: how many unjitted instrs in string-fasta?
- about 28M
- does a lot of ret bailout, probably most of the problem

[DONE] FIXME: string-fasta segfaults at the end?
- No call or ret bailout
- global v is not the corrupted value...
- something gets written at the wrong position?
- what if our type tag gets written in the wrong place?
- bug in set_global implementation

[DONE] TODO: check ref ptr values stored in interp StoreOp

[DONE] TODO: void checkVal(Assembler as, X86Opnd wordOpnd, X86Opnd typeOpnd, string errorStr)
- use CMP to check value, jump to final label if OK, otherwise print errorStr
- use this in set_global to try and find when problems happen

[DONE] TODO: implement get_word, get_type
- 3d-raytrace now 8.0M unjitted

[DONE] TODO: implement set_value
- originally 9.25M unjitted instrs, 3.6s
- now 8.2M unjitted instrs

[DONE] TODO: logging of default JIT ops using ctx.as.printStr, test on 3d-raytrace, string-fasta
- lots of store(s)
- $2 = get_type missing
- $0 = set_value $20, $21
- $2 = get_word $29
- lots of mod_i32

[DONE] TODO: stat counter for number unjitted instructions executed
- 9.5M for raytrace, probably dominates execution time!

[DONE] TODO: dynamic type tests, incr counter only if jit_stats enabled

[DONE] TODO: exec time stat? record start time in static ctor
- Could we log stats in static dtor???

[DONE] TODO: can we compute comp time using microsecs to make more accurate?
- 3d-raytrace, 327ms out of 3675ms

[DONE] TODO: jit.stats, stats.compTimeMS
- What is the comp time for 3d-raytrace? 304ms out of 3800ms

[DONE] TODO: optimize non-constant comparison followed by if_true
- cmp can check that if instruction follows and is the only use
- if can check that cmp instruction precedes
- could possibly directly check the last ASM instruction?
- time benchmarks before if opt, best of 5
3d-cube             1.75    1.65
3d-raytrace         3.84    3.5
bitops-nsieve-bits  1.14    1.12
access-fannkuch     2.32    2.28

[DONE] TODO: improve cmp + if_true
- can generate bool and then cmp independently
- must modify ifTrueNext
- generate bool if we have more than one use or no if_true follows
- generate the if_true if one immediately follows

[DONE] FIXME: segfault after if opt.
- Problem is not with single use
- using for only IsTypeOp seems to work
- two versions of a null comparison, one fails?
- Problem is, for comparison, we can only do do cmp in the comparison operator...
  - Might need an implementation of if_true to which we can supply our own comparison operators...
  - if_true just calls implementation if bool arg doesn't immediately precede
- need void genCondBranch(trueOp, falseOp)

[DONE] FIXME: assembler fixed point goes into infinite loop...
- Computed jump offset can be wrong
- If jump instr becomes shorter, label offset is no longer accurate in current pass
- May recompute offset and get wrong answer because label position is no longer valid

[DONE] TODO: boolArgPrev
- Can avoid comparing against true val if cmp already done!
- most often true, but not always, sometimes because of phi

[DONE] TODO: implement ifUseNext(IRInstr) for IsTypeOp and CmpOp
- log occurrence: 80 to 90% true

[DONE] TODO: implement more opts in JIT, target defaults of slower benchmarks
- i32_to_f64? already commented out
- 3d-raytrace time?

------------------------------------------------------------------------------

[DONE] FIXME: error in v8/richards
- also issue with call bailout

[DONE] FIXME: segfault in v8/deltablue
- when fixed, enable in unit tests
- does this fix other segfaults?
- crashes somewhere in the plan execution
- modifying Plan.prototype.execute causes it to work properly
- get the IR string for this function?
  - just one phi node for the loop increment
  - mostly function calls
entering fn: Plan_prototype_execute(F529) (for_test(F642))
Segmentation fault
The call to c.execute crashes
Call bailout happens in this function just before the crash!
- Forgot to put loadVal=false in all getWordOpnd calls

[DONE] TODO: JIT currently checks if call instr has out slot, do we still have
situations where we don't allocate an out slot to call? test it

[DONE] TODO: cleanup call cont generation code
- add ctx.genCallCont function
- remove getEntryPoint from there

[DONE] FIXME: bug with sunspider/3d-cube, mov xmm0, 0;
- How do we load an immediate into XMM?

[DONE] TODO: re-benchmark and re-enable more sunspider/v8 tests

[DONE] TODO: getTypeOpnd in gen_ret should have acceptImm = true

[DONE] TODO: valToString should validate ref pointers
- core.memory.query, returns null if invalid pointer

[DONE] FIXME: bug in stackvm with ret enabled
- doesn't happen with interp ret only
  - much less JIT execution
- Does it crash when run on its own? Yes
- Does it crash if we disable GC? Yes, after a few runs (enough for JIT?)
- Try disabling specific ops, like load?
./higgs --nostdlib programs/regress/jit_ctor.js
- segfaults with object ctor call, adding property, returning new object
- many conditions need to occur
- Disabling load fixes the segfault...
  - Enabling just load_u32 makes it happen
    - 5 instances
  - pointers and offsets passed seem valid
  - doesn't seem like the load itself is causing the segfault
- Load code seems correct, try disabling other ops
- Bug in ret bailout code, state doesn't match entry state
  - need to set loadVal=false in getWordOpnd

[DONE] FIXME: jit ret causes infinite loop in stdlib, setPropObj
- Not caused by phi nodes
- Return value somehow not set?
  - interp and jit ret should be doing the same wrt return value
- Seems we get a loop with always the same next pointer returned
  - but the return code seems correct
- The situation we have occurs with a loop... The loop definitely has phi nodes
- Seems we really have an object with itself as next value
- Disabling ret makes it work
  - disabling jit ret doesn't fix it
  - disabling jit call cont generation doesn't fix it
- must be a phi node issue with the interpreter
- wspReg, tspReg not set in interpreter before interp.branch

[DONE] FIXME: jit entry point should be executing the phi moves...
- interp entry point doesn't execute moves, because the interpreter
  already executed them in the branch() function
- Could put a special pointer on the call instruction
- genBranchEdge to generate the phi nodes?
  - need to use stack entry state
- store association between label and call instr
- at the end of compFun, write the pointer
    ctx.genBranchEdge(
        ctx.ol,
        new Label("cont_branch"),
        instr.getTarget(0), 
        new CodeGenState(fun)
    );
- fixup gen_ret to use jitCont
- also make the branch edge exported
- add jitCont pointer on IRInstr

[DONE] FIXME: printStr is broken

[DONE] TODO: reimplement ret instruction in JIT
- need to fix jump(reg) to work branch desc
- move code into ret, it's the only usage

[DONE] FIXME: es5 comparisons, 2 !== 2 ==> false (expected undefined)
- undefined, wrong value extracted from array?
- try prop read loop in REPL?
- try disabling comparisons?
- make small regression test again
- test passes when JIT comparison ops disabled
  - fails if eq_i8 enabled

[DONE] FIXME: segfault once JIT call is enabled
make; ./higgs --nostdlib --jit_dumpinfo programs/sunspider/bitops-bitwise-and.js 
- segfaults if using interp call
- no segfault if interp call and no call continuation
- no segfault with JIT call and no call continuation
- still segfaults with stdlib enabled
  - after $rt_obj_get_cap compiled?
  - disabling JIT load ops seems to fix this
  - wrong reg used in load

[DONE] TODO: debug mode tests in load ops

[DONE] TODO: reimplement call instruction in JIT
- might cause load ops to be triggered, bugs to pop up, we shall see!

[DONE] FIXME: get_global, set_global, cannot allocate IR value for constant

[DONE] TODO: fixup load ops in JIT
- Also improve codegen wrt imm

[DONE] TODO: set_global, get_global

[DONE] TODO: asm peepholes, eliminate jump after jump

[DONE] TODO: re-enable JIT-specific unit tests

[DONE] TODO: reimplement basic arith

[DONE] TODO: reimplement eq instructions

[DONE] FIXME: CmpOp causes malfunction?
- Causes some values to be loaded from the stack...
- Neither $rt_se nor $rt_toBool have phi nodes, so this is probably not the issue
- Seems we get issues when using EDI as our output reg?
- Not obvious at all what's wrong
- Issue is with CmpOp not writing the upper 32 bits of memory words
- Fixed if_true implementation in interpreter

[DONE] TODO: copy es5_cmp, simplify until bug disappears, regress_cmp
- use --nostdlib to minimize interference
  - no JIT usage
- only one instance of eq_i32, in $rt_se

[DONE] TODO: check that phi nodes aren't getting the same register in succState

[DONE] TODO: reimplement if_true instruction

[DONE] FIXME: interp.d(538): ref ptr out of heap
- es5_cmp benchmark, many ifs
- no gc
- phi moves are involved
- Check if if_true code is correct...
  - all cases are exerted
- Log if cycles occur
  - no cycles
  - several mem-mem moves, type info
  - few moves, moves seem normal
- if args are all regs
  - two of the args are phis
  - are we loading them properly?
  - mapping all phis to stack doesn't fix the problem
./higgs --e "test()" --jit_dumpasm programs/es5_cmp/es5_cmp.js 
entering fn: $rt_valIsString(2B7A) (entry(32C2))
- disabling IsType ops seems to fix the problem
- test in more detail what in IsTypeOp causes an issue
- Bug in loading from mem to reg, not loading all the bits
- Also bug in getTypeOpnd

[DONE] TODO: reimplement jump instruction

[DONE] FIXME: mov r12l, [qword r14];
- 8-bit dst? wtf?
- getWordOpnd mem opnd wrong

[DONE] FIXME: getTransLabel, can't just insert instructions immediately!
- Might be called at various points inside an instruction
  - branch instructions only, at end of blocks
- Need to wait until end of current instruction
- can queue until end of current block
- What if we supplied a label to getTransLabel?
  - Call genBranchEdge at the end

[DONE] TODO: fix execMoves wrt tmp reg size
- add sanity checks, ie: no move into imm

[DONE] TODO: X86Reg.ofSize

[DONE] TODO: block transitions, state transition handling
- getTarget, need to generate code
- Need mechanism to handle block transitions w.r.t. phi nodes
  - "Execute" the phi assignment at the beginning of that block
  - Update state to reflect which phi nodes are in slots or regs
  - Insert moves as appropriate
  - May have cycles between phi node moves

[DONE] TODO: fix getWordOpnd
- used once in SpillRegs
- used by block trandition!
- need to be able to prevent load
- comment out current implementation and try reimplementing?
- getCurOpnd sub-function?

[DONE] TODO: fix getOutOpnd

[DONE] TODO: reimplement is_i32 instruction, IsTypeOp

[DONE] TODO: fix getOutOpnd

[DONE] FIXME: getEntryPoint, interp already executed phi nodes
- Doesn't make sense to generate new phi node mapping
  - phi nodes should remain on the stack as they were
- Could add a "noLoadPhi" arg. Simple enough

[DONE] TODO: fix getTypeOpnd

[DONE] FIXME: don't want to need interp pointer to evaluate constants
- could make static interp method, callable with interp or null

[DONE] TODO: re-enable jit call in interpreter
- get jit working with defaultFn only
- no branch handling for now, bailout to interpreter pre-branch

[DONE] TODO: fix defaultFn

[DONE] TODO: implement IRInstr.hasArg(IRValue)

[DONE] TODO: fix spillRegs calls

[DONE] TODO: fix spillRegs implementation
- if something is dead, delete it from the map, no more RA_DEAD

[DONE] TODO: replace liveSets by liveQueryFn

[DONE] FIXME: Object.keys({length : 1}).length == 0
keys there should give ["length"] but instead you get []
- Test in REPL
- Add object unit test

[DONE] TODO: make register mapping use values instead of local indices

[DONE] TODO: move list execution function
- uses one temp reg
- algorithm:
  - Identity moves are removed
  - If no moves don't overwrite an src, take pair (A->B) and remove from list,
    move A into tmp, add (tmp->B) to list
  - Pretty simple iterative algorithm!

[DONE] TODO: dumb register allocator
- need to test our ideas first, quality reg alloc is not on the critical path

[PASS] TODO: smarter slot/register mapping pass, jit/regalloc.d
- Only map registers for now, later map both slots and regs
- Ideally, slot/reg allocation assigns vals and phi nodes to same slot/reg
  - Provided they don't interfere
- Ideally, values that share a phi target end up in same register
- Should do phis first, values after?
- Should produce mapping of values to slots, allows remapping stack frames
  - Don't compute liveness just for interp, that's expensive
- Map instr to first slot that's not already mapped to an interfering value
  - Grow num slots as needed

[DONE] TODO: how often are phis live/interfering with their non-const arguments?
- compute stats in astToIR to get this info
- Liveness... Do we need more info?
  - Can manually test if used by a phi node if necessary
  - When checking if phi interferes with arg... Doesn't matter if val is live
    while phis are being assigned into if the val isn't live after
- Phis and args do sometimes interfere but most of the time not ***

[DONE] FIXME: live vars queries with instr from block that isn't in the function anymore?
- instr.block.fun is null (so block was removed from function?)
- we got this instr from a phi argument
- normally, incoming branch should have been removed
- PROBLEM: if instr had been removed, its block would be null...
- delBlock in peephole.d causes this to happen
  - only deleting dead blocks... removing incoming to other blocks
  - our instructions should have null block
- the instruction is still the valid last instr in the block!
- block was deleted, should have no instrs...

[DONE] TODO: jump to if_true of phi opt pattern
- Occurs in $rt_add
- pred can potentially be made to do if instead of jump
- succ must have just this one phi, which feeds into the if
- down from 6 to 2 phis in $rt_add!

[DONE] TODO: fixup liveness analysis to work with SSA
- better liveness data structure?
- could have dead/kill points for values?
  - if no uses, immediately dead
  - can die on branches

[DONE] TODO: read SSA liveness PDF
- Should really use bit sets for liveness if possible
- Could we produce live sets as query-able closures? ***
  - Internally store bit set(s), instr to id mapping
  - Probably not that inefficient
  - If each instr has a bit set, could allocate quadratic storage contiguously
    - Instrs/phis with no uses get no entry
    - Can log biggest table size for ease
- Paper says "variable by variable approach" performs best, read section 5

[DONE] TODO: fix loop bug w.r.t. loop vars and continue

[DONE] TODO: remove dead instrs peephole
- hasNoUses, !opcode.isImpure, !opcode.isBranch
- Actually very few dead instrs, probably a good thing

[DONE] TODO: $nullptr
- add unit test for typeof $nullptr, typeof $argc

[DONE] TODO: in ir/ast.d, flip ctx arg to be first in *toIR functions

[DONE] FIXME: null owner block for phi use
- phi node is not attached to a block
- have phi node use that was deleted, but not properly unregistered
- PROBABLE: we make a block dead, and it has arguments to some phi
  - branch is removed, but phi args never removed
  - remIncoming should unregister all associated phi args

[DONE] TODO: jump to jump peephole opt
- block with only branch instr, no phi nodes

[DONE] FIXME: jump to jump peephole doesn't seem to work when done with call
and phi args are allowed...
- ret instr in interpreter seems capable of handling phi args...
- Need to set ret val before executing phis!

[DONE] TODO: int32 add const prop peephole opt

[DONE] TODO: fixup FFI
- extract args into buffer

[DONE] TODO: basic IR peephole pass
- look at irString for primitives, add, getProp, etc before and after
- opts:
  - phi node opts
  - dead blocks
- See if interp performance changes much
bitwise-and     7.24    6.8-7.1
nsieve-bits     77.6    69

[DONE] FIXME: GC bug after phi replacement, gc/closures
- ops.d(613): pointer is not pointer type in load op
- new_clos triggers the collection
  - clos allocation itself triggers collection
- crashes in $rt_cell_get_word, inside of closure code
- cell pointer set to wrong value? or maybe in wrong closure?
  - very unlikely
  - we are calling the right closure object
- cell pointer we got from closure (clos ptr arg to call) is wrong?
- final get seems to be what fails...
  - adding prints in test function or getCellVal seems to make this issue go away
- As soon as the GC executes, tsp[3] becomes corrupted. How is this possible?
- GC corrupts type stack when zeroing it out using wrong pointer type!

[DONE] FIXME: phi moves don't swap properly... would have to all be simultaneous
- could load all arg values into a temp vector, then copy temp vector?
- preallocate temp vector for phi, calls in interp, not that inefficient!
- eliminate alloca

[DONE] FIXME: phi uses deleted phi
- removing "first use", but firstUse is null... val already deleted?
  - could we be marked as a use of ourself? should not be an issue?
- Can't just destroy phi nodes or instrs when removing block
  - May have other (dead, uncollected) uses still referencing them

[DONE] FIXME: removing phi nodes always results in a seg fault? why?
- printing some instr fails while printing args...

[DONE] TODO: get jit.d compiling with JIT disabled

How should the SSA JIT work?
- Moves may need to be generated for some phi nodes, when jumping to a block
  - getTarget may need to take pred into account, generate stub of moves
- Current state: whether each value is in its register or slot
- Will need a way to request an argument as a register
  - If it's a constant, we need to supply a temp
- If I have some phi incoming in a slot, and I branch to a block, I'll be
  redefining this phi node, hence the state I branch to should have that phi
  also in a slot, if they're the same ***
- Maybe the JIT shouldn't make phi nodes have fixed slots?
  - This only matters if phi incomings and phi nodes often interfere ***
    - Must compute this stat to inform our decision

------------------------------------------------------------------------------

July 15th goal: complete AST->IR and interpreter refactoring

[DONE] TODO: rebase main branch onto SSA

[DONE] TODO: fixup GC
- Try enabling GC tests in steps

[DONE] TODO: grep for FIXME

[DONE] TODO: exceptions, try-catch-finally
- Finally execution
- Try/catch/finally, context merging
- Throw, throw ctx lst? See Tachyon
- genExcPath needs to be altered

[DONE] FIXME: trying to add instr after call to rt_add
- Seems to be caused by englobing try block... genExcPath?

[DONE] TODO: for-in loop
- crash, first call to enumerator fails

[DONE] TODO: arguments object

[DONE] TODO: call_apply

[DONE] FIXME: "programs/basic_assign/basic_assign.js" produces 20

[DONE] TODO: new operator

[DONE] TODO: switch statement
- Needed to load stdlib
- Look at Tachyon code

[DONE] TODO: array literal support

[DONE] TODO: object literal support
- Should enable many more tests

[DONE] TODO: delete operator
- Signal 11 on delete of global

[DONE] FIXME: $rt_toString(5), ir.d(932): phi node is not attached to a block
- Replacing value by unattached phi node????
- Problem: replacing uses of phi but, phi may be in context already
- Shouldn't be doing this during code gen... Need separate opt phase

[DONE] TODO: typeof operator
- Has its own unittest section

[DONE] TODO: for loop

[DONE] TODO: do-while loop

[DONE] TODO: compare Tachyon and Higgs WhileStmt versions
- Possible improvements for clarity/simplicity? Refactor now
- createLoopEntry? look at Tachyon usages, do we always register labels?

[DONE] TODO: get simple while loop with phi nodes working
- can now test this with --nostdlib --e "..."

[DONE] FIXME: break/cont target should have both ctxList and IRBlock
- enable some loop tests

[DONE] TODO: operator ++

[DONE] FIXME: signal 11 at ret in basic tests
  call_cont(26473):
    $0 = or_i32 $5, $8
    ret $0
- phi node assigns into RA!

[DONE] TODO: --nostdlib option?

[DONE] TODO: log branch target idx in phi toString

[DONE] TODO: if you do remPhi, should remove args for that phi node
- BranchDesc.remPhiArg(PhiNode phi)

[PASS] FIXME: phi nodes with 0 or 1 input
- seems valid for now...

[DONE] TODO: test if 1 + 1 (runtime, arith ovf) is working
- Missing if statement support

[DONE] FIXME: visible argument slots wrongly assigned?

[DONE] FIXME: phi node toString doesn't show any incoming values
- desc.args.length: 0

[DONE] FIXME: newlines in IR listing

[DONE] TODO: ternary expression

[DONE] FIXME: r/ast.d(1854): variable declaration not in local map: "x"
- x is a parameter to $rt_add
- local map length: 0

[DONE] TODO: && operator

[DONE] TODO: if statement

[DONE] TODO: jump with branch descriptor, handle phi nodes
- interp.getValue(IRValue val)
- interp.branch(BranchDesc branch)

[DONE] TODO: set_str

[DONE] TODO: set_undef... Do we want to implement a $undef and $missing?
- Like $argc

[DONE] TODO: new_clos, needed by runtime lib

[DONE] TODO: get set_global, get_global working
- Needed for even basic runtime
- x = 1; return x;

[DONE] TODO: get basic "1", "ir_add_i32" working in interpreter

[DONE] TODO: getArgVal

[DONE] TODO: add loadRuntime option to interpreter

[DONE] TODO: make callFun interp method

[DONE] FIXME: temps are not per-block

[DONE] TODO: implement simple stack slot assignment pass
- should be called at end of astToIR
- ir/slotalloc.d, allocSlots(IRFunction)
- instrs with single uses *in the same block* interfere with other from block
  - these are "bounded" temps (same block bound)
  - each get a slot from tempSlots
- instrs in the other category interfere with everything
  - each get their own slot from varSlots
- for now phi nodes get own slots too, from varSlots

[DONE] TODO: rename "dsts" to uses, less confusion

[DONE] FIXME: do you consider branch desc args as uses? ***

[DONE] TODO: comment out currently broken tests, get make test working

[DONE] TODO: get IR gen for function calls working

[DONE] TODO: get IR gen for function decls working

[DONE] FIXME: get x = 1 working

[DONE] FIXME: get while (1) to work
- genRtCall is incomplete

[DONE] TODO: get while(true) to work

[DONE] FIXME: merge ctx should check if branch exists
- If branch present, find matching target

[DONE] TODO: context.merge(subCtx)... proper local map handling?

[DONE] TODO: IRGenCtx.dup? Bring back subCtx! less copying overhead

[DONE] TODO: IRGenCtx.ifTrue

[DONE] TODO: adapt context for loops, break ctx list, cont ctx list
- No longer want exit and continue blocks, but lists instead

[DONE] TODO: convert genBoolEval
- KISS for now, improve with SSA way later?

[DONE] TODO: mergeContexts
- In Tachyon, with the output of mergeContexts
  - Set it as the "output" (continue generating code there), like .merge
  - Continue generating code from a new context with that block
- Creating a new context seems like the safer, cleaner option (and probably just as fast)
  - Much cleaner abstraction

[DONE] TODO: mergeLoopEntry?

[DONE] TODO: method to set/add branch desc argument?

[DONE] TODO: createLoopEntry
- creates phi nodes for each variable going through the loop
- start by making basic while loop work!

[DONE] TODO: test simple functions/expressions
- print text output
- modify main to do this? return early

[DONE] TODO: fixup IRFunction.toString

[DONE] TODO: begin porting stmtToIR, exprToIR
- constant exprs
- arith add
- statement expr, return expr

[DONE] TODO: modify/port (most of) astToIR function to get familiar

[DONE] TODO: port genRtCall
- needed for astToIR function

[DONE] TODO: mutable int32 IR value? IntVal?

[DONE] TODO: modify IRGenCtx
- outValue
- localMap

Context merge idea: we must make the contexts jump/branch to the right block
(we do this already). Must also create phi nodes and add incoming values as
appropriate.

It seems like we probably could have a simpler mergeContext that works on
an individual context basis... 
- mergeLoopEntry uses a map of entryLocals and an entryBlock
- createLoopEntry creates a phi node for each variable going through the loop
  - no choice without prior knowledge

Tachyon IRConvContext has:
labels,
localMap,   // Mutable map of local variable states
sharedMap,  // Map of shared variable locations
breakMap, 
contMap,
throwList,  // Throw context list
funcObj,
thisVal,    // This argument value
outValue    // Output value of the evaluated AST node

IRConvContext.prototype.setOutput = function (exitBlock, outValue)
- Note: exitBlock is no longer necessary

// Create a context for the loop entry (the loop body)
var entryLocals = new HashMap();
var brkCtxList = [];
var cntCtxList = [];
var bodyContext = createLoopEntry(
    astStmt,
    astStmt.statement,
    context,
    entryLocals,
    brkCtxList,
    cntCtxList,
    'loop_body'
);

// Merge the break contexts
var loopExit = mergeContexts(
    brkCtxList,
    context.localMap,
    context.cfg,
    'loop_exit'
);

// Merge the continue contexts with the loop entry
mergeLoopEntry(
    cntCtxList,
    entryLocals,
    context.localMap,
    testContext.entryBlock
);

// Merge the local maps using phi nodes
var joinBlock = mergeContexts(
    [trueContext, falseContext],
    context.localMap,
    context.cfg,
    'iir_join'
);

[DONE] TODO: string constant IRValue

[DONE] TODO: get code into compiling state
- Comment out code until things compile?
  - Comment out most of ir/ast.d
- getArgSlot?
  - for interp, assert use has an out slot

[DONE] TODO: remove useless instructions
- set ..., move

[DONE] TODO: remove original IR classes, replace by new ones

[DONE] TODO: implement SSA IR
- Constant pool for int32s, float64s, true/false/null/undef/missing
- Remove instrs that are now constants

[DONE] TODO: fix dependency cycle ir.ir -> interp.ops -> ir.ast -> ir.iir -> ir.ir

[DONE] TODO: disable various IR analyses

[DONE] TODO: disable JIT for now, comment out aside in makefile

------------------------------------------------------------------------------

[DONE] TODO: think about register kill in ASM, would be very useful
- Combined kill with bit mask of GP registers to kill
- KillRegs annotation
- Only insert if !jit_noasmopts
- slows the code gen a bit...
  - another argument for SSA
- this idea actually sucks

[DONE] TODO: basic peephole opts

[DONE] TODO: jit_noasmopts flag

[DONE] TODO: try to use one less scratch reg, commit before
- Benchmark first, note times ***
  3d-cube               2.45    2.50
  3d-raytrace           4.34    4.43
  bitops-nsieve-bits    1.32    1.33
- Grep for scrRegs64[3]
- Result: no noticeable difference!

[DONE] TODO: lsft_i32, rsft_i32

[DONE] TODO: test simple artificial benchmark for study
- for_loop.js, just a for loop that increments a counter
- issue: quite likely, w.r.t. const prop, global values aren't optimized
  - global version is a little slower
- stare at ASM, make it better
- Observations
  - lt, add successfully inlined in main loop
  - tons of stubs are produced, should probably optimize stub compilation
  - with lots of iterations, it's almost twice as fast with inlining
- when we do get_global, we copy the type to the stack, but we keep the
  value in a register. We then write 0 to the stack to prevent a type out
  of sync problem...
- jumps to next label are quite common
- int offset in load instr could be optimized

[DONE] FIXME: useless move in simple for loop, closure version
- Flaw in init analysis w.r.t. dead code and argument initialization

[DONE] FIXME: bug in 3d-raytrace, has to do with set_true, set_false
- Fn args could be constant, but call/ret wouldn't know?
  - Test if this is the case

[DONE] TODO: getWordOpnd: provide a tmpReg parameter

[DONE] TODO: rename getArgOpnd to getWordOpnd

[DONE] TODO: getTypeOpnd, do we ever get a type that's not an instr argument? grep it

[DONE] TODO: eliminate getReg

[DONE] TODO: restructure/simplify call, spill everything *after* arg copying

[DONE] TODO: SET_TRUE should store its constant

[DONE] TODO: optimize IsTypeOp

[DONE] TODO: add flags for known boolean values, defer value write?
- Allows optimizing both IsTypeOp and if_true
- If opnd is requested, move value to opnd
- If spilling, write value
- Probably need a special TF_CONST

[DONE] TODO: basic OSR if function is on top of the stack
- Easy at this point? Just move the values to the new slots
- Fn on stack must be interp function if we're in compFun
- Large majority of stuff isn't deep on the stack when compiled
  bitops-nsieve-bits shows $rt_arr_ofs_len as "deep"... How???
  - Could an old RA be left over on the stack, not used?
  - Try implementing proper stack traversal
- Disable temporary compFun in callFun

[DONE] TODO: remove localMap thang from inlineCall, not needed

[DONE] TODO: re-implement FP ops in JIT

[DONE] FIXME: v8bench/splay borks the JIT
- operand is null, nonsense!

[DONE] TODO: GC unit test
- Alloc small object, add more properties, trigger GC,
  try accessing latter properties

[DONE] FIXME: GC bug with next chain
- Segfault in gc/graph after collection is done
- GC is artificially triggered by shrinkHeap, not during allocation
- Crashes somewhere while setting up initial graph
- Seem to be crashing on array push
- Crashing when trying to get a closure cell property (array_toObject)
  - $rt_getCellVal
- Quite possibly our closure got a next pointer before the cells were set!

[DONE] TODO: interpreter stack traversal function with delegates?
- use for GC, funOnStack
- delegate with: IRFunction fun, wsp, tsp, size_t depth

[DONE] TODO: blog, Implementing Inlining
- Inlining in Higgs
  - OSR aspect
  - nontrivial, stressing the JIT, bug fixing
  - frame compaction, optimization
  - most tests show slight perf loss, some slightly faster
- Plans: more libs, graphics/audio wrappers, testing system
  - Competing with Python?
- DConf 2013 talk in a week or so
  - Will be announced and linked on this blog and on my twitter feed

[DONE] TODO: investigate why most functions get no inlining, including $rt_add, $rt_lt
- Lack of inlining partially explains lack of speed
- bitwise-and is a loop, won't inline anything without basic OSR
- rt_add, rt_lt themselves don't really need inlining for the common case
- must have basic OSR to see change in functions with loops
- 3d-cube is actually faster

[DONE] TODO: re-implement add_i32_ovf in JIT

[DONE] TODO: re-implement set_f64

[DONE] TODO: for inlining, be a little smarter
- Check if arg count never read, if so don't write it
- Check if arg slots never written, if so use arg vals directly

[DONE] TODO: jit_noinline flag
- remove plain jit_noopts, not specific enough
- 3d-raytrace still 0.6s faster without inlining, 3.5 vs 4.3

[DONE] TODO: IR flag for non-pure values, things we can't safely remove
- STORE_..., SET_LINK, SET_GLOBAL, EVAL_STR, PRINT_STR, CLOSE_LIB, GC_COLLECT
- OpInfo.IMPURE

[DONE] TODO: optimize instructions needed for inlining
- set_rawptr, eq_rawptr, set_i32, load_rawptr
- produces some speedup, but still not as fast as uninlined
- moves may be quite inefficient

[DONE] TODO: test performance on raytrace, bitwise-and? try increasing fn size limit
- Raytrace is twice as slow, 4.4s vs 10s

[DONE] TODO: test inlining with functions not currently on stack (pre-OSR)
- funOnStack
- ISSUE: all functions are on the stack when compiled!
- For now, temporarily call compFun in function call bit?

[DONE] FIXME: rt_sub used for negative numbers in JS layout computation!
- Look at irString, $rt_clos_ofs_cell
- Fix in parser

[DONE] FIXME: inlined rt_sub is compiled all wrong???
- Move instruction doesn't copy type tag properly?
- Disabling gen_move fixes problem
- Immediately after move, is_int32 fails
- IsTypeOp doesn't account for known type tags

[DONE] FIXME: segmentation fault on Higgs init
- JIT is probably calling valIsString with the wrong stack frame size
- Optimized call based on pre-inlining size

[DONE] TODO: JIT string printing mechanism

[DONE] TODO: test inlining with the JIT off first?
- Tests pass without JIT and without inlining
  inlining $rt_setCellVal(22E120) into clos(2380CD)
- invalid move dst in clos() function
    $4 = set_undef
    move $4
    jump => call_cont(23812C)
- Call with no return value unhandled

[DONE] FIXME: segfault when executing fun w/ inlining
inlining $rt_obj_ofs_type(11AC) into $rt_obj_set_type(11D6)
- Arguments not copied right, inverted order

[DONE] FIXME: segfault during JIT compilation

[DONE] FIXME: pointer is not pointer type in load op, failing to load from clos ptr

[DONE] TODO: implement size limit in inlining test

[DONE] TODO: funOnStack
- Just scan the stack for RAs, very simple

[DONE] TODO: go over inlining implementation, inspect code

[DONE] TODO: implement inlining
- Maintain original call cont blocks
- Keep track of who's inlined at each call site, for exception stack unwinding
  - Map of call instrs to lists of functions
- Produce mapping of pre-inlining stack slots to inlined slots, for OSR
  - Map of stack indices to stack indices

[DONE] TODO: change function layout so function pointer has fixed offset
- Get offset of word slot 0?
- on alloc class, add numRsvProps parameter

[DONE] TODO: fix closure ctor_class issue

[DONE] TODO: IR, i64 tag, support

[DONE] TODO: IR instr renaming for convenience
- is_i32, is_f64, ...
- set_i32, set_f64, set_str, ...

[DONE] FIXME: crypto-aes, run-time error: undefined base in property read
- array w in KeyExpansion should have been initialized with array, is not
- Likely, failing because loop index is not integer

[DONE] FIXME: crypto-aes, invalid operand 2 type in op "auto r = x * y;" (int32)
- Investigate, create failing unit test
- Problem with new Array, size resulting from division is a float

[DONE] TODO: blog
- DConf, impressions
- method JIT, versioning
- talk slides
- forum.dlang.org/group/digitalmars.D

[DONE] TODO: fix loop label segfault

Publishing: figure out their litmus test. For some, numbers, for some it's
proofs, make sure you have that
- You're selling something, try to have a grand narrative
- Why it's hard, why it's interesting, why is it novel
- Papers you *should cite*, how does it compare
- Try to cite the reviewer...?
- Cohesion, line of thought, don't want sections to look like afterthought

Michael: try to do these optimizations by hand on some benchmarks, where will it pay off?
- I wasted a lot of time trying to do clever things I thought would matter

Michael: constant folding, copy propagation, try to predict benefit? *****

Michael: either work backwards or you backtrack
- Or do it greedily backwards?

Shu: flow problem. Want to optimize CFG to reduce joining work.
- Attach weight to individual nodes based on amount of work
- How much work did we save?
- Model performance characteristics

Problem: add operator, overflow case... Don't want this automatically compiled
- Whole other loop path for doubles?

Michael: don't want duplication to propagate all the way through
- Merge as early as possible
- Metric of benefit vs cost of duplicating a block
- If merging from two different types, we get boxing overhead

Max: Incremental duplication may be necessary... Prevents impossible/useless
duplications to some extent. Otherwise duplication can propagate to successors.
- Similar problem to trace trees

Michael: if you duplicate a block, what is the probability you'll have to
duplicate its successors

Michael: tail duplication has been around for a long time, lots of literature

Michael: would be interesting to try and predict if tail duplication will help
at a specific point

Michael: come up with a metric
- Now way of knowing tail duplication will pay off in the future
- Has a cost, could afford it if it pays off

Shu: split (terminology?)

Michael: profile in an interpreter
- Backwards flow analysis, I need this type info?
- I would like this not to be polymorphic
- Would like this to be an int

Shu: tail duplicate until things become monomorphic
- Drives the duplication

Michael: compile without duplication, monitor hot spots

Shu: don't version at some blocks?
- Re-merge if useless?

[DONE] TODO: start sketching out ir/inlining.d
- inlineCall?
- add comments to flesh out process

[DONE] TODO: allocate stacks with malloc, NO_SCAN

[DONE] TODO: use GC.BlkAttr.NO_SCAN when allocating heap, link table

[DONE] FIXME: return with no semicolon causes parse error
- Create failing parser test

Problem: unwinding stack frames on throw or before calls...
- Must setup stack frame as multiple frames before each exiting call?
  - Correct stack height
  - Write return addresses
  - Spill values/types in the proper slots
- Could save on cost of having to spill types too?
- Need to inflate if exiting to interpreter
  - call to interp
  - unsupported behavior
  - unsupported instruction
- Exceptions need to be able to make the caller inflate
  - Probably want a special extern(C) function to inflate/spill stack frames?
  - Map of call instrs to inflate function
- We can still have interpreter entry points in the middle of functions as before!
  - But these will go to non-inlined versions of functions
  - Don't place entry points in the inlined functions, only at top level
  - Not a huge deal
- Functions with inlining can have an internal stack frame size different from numLocals
  - If we optimize an inlined function and remove temps/vars, need to somehow know
    what temps map to which original function temps
    - could use special pseudo-instr to manage this
    - plase pseudo-instr before possible bailout points, function calls

[DONE] TODO: think about dynamic block/version compilation further
- What would the infrastructure look like?
  - Compile to an assembler, write to a code block
  - ol assembler used for interp entry points, interp fallback
- No longer need a queue of things to compile!
  - Blocks, entry points compiled immediately, until branch occurs
- Need an out of line code block
- Contexts need to account for inlining

Dynamic block compilation...
- Could dynamically profile branches/calls on stubs, eventually compile
- Need to manage a code block and append to it
  - Could simply preallocate to start
- Need to keep track of what jumps to what? Only if we need to displace?
- Incremental compilation of functions
- If compiling and branch occurs, create interp fallback stub, install profiling counters
  - First stub to trigger compilation gets concatenated?
  - Could have already compiled multiple loop iterations?
    - No, because you stopped at the branch!
- Inlining, could do it in the backend?
  - Yes, but we need some sort of lazy move, special alloc state
  - Might be able to recompile calls after some counter hits a threshold
- Issues:
  - Suboptimal code, reoptimization more difficult, but not impossible
  - Jumps to movable code, need to place and rewrite jump

Dynamic compilation cons:
- complicates the backend (N level contexts when inlining?)
- possibly reduces optimization opportunities
- hard to reoptimize code
- need to keep around lists of block versions for future compilations
- can't compute total frame size for inlining ahead of time...
  - would need to reserve space ahead of time

Dynamic compilation pros:
- may save compilation time
- get better profiling data
- avoids invalidating on stub hit
- can try going along with an inlining and back out of it?

[DONE] Inlining heuristics:
- max allowable numLocals of the callee
- max allowable number of blocks in the callee
- total caller + callee size
- total caller + callee locals
- IBM paper considers inlining based on profiles at the callee
  - How many callers, how frequently
  - Generates inlining requests for next compilation
  - Works based on call edge density/distribution, relative method hotness

[DONE] TODO: read empirical inlining paper, note insights

[DONE] TODO: look at IR for getPropIdx... Can we benefit from type info at all?
- Has a ton of calls to various methods
- some eq_const, eq_refptr
- Benefit would probably be fairly small, but inlining will help a lot

[DONE] TODO: functions, remove closure caching, slow offset comp path

[DONE] TODO: BOOL_OUT flag on instructions

[DONE] FIXME: v8/splay segfault with JIT
- Does lots of GC, could be related
- Is this fast enough to include in unit tests? Can we make it faster?
- Note: the GC happens increasingly fast! heap space is exhausted

[DONE] TODO: don't init temps to undef, only local variables
- numTemps, numVars?

[DONE] FIXME: i++ does get_global "i" twice???
function () { return i++; }
- confirmed, first value not used
- Problem is we want the value pre-incrementation

[DONE] FIXME: bug with 3d-raytrace
run-time error: undefined base in read of property "intersect"
Scene_prototype_blocked ("programs/sunspider/3d-raytrace.js"@244:27)
- all unit tests pass, make new regress_raytrace test
- iteration index i becomes null
- i is a global variable! some kind of type corruption happening
- problem is with set_global not using type info properly

[DONE] FIXME: type spilling
- Should only write a type when spilling a value AND the type is not in sync
- What if we're writing a dynamic type, e.g.: move
  - Should write 0 value on the word stack
- BUT, what if we have a memory operand?
  - Might still know the type, not write it to the stack...
  - If we're writing a different type and not in sync, write it to the stack?
- Problem: copying types during ret and call is cumbersome
  - getTypeOpnd, pass scratch reg if mem reading is needed?
  - Need to add stack offset param (in case we pushed more stack space!)
  - default is int32_t.max

[DONE] TODO: try to optimize global prop access, remove offset recomputation

[DONE] TODO: make setOutType change type state
- Should result in more versions, but still working code

[DONE] TODO: simple `make install` target

[DONE] TODO: add typeState to CodeGenState

[DONE] TODO: write adversarial GC/JIT test
- Big loop
- Mix many obj refs & integer calculations?
- Branching

[DONE] TODO: improve register spilling, defaultFn, better usage of liveness info

[DONE] TODO: add a V8 benchmark to make test, more sunspider tests?

[DONE] TODO: re-implement return in JIT

[DONE] TODO: usesThis, usesClos, can optimize function calls further

[DONE] TODO: type flags, type state definitions
- Known type bit
  - If not known, it's stored on the stack
- In sync with stack bit
  - if we test a type, the type we now know is what's on the stack
  - if we spill a type tag, stack becomes in sync
  - if we set a type, and it's the same as before, flag unchanged
- 5 bits for type tag itself, if known

[DONE] FIXME: function calls
- Selectively spill non-args in regs before the call
- Everything that's live after the call must be spilled
- Keep non-live flag for spilling?

[DONE] TODO: try eliminating init maps
- Don't store on function, don't use in GC
- Can init less slots if we only worry about uninitialized variables
- Refactor GC to init/reset stack to 0
- Temporarily: when setting a type, write 0 value
  - Writing 0 in get_global prevents GC crash

[DONE] TODO: check if 0 when setting type fixes the GC bug w.r.t. calls/spills
- Crashes during GC

[DONE] TODO: jit/ops.d

[DONE] TODO: default state, only args should be on stack

[DONE] FIXME: jit.d(485): argument is neither in a register nor on the stack
- Problem is with rt_typeof, used in jit/loop_new
- Log the function we're actually compiling
  $1 = set_null
  $3 = eq_refptr $10, $1
  if_true $3 => if_true(A368), if_false(A36B)
$3 is in fact live after eq_refptr
- eq_refptr uses the interp fallback
  - will not map its value as being on the stack!
  - could change interp fallback to fix this?

[DONE] TODO: bitwise-and, must still be missing instrs for lt
- using default for: $7 = lt_i32 $15, $16 ($rt_lt(27EA))

[DONE] TODO: fix set_global
- Bug with type tags? Should get true, get integer 1, integer type tag

[DONE] TODO: implement/fix get_global

[DONE] TODO: pushRegs, popRegs

[DONE] TODO: revise gen_call
- Will test the limits of the reg alloc

[DONE] TODO: implement reg alloc for simple instructions
- add, mul, and
- get_global_obj
- load

[DONE] FIXME: load with refptr gets bus error
- Unaligned memory access or wrong address???
- Could we be, by using int32 offsets, having invalid hi reg values?
  - If so, problematic!
  - There's your problem...

[DONE] FIXME: ; if_true $4 => if_true(32D6), if_false(32E2)
- Jumping to block with wrong reg alloc

[DONE] TODO: exit to interpreter, should spill regs appropriately

[DONE] TODO: revise defaultFn, might need to save allocatable regs

[DONE] TODO: spill logic

[DONE] TODO: make getArgOpnd have a loadVal argument, load to reg
- Assert not bumping output val

[DONE] TODO: make getOutOpnd try to load to reg if not bumping input

[DONE] TODO: make versioning system work without actual versions or reg alloc
- Always the same state, one version

[DONE] TODO: think about block version **state** objects
- State evolves as we go through blocks
- Should be a struct so we can assign it simply
- Need list of block versions, labels with associated states
- For now, ignore type tags, keep them on the stack ***
  - Focus on reg alloc only
- Need a map of blocks to state/label pairs
  - getBlockLabel(block, state)
  - Try to find a match, if none, produce one

[DONE] TODO: integrate level 0 FFI functionality

[DONE] TODO: interference analysis, coloring
- Go over basic blocks, count number of instrs where values interfere
  - Add counts to edges
- Color slots with registers so as to minimize conflicts
  - Use greedy coloring algorithm
  - If register must be used, pick one from neighbor with least contention
- Also color with XMM registers for FP values and spills

[DONE] TODO: JIT-to-JIT call
- fast jit entry points on blocks

[DONE] TODO: liveness analysis for stack slots
- Returns map of instrs to sets of live slots after the instr
- Need to know if we can kill a value after an instr

[DONE] IDEAS: Basic block versioning
- Can version based on spill status, type, known constant value
- Instr flow functions give us type info
- Type checks give us extra type info
- Checking if something is a given constant gives us info
  - e.g.: check type of receiver before inlined call
- Can avoid generating paths that haven't occurred in practice
  - Jumping to non-existing path needs to bailout to interpreter, invalidate function
- Blocks with 0 exec count are stubs
- If IRFunction is transformed for inlining, non-inline paths will have 0 exec count to begin with
- If known constant value, can try generating new version
  - If too many versions already, try to match existing versions more coarsely

[DONE] IDEAS: Versioning JIT
- Generalize versioning to per-version pre-conditions
  - Generic/catch-all version has no conditions required
  - Type requirements of various granularities can be encoded as conditions
- Count interpreter cycles per call to grant versioning/optimization/inlining budget
  - Functions that take long to execute should get more!
- Monitor call args to decide how to version
  - Can specialize all the way down to constants
- Can transform loops into tail calls
  - Optimize the tail

[DONE] TODO: implement callee-guessing
- Map of call instrs to lists of callee fptrs with frequencies
  - Store on the caller function
- Test fptr and not closure ptr

[DONE] TODO: mid-loop entry
- Create entry points for loop headers
- Bitwise and can't be optimized without this

[DONE] TODO: basic block stubbing
- Code should be out of line
- Invalidates code block and all entry points for function
  - Implement through C function
- Run unit tests

[DONE] TODO: implement some of the ops in rt_and
- is_int32, and_i32

[DONE] TODO: make basic method JIT work, use only scratch regs for now, no reg alloc
- Implement jump, if_true
- Implement initial call/ret by bailing out to interp
  - Generate export for continuation target
- Test on bitwise-and to start
- Try unit tests and commit method JIT v0

[DONE] TODO: JIT compilation & entry hooks in interpreter
- If block reaches target exec count, compile its function
- Will automatically work for loops too

[DONE] TODO: secondary entry points for fn returns
- Function to generate the code for an entry point
- Create an exported label? Need to wait until code is assembled to set
- Map of blocks to exported labels
- This code should be out of line ***
- getEntryPoint
- Eliminate initial entry point, just get the entry point for the entry block!

[DONE] ISSUE: you don't know if the caller was running JITted code?
- If calling interpreter function, have to bail out to interpreter first, so that's OK
- If doing JIT-to-JIT call, and then we bail out to the interpreter...
  - KISS: when you do any call, spill the locals

[DONE] TODO: begin compiling basic blocks?
- getBlockLabel?
- stack overflow warning

[DONE] TODO: store CodeBlock pointer on compiled function

[DONE] TODO: solve first problem: how do we enter, how do we bailout
- To enter, call entryFn on some basic block
  - Saves regs, does required prep
- To bailout, pop regs, save wsp, tsp, do return to interpreter
- For now, can have generic bailout label in code gen context

[DONE] TODO: plan register mapping with fixed regs, scratch regs, allocatable regs

[DONE] TODO: read SELF customization article

[DONE] TODO: research procedure cloning, dynamic languages
- Find MATLAB versioning article
  - MaJIC, precompiles version

[DONE] TODO: can we generalize versioning, dispatch based on arbitrary conditions?
- types of class properties involved in parameters (specific type sets)?
  - Is this effective? Avoids invalidation
  - Might have lots of type sets involved?
  - Can disable entry to function with boolean flags, basically
- How granular? can dispatch all the way down to constant values
  - Profiling argument types would make sense here
  - If almost always constant, take advantage
- Heuristic: functions with longer execution time (in interpreter instrs)
  should get more versioning budget/granularity
  - Re-add interpreter cycle counter?
- Should generalize string down to pre-conditions **********
  - Generic/catch-all version has no conditions required ******
  - Type requirements of various granularities can be encoded as conditions
- Start by implementing generic method-based compiler

[DONE] TODO: think about method-based compilation
- Interp fallback
  - Dump stack slots to interp stack
- Mid-loop interp jump
  - Special entry point that jumps into loop (outer loop only?)
  - Can have special prelude code
- Fallback w/ inlining
  - Need to keep track of frames pushed, locals for each frame
  - When inlining, add special call/ret annotation instructions
    - Keeps track of frames pushed, slots added
- Join w/ inlining
  - Join at loop header, not in the middle of inlined calls
- Speculative inlining
  - Can use interp fallback if incorrect guess, or have 2 paths
  - Default path does generic call
- Can prealloc space for inlined frames on call to compiled function
  - When doing inlined call, avoid copying args until write occurs
- Calling non-inlined function
  - Leave extended stack frame as is
  - Put calling instr on stack, as normal
  - Callee checks who caller is when returning, can find actual RA
  - May need to return to interpreter to do call

[DONE] TODO: add support for regexp in parser
var re = /pattern/flags
var re = new RegExp("pattern", "flags");
flags: i, g, m, y

[DONE] TODO: 3d-cube has a horrible trace exit count, why?
- Is it because traces are limited in length? Is it because of recursion?
- MMulti trace has 513 blocks
    root trace entry count: 1160855
    sub-trace entry count : 624093
    trace loop count: 241408
    trace exit count: 919447
- Increasing max trace length doesn't improve things
- getPropIdx isn't the problem
- Low trace count and super long traces doesn't help
- The trace is legitimately very long...

[DONE] TODO: compute trace completion rates?
- increment interp counter on trace start, other counter on final trace completion
- counter for interpreter fallback rate ***
- jit_stats
- Loops? Increment on each trace entry

[DONE] TODO: blog
- Traces, sub-traces
- Stack frame init maps
- Updated perf numbers
- All SunSpider/V8 benchmarks except regexp working, thanks to Tom Low
- FFI
- eval

[DONE] FIXME: segfault on ./higgs programs/sunspider/bitops-bits-in-byte.js 
- Doesn't crash with no JIT
- jump to self at block 30/169 in sub-trace of bits-in-bytes
- Root node has no trace object???? wtf
  - root not marked as a trace start
  - not calling record on it
- not setting root node properly in sub-traces

[DONE] TODO: look at more missing instrs for nsieve-bits
- eq_i8
- does this make sub-traces faster? yes
- crash in sunspider tests, signal 11

[DONE] TODO: review traces and sub-traces, do they make sense?
- long traces probably due to loops in runtime, e.g.: getPropidx
- does allowing longer traces result in slowdowns?
- increasing max trace length makes it slower

[DONE] TODO: jit_dumpinfo

[DONE] TODO: test JIT on earley-boyer
- check memory usage: 2.3%
- sub-traces aren't making much difference

[DONE] TODO: try tweaking trace/sub-trace constants/heuristics
- use jit_nosubs for performance comparisons
- 3d-raytrace is faster with sub-traces
- Tweaking inconclusive, would ideally need automation

[DONE] TODO: jit_disable, jit_dumpasm, jit_nosubs

[DONE] TODO: increment block idx only for trace headers

[DONE] TODO: add/enable more sunspider benchmarks in unit tests

[DONE] FIXME: gc/stackvm crashes with JIT, uses GC
- Crashes during sub-trace compilation

[DONE] FIXME: 3d-raytrace segfaults
- jumps to self too early?

[DONE] FIXME: stack depth issues in sub-traces
- Not keeping track of call stack and call stack depth properly
- Sub-trace needs this initial call stack
- Trace start node needs to start with correct stack depth

[DONE] FIXME: make sub-traces belong to parent trace object, not blocks

[DONE] TODO: make it so sub-traces are part of the root trace tree?
- Do we really need a trace pointer in TraceNode objects, is rootNode ok?

[DONE] TODO: Pass a copy of the CodeGenCtx to the sub-trace?
- Could be a big object
- Can we retrace steps from the root trace? Expensive
  - Expensive but necessary?
  - Could have hundreds of blocks in a main trace
  - Still OK if ctx is relatively small

[DONE] TODO: implement sub traces from if
- If threshold reached
  - call function that begins tracing from block
  - jump to interpreter
- Pass address to patch back for direct jump to trace
  - Write jump directly over a reserved block of nops, 10 + 2 bytes
  - Can reserve 12 bytes, use an assembler to get the proper bytes

[DONE] TODO: Trace node currently stores root node pointer
- Could store trace object pointer instead
- Trace object can store:
  - root trace node
  - parent trace object
  - parent jump address
- Creating the trace object can create the root trace node?

[PASS] TODO: loop to loop, stop at inner trace?
- Doesn't seem to improve performance

[DONE] TODO: keep track of calls/returns during tracing, avoid wasting time?
- Will avoid wasting a lot of time in function traces, super long traces
- Simplifies logic of JIT itself
- Should speedup 3d-cube, 3d-raytrace

[DONE] TODO: better callee-guessing in call

[DONE] TODO: ctx.stopTrace

[DONE] FIXME: 3d-cube, interpreter stack underflow, other crashes
- Caused by trace length being capped? No
- access-binary-trees, multiple levels of recursion in
  run-time error: undefined base in property read
  crash after compiling trace in $rt_getProp(27F5)
- Try disabling global prop access: no
- Disabling ret logic seems to fix it...
- Problem comes from default call/ret implementation not stopping trace

[DONE] FIXME: enable jump to self

[DONE] TODO: remove segment extension code, compile traces from trace nodes

[DONE] FIXME: in nsieve-bits, recording many many traces at rt_not, never compiling

[DONE] TODO: move IIR static ctor to ir/iir.d

[DONE] FIXME: seemingly unrelated blocks in traces...
- Jump into a trace while recording, end up anywhere

[DONE] TODO: implement trace node updating during tracing
- compTrace should take a TraceNode argument, construct the block list
- add a trace node pointer to the interp class?

[DONE] TODO: implement TraceNode class, jit/trace.d
- Node should have count, associated block, depth, tree root, list of children

[DONE] TODO: implement system to constrain trace starts to specific blocks
- Need to label trace start blocks
- Blocks need counter + trace start flag + trace object pointer

[DONE] TODO: refactor global return code into parser
- Useful for eval

[DONE] TODO: implement global eval
- eval_str instruction?

[DONE] TODO: rename segment object to trace, compSegment to compTrace, etc.
- Do grep for Segment/segment, to match comments

[DONE] FIXME: GC bug after multiple runs after load?
- Try to replicate with unit test
  - Hard to achieve, too much code
- rule_loop is the function that was destroyed then called *****
  - appears to be a local function, recreated
  - there are 3 different rule_loop functions...
    - 2 of them transitively added, last one destroyed
- How can we not find one of the rule_loop functions transitively?
- If we GC on global scope... Most functions are destroyed
  - Only a problem if first run occurs first
  - Obviously poor traversal, poor finding of function references
- The problem must be that our transitive function adding is imperfect..
  - Does not implement a proper DFS

[DONE] TODO: ASMComment pseudo-instruction?
- Have function to add comments when dumpasm is enabled?
- Will allow better understanding of asm output

[DONE] TODO: rename JITInstr to ASMInstr

[DONE] TODO: prepare presentation for Friday 15th March
- Explain ideas in more detail
- Elaborate on incremental segment extension
- Is counter=1 like regular tracing?
  - Not exactly, still need multiple passes through segment to extend

[DONE] FIXME: earley-boyer, call to non-function

[DONE] TODO: try self-patching mechanism for optimized global object access?
- cache based on global object address?
- can a load patch its own 32 bit offset???
- flesh out ASM code

[DONE] TODO: IP-relative addressing
- Should be able to specify label, but also extra disp
- Unit asm code execution

[DONE] TODO: refactor instruction operands
- Array of fixed size in instr
- Pointers to subclasses of X86Opnd

[DONE] TODO: IntData JITInstr
- Num bits, value

[DONE] TODO: optimize JIT interp fallback, now have mayGC, isCall
- Test with earley-boyer

[DONE] FIXME: GC during load(), not a proper function call! can't traverse stack
- unit test this, gc/load.js?

[DONE] TODO: remove stack init code from JIT

[DONE] TODO: make interp no longer init stack slots in function calls

[DONE] TODO: refactor GC to use init maps when traversing stack
- Make sure unit tests, earley-boyer still work fine!

[DONE] FIXME: ip is moved before instr is executed...
- Could probably change this with current design

[DONE] TODO: mayGC opcode flag
- Needed by heap_alloc, set_str, set_global, get_global

[DONE] TODO: implement init map system
- bug, seems to be caused by code after branch
- stop adding instrs after branch?

[DONE] FIXME: JIT bug causing segfault in earley-boyer
- Crashes in segment in $rt_class_get_cap(1394), len: 1
- Disabling call and ret JIT instrs does not fix it
- String table gets extended, class gets extended, but no GC yet
    $2 = get_global "$rt_class_ofs_cap", 177
    $1 = get_global_obj
    $3 = call $2, $1, $11 => call_cont(2D5A)
- Could it be get_global? Try disabling?
  - Works without get_global!

[DONE] TODO: optimize set_str

[DONE] TODO: try optimizing/specializing return sequence

[DONE] FIXME: gc causes crash during trace?
- Could the GC be invalidating something?
- Collecting the current function? No
- Segment causing crash is in array_push
  - Loops over $argc
- not crashing in get_arg, set_str, heap_alloc, load
- bug caused by getString in gen_call causing gc!

[DONE] TODO: can we have traces join themselves, e.g.: bitwise-and?

[DONE] TODO: add callStack in CodeGenCtx?
- push/pop the call instructions
- can allow full inlining
- may have problems with very long traces

[DONE] FIXME: v8/crypto sanity check fails

[DONE] TODO: branches extend according to which block is specified in the list
- Last if_true, if no next block is specified, insert counter code
compSegment(Interp, nextBlock, segment = null)
- Segment is created if none exists
- nextBlock gets added to the block list
- compilation loop follows the block list

[DONE] TODO: Create Segment class
- Can store counters, list of blocks, code block, etc.
- Easier to manage!

[DONE] NOTE: block exec counts are betraying us even in very simple cases!
- rt_and, both operands integers
- and_exit and and_sec blocks have the same exec count
- can't tell that the AND condition is always true
- Do we want branch counters instead?
  - Strictly more powerful than block exec counters, can still compute block exec count

[DONE] TODO: log instrs for which default fn is used

[DONE] FIXME: JIT breaks 3d-raytrace?
- Find issue, add jit unit test
- Problem seems to be in the call logic
- String(undefined) produces undefined after compilation
- $rt_isGlobalObj(this) in String starts producing true after compilation

[DONE] TODO: use unique id system for labels, use in toString?
- Just print their current offset?

[DONE] TODO: second assembler object for out of line paths
- Assembler.append(Assembler) function?
- OVF logic => out of line
- Function call interp path => out of line

[DONE] TODO: try logging branch exec counts on if_true
- Log with associated instr
- Many go entirely one way, most unbalanced

[DONE] TODO: refactor all conditional branches to have 2 targets?
- target, excTarget?
- Probably best for block extension
- Need to pick a target to extend the block with either way

[DONE] TODO: blog post about JIT compiler

[DONE] FIXME: v8/earley-boyer requires class extension
- Implement in interp/object.d
- Add unit test for this

[DONE] TODO: try to guess callee function?
- Can introspect a bit, check if calling global fun
- Compare closure pointer against known global
- If known global, run optimized sequence!
- Otherwise run interp version
- Great speedups!

[PASS] TODO: implement CALL instruction
- PROBLEM: call instruction sequence is extremely long!
- Very inefficient to implement

[DONE] TODO: implement RET instruction

[DONE] TODO: stack access functions

[DONE] TODO: table of code gen functions, addressed by opcode
- Default gen function calls the instruction

[DONE] TODO: implement JUMP_TRUE, JUMP_FALSE
- jump to trace end label

[DONE] TODO: implement set_int32
- Need to access wsp, tsp
- Load them from interpreter at start of trace, spill at end?
  - Allows proper indexing
  - Put them in callee-save registers

[DONE] FIXME: including RET or CALL in tracelet causes segfaultl
- Return seems to occur twice?
- Set traceEntry to null before entering trace
- Otherwise, we're setting it to null after trace, undoing work of another trace

[DONE] TODO: command-line option to enable or disable JIT
- options.d?

[DONE] FIXME: somehow, traces make odd behaviors happen, e.g.: call to non-function
- Somehow, semantics differ
- Lots of tracelets seem to get executed successfully
- Setting the IP before instruction execution seems to fix this...

[DONE] FIXME: trace issue, jump(block) can trigger recursive trace exec
- Could jump() set a trace pointer in interp, but not call it?

[DONE] TODO: basic tracelet JIT, jit.d
- Lazily compile tracelets for blocks
- Start with one entry point, as a C function
- Need trace to call into instr op functions
- Trace exits by doing ret

[DONE] TODO: port and test x86 execution tests

[DONE] TODO: convert push/pop test to 64-bit registers

[DONE] TODO: complete porting of assembler tests

[DONE] TODO: begin porting assembler tests

[DONE] TODO: port assembler code

[DONE] TODO: port operand toString

[DONE] TODO: finish porting basics of CodeBlock, add mem block allocation

[DONE] TODO: implement register toString

[DONE] TODO: port operand, encoding code

[DONE] TODO: port instruction table construction

[DONE] TODO: copy over Tachyon assembler tests, instr table

[DONE] TODO: fmod, needed by both raytrace benchmarks

[DONE] FIXME: raytrace sanity check fails
- Problem is division of number by string... assholes.

[DONE] TODO: look at D ABI
- Should match the linux 64-bit C ABI
First six int/pointer arguments in RDI, RSI, RDX, RCX, R8, and R9
Return value is stored in RAX

[DONE] TODO: blog
- Mozilla people, learning, friendly people, pleasant office
- DConf 2013
- Meeting with Apple
- Silicon valley is quite different
- Smartphone
- First pull requests
- Bug fixes
- Feature and benchmark list
- Brainstorming
- Preparing tracelet JIT implementation

[DONE] TODO: Add jump function, to jump to a certain block
- Changes the state of the interpreter, returns
- Asserts target is not null
- add block exec count

[DONE] TODO: enable JSON stdlib module
- parse fails, unknown escape sequence

[DONE] TODO: genCallTargets

[DONE] TODO: make call have 2 targets

[DONE] TODO: make post-call be separate block
- Don't want ret tracelet starting in middle of block
- Better for analysis?
- Alternative is ret stays in same block, IP is post-call
  - Would have to associate tracelet with instr in middle of block!
- bitops-nsieve-bits, before: 19.879, after: 24.189, sep: 21.837

[DONE] FIXME: 4294967295.0 === 0xFFFFFFFF
- Int not represented correctly
- Gen code using set_float instead

[DONE] TODO: Fix toInt32, needed by v8/crypto, v8/splay
- Make it use f64_to_i32
- Add more bitwise unit tests for and, or ops, rsft, ursft
- test corner cases

[DONE] TODO: Comply with ES5 comparison unit test
- Will help certify proper working
- Look at Tachyon implementation of primitives

[DONE] TODO: load_file instr
- Add unit test for this
- Add load to feature list on blog

[DONE] FIXME: deltablue, interpreter stack overflow
- Fails after Error object is finally found?
- Did some assertion fail?

[DONE] TODO: add more basic Tachyon unit tests
- Arith, operators

[DONE] FIXME: do we expect the result of Obj.toString to be a string in $rt_toString

[DONE] FIXME: v8/raytrace, info.color is undefined, shouldn't be
- for-in, used by object extension, is broken
- the presence of "var" screws it up

[DONE] FIXME: v8/deltablue, call to non-function
- EditConstraint corrupts working of UnaryConstraint?
- Setting EditConstraint.prototype.isInput corrupts EditConstraint.prototype.isInput

[DONE] FIXME: typeof global var should produce undefined
- $rt_typeOfGlobal(propName)?
- Needed by v8bench/raytrace
- Implement runtime function to see how practical this is
- Add unit test

[DONE] TODO: parseInt, needed for v8bench/crypto

[DONE] FIXME: interp.interp.RunError: global property "rng_pool" is not defined
- Global var stmt, not initialized to undefined
- Add unit test

[DONE] TODO: add list of working benchmark programs on Higgs page, useful to have

[DONE] TODO: Math.round, needed for 3d-cube

[DONE] FIXME: crypto-md5, crypto-sha1, invalid operand 2 type in op "auto r = x * y;" (int)

[DONE] FIXME: deltablue, 3d-cube, ref ptr out of heap
- Failing on object property
- propIdx is 2, object capacity is 2

[DONE] FIXME: lt,gt,eq functions fails in 3d-raytrace, undefined/null value as input

[DONE] TODO: anon function naming in AST
- Anon functions in sunspider/raytrace.js hard to debug

[DONE] FIXME: v8bench/richards, Segmentation fault
- Can we replicate this in a unit test?

[DONE] TODO: TypeSet, GCRoot, could we just use type monitor objects as weak roots?
- Use linked list kind of system, all type sets linked
- Store associated class, if any
- If class is dead after GC, destroy
- Functions destroy their type sets automatically
- Merge TypeMon and TypeSet

[DONE] TODO: implement delete operator
- Unit test this

[DONE] TODO: complete TypeSet constructor from val, union

[DONE] TODO: complete TypeMon basics

[DONE] TODO: GCRoot assignment operator, copy constructor

[DONE] TODO: blog, higgs interpreter complete
- Flesh out feature list on about page
- Post feature list
- Blog about monitoring
- Mozilla visit

[DONE] TODO: enable stdlib_string unit test, comment out regexp code
- interp.interp.RunError: global property "alloc_str" is not defined

[DONE] FIXME: destroy fun in collectFun causes odd interpreter bug
- Collecting function on stack?
- Log deleted functions

[DONE] TODO: parser, encode operator associativity, improve parenthesization
- Test with Function.toString
- Unit test expressions for correctness
- Problems arise when the parent doesn't have higher priority than us

[DONE] TODO: try to find expression tests that break parser re-parse
- write failing unit test

[DONE] TODO: add problematic expression tests for interpreter

[DONE] TODO: determine how to represent numerical ranges
- Look at moller's paper for insight
- just use int64

[DONE] TODO: start implementing type set object, in D
- interp/type.d?
- operations should mutate set objects? Yes, probably
  - want to keep list of dependencies
  - want to maximize speed of operations

------------------------------------------------------------------------------

Milestone Complete: working benchmarks

[DONE] TODO: for-in loop
- [DONE] Port over Tachyon runtime code for this
- [DONE] Test getPropEnum before implementing loop code gen
- [DONE] Base loop code gen on Tachyon code
  - loop until enum function returns false
- [DONE] Enable for_in unit test

[DONE] TODO: basic Date support
- currentTimeMillis()
- IR instr get_time_ms

[DONE] TODO: class obj, make it a hash table
- like the string table
- add max load consts to layout.py

[DONE] FIXME: string table extension provokes GC
- gc during table ext invalidates string ptr?

[DONE] TODO: arguments object
- If no "arguments" param, create arguments local
- KISS, just create array, copy arg vals in loop, set in local slot
- vars analysis should set usesArguments flag in function
  - KISS for now, any occurrence of "arguments" identifier
- enable gc test

[DONE] TODO: call with apply
- call_apply(closArg, thisArg, argTable, numArgs)
- enable gc test
- add unit Tachyon apply tests

[DONE] TODO: accessing missing global prop should throw exception
- use missing property constant
- assertThrows

[DONE] TODO: missing property constant, like undefined, but not
- [DONE] set_missing
- [DONE] init object properties to missing
- [DONE] revise getProp
- [DONE] revise "in" operator, hasOwnProperty
- [DONE] add unit tests

[DONE] TODO: Look at features of two "real" benchmarks to guide development
- Benchmarks: Bones, sunspider/3d-raytrace
- What features are we missing?
  - Float32Array, could replace by Float64Array, aliased to array
  - Already have everything else for bones!
  - For raytrace, new Date().getTime()
- v8/raytrace uses the for-in loop

[DONE] TODO: string->number, parsing numbers in strings
- stdlib_number unit test

------------------------------------------------------------------------------

Milestone Complete: complete simple interpreter (~Dec 31st)

[DONE] FIXME: topmost function doesn't have closure on stack?
- We free a closure, but can we free all its link indices?
  - No, because the code might still be used...

[DONE] TODO: traverse instructions of dead functions, collect link table refs
- log dead functions

[DONE] TODO: garbage collecting fun refs
- Create new fn ref table
- liveFuns table in interpreter
- When traversing closures, add fns to ref table
- Replace original ref table

[DONE] FIXME: ret addr is calling instruction, not IR function pointer
- Add special instruction pointer type tag

[DONE] TODO: blog post, interpreter milestone complete
- Next goals, monitoring, tracing JIT

[DONE] TODO: edit Higgs page on pgw, add supported features list
- Objects
- Arrays
- Closures
- Variadic functions
- For/while/do loops
- If/switch statements
- UTF-16 strings
- Integer and floating-point arithmetic
- Redefinable arithmetic operators
- Garbage collector

[DONE] TODO: remove GC output during unit tests

[DONE] TODO: garbage collecting string table
- don't forward string table, just re-alloc with same size
- after scan, remove strings table entries without a next pointer
  - need to rebuild table, reinsert strings
  - rebuild from old table
- strcat unit test

[DONE] TODO: remove stack slot init to undef, make it implicit?
- move from push to callFun

[DONE] TODO: make next ptr first field in all layouts
- init next ptr to null
- header is second field
- have GC traverse next pointers in objects

[DONE] TODO: beef up clos alloc test

[DONE] TODO: obj alloc test

[DONE] FIXME: stackvm test, segfault
- allocation completes
- crash after alloc in op_call_new

[DONE] FIXME: deepstack... Stack ref, object not in from-space heap
- collect called manually, not in the middle of anything...
- invalid object is all zeros?
- pointer appears to be from old from-space (zeroed out)
- clearing stack slots on push seems to remove problem
- Temp slots don't get initialized!

[DONE] FIXME: graph test, second collection fails, cannot copy in to-space, heap limit exceeded
- object size is corrupted (by previous GC?)
- happens during op_heap_alloc
- crash during "visiting stack roots"
  - probably, some stack object or stack ref is corrupt
- setting slots to undef on push and pop does not fix the problem
- inserting/removing prints can make the bug disappear...
- layout type of faulty object is closure...
  - object is near boundary of from-space

[DONE] TODO: implement GC count variable, IR instruction

[DONE] TODO: make programs/gc/graph.js run

[DONE] TODO: repeated closure allocation test
- closure in loop
- call closure to test

[DONE] FIXME: heisenbug with repeated closure alloc
- call to non function

[DONE] FIXME: repeated closure allocation produces segfault
- Failure probably occurs during newClos

[DONE] TODO: implement proper shrinkHeap

[DONE] FIXME: heap corruption during collection
- println fails, unhandled type in toString
  - link table problems?

[DONE] TODO: implement heap resizing for GC tests

[DONE] TODO: gc arrays test

[DONE] TODO: while manipulating references in interp, push refs to be saved on stack
- [DONE] setProp 
- [DONE] newObject
  - pay special attention to arguments
- [DONE] interp/string.d
- [DONE] setProp callers
- [DONE] throwError
- [DONE] op_call_new
- [DONE] op_new_clos

[DONE] TODO: eliminate ppClass in newExtObj? How useful is it really?
- Not that important!

[DONE] TODO: store ValuePair in stack root
- Multiple helpful constructors
- Assignment operators

[DONE] TODO: implement stack root system
- use special pointer container object, struct w/ destructor (implement in gc.d)
- object can be linked in doubly linked list

[DONE] TODO: revert to-space alloc code

[DONE] TODO: collect in function test

[DONE] TODO: $ir_gc_collect instruction

[DONE] TODO: get heap size instruction
- $ir_get_heap_size

[DONE] TODO: gcCollect after library loading

[DONE] TODO: gcCollect in middle of library loading

[DONE] TODO: first GC test, call gcCollect after interp init?

[DONE] FIXME: forwarding the same address many times over?

[DONE] TODO: function to allocate to-space
- Check if not allocated in gcCollect, if so allocate

[DONE] TODO: when allocating and running out of space, alloc to-space?
- Can keep allocating in from-space as well!
- Have a special function to check if to-space is allocated, allocate to it

[DONE] TODO: move heapAlloc to interp/gc.d

[DONE] TODO: scan link cells during GC
- Scan as roots

[DONE] TODO: layout_visit_gc(o) dispatching fn

[DONE] TODO: GC obj traversal functions
- Do a get on fields, call gcForward, set the result
  - word/type pairs slightly problematic?
    - if tpField set, call special function to forward

[DONE] TODO: remove array functions from objects.d, maintainability hazard

[DONE] TODO: init object properties and array elements to undefined for now

[DONE] TODO: unit test for obj field init
- Two objects from one class, one with a specific field, one without
  - Second one should come out undefined

[DONE] TODO: word field in object/array/cell should be annoted with type field name
- type field should be resolved

[DONE] TODO: layout_sizeof(o) dispatching fn
- Easy to implement, do this automatically
- obj_get_header(o)

[DONE] TODO: Forwarding pointer in layout
  layout_get_next(o)
  layout_set_next(o, p)
- Set special header flag (top bit), store forwarding pointer after header
- Can write these functions in D if desired

[DONE] TODO: layouts, enforce alignment of fields to field size

[DONE] TODO: implement visitStackRoots

[DONE] TODO: port gcCopy, gcForward

[DONE] TODO: complete port of gcCollect

[DONE] TODO: call gcCollect in heapAlloc function

[DONE] TODO: copy over relevant Tachyon GC code

[DONE] TODO: Make sure pointers are initialized to null
- Unless immediately initialized, init pointers to null

[DONE] TODO: create interp/gc.d

[DONE] TODO: create IRFunction ptr word type tag
- Update in layout.py as well

[DONE] TODO: store ctor class ptr on closure obj?
- refptrs

[DONE] TODO: no more ptr caching in instr/IRFunction, no ptrVal instr arg type

[DONE] TODO: modify opNewClos to use link table entries

[DONE] TODO: use new arr alloc in IR->AST

[DONE] TODO: use new obj alloc in IR->AST

[DONE] TODO: implement newClos in runtime.js
- Issue: need to get IRFunction ptr, add to ref table
  - Special instruction for this?

[DONE] TODO: GET_FUN_PTR
interp.funRefs[cast(void*)fun] = fun;
- GET_FUN_PTR <irfunction>
- Takes ptr, add fn to ref table, produces raw ptr

[DONE] TODO: implement newArr in runtime.js
- Improve Array ctor, use newArr

[DONE] TODO: implement newObj in runtime.js

[DONE] TODO: instructions to access link table
- make_link "name"
- get_link
- set_link

[DONE] TODO: make SET_STR alloc a link table cell internally
- Store cell index in arg
- Add new arg type

[DONE] TODO: add wLinkTable, tLinkTable to interpreter
- Allocate in constructor using malloc
- Have list of free link table entry indices
- Function to get a new link table entry index

[DONE] TODO: create $rt_toNumber
- Used in number constructor

[DONE] FIXME: programs/sunspider/math-spectral-norm.js
interp.interp.RunError: invalid base in property write
- Var statement is parsed incorrectly...
  - Only first identifier is resolved, rest goes in init expression
 - Make a parser unit test

[DONE] FIXME: programs/sunspider/bitops-nsieve-bits.js 
global prop unresolved $rt_not
- Add unit test

[DONE] TODO: float to string support, can't print floats right now!
- expose f64_to_str instruction
- Unit test

[DONE] TODO: can we run more benchmarks? Yes
bitops-nsieve-bits  14.5
math-spectral-norm  3.28
math-partial-sums   10.4
3d-morph            6.07
access-nsieve       8.46
access-fannkuch     33.0

[DONE] TODO: Math.log, Math.exp, Math.pow, Math.ceil, Math.floor, expose as instrs
- Too early to try optimizing this, beat libraries

[DONE] TODO: remove exec flag from heap

[DONE] FIXME: stdlib/math.js, second parse gave different result
    if (term < 1E-15)
        break;
- Add parser unit test, fix

[DONE] TODO: blog post about state of Higgs, features supported, upcoming
- Ask for help, Math.js, anything else?
  - be specific
- Simple JS FFT benchmark?

[DONE] TODO: use exceptions in op_call
- Throw exceptions on error, e.g.: call non-function
- Lookup global exception constructor
  - If avail, create deriv obj from prototype
  - If not avail, throw message string
- Need to run throw logic

[DONE] TODO: catch RunError instances in repl, print stack trace

[DONE] TODO: make stdlib/error.js work

[DONE] TODO: stack trace
- KISS for now, accumulate stack trace in throw

[DONE] TODO: test basic interprocedural try/catch

[DONE] TODO: implement stack unwinding, RunError
- Uncaught exception throws D exception

[DONE] FIXME: infinite loop when generating exc path for runtime calls?
- Infinite loop in compiling finally statements
  - string concat in finally stmt
  - finally stmt has itself in finally list? WRONGE!

[DONE] TODO: exception codegen for call / call_new
- If there is no englobing try/catch and no englobing finally, do nothing special
- If there are englobing finally blocks, need to compile those on exception path
  - After these are compiled, jump to try catch if present, otherwise do interp throw
- Prototype with call

[DONE] TODO: throw from within catch, no catch block, but should trigger finally block
- Could we use getFnlStmts, just use first fnl block?
- make test, finally_throw.js

[DONE] TODO: implement finally support in break/continue
- accumulate finallys until target? can pass list ref as argument to ctx fn
  - compile from inner to outer

[DONE] TODO: implement finally support for return
- find all englobing finally statements
  - compile from inner to outer
- test with finally_ret.js

[DONE] TODO: test intraprocedural throw
- throw_intra.js

[DONE] TODO: basic catch block compilation, ir/ast.d

[DONE] TODO: import some Tachyon stdlib tests (e.g.: boolean)

[DONE] TODO: make String ctor work

[DONE] TODO: make array toString/join work

[DONE] TODO: make new Array(len) work
- Needs arguments object
- unit test
- nqueens test?

[DONE] TODO: make Math.max work

[DONE] TODO: instructions to get arg count, access args

[DONE] TODO: refactor calling convention, call instr will:
  ra, clos, this, argc, args.., ...padding...
- pad with undef for missing args
- push args in reverse order
- push local slots
- ret pops local slots, pops args based on argc, pushes ret val

[DONE] TODO: employ closures to implement Math.random RNG
- Keep the RNG simple, KISS!

[DONE] TODO: use subCtx when creating managing clos cells at function init, save temps

[DONE] TODO: unit test closures more thoroughly
- Tachyon closure tests

[DONE] FIXME: variable resolution
- Currently, after nested function has had its defs added, resolve them
- This seems wrong, need to finish parsing parent functions
- Do a recursive resolveRefs pass at the end?
- Problem: all the scope objects are lost! god damnit.
- Alternative: find all decls at one level before trying to resolve
  - Can just resolve immediately instead of calling resolveRefs

[DONE] TODO: gen code for closure cells
- grab unit tests from Tachyon
- cellMap: maps symbols to closure cells
  - in our case, symbol -> local slot of clos cell
- Creating closure objects, set their cells

[DONE] TODO: allow not having return slot in call instr

[DONE] TODO: resolve captured (closure) vars in parser/vars.d
- In Tachyon, fun.captVars vs fun.escpVars
- captVars: captured from other functions
- escpVars: escaping to nested functions

[DONE] TODO: closure cell layout
- Extra properties after object fields

------------------------------------------------------------------------------

[DONE] TODO: improve valToString

[DONE] TODO: fix AST bracketing (curly braces)?

[DONE] TODO: support for "in" operator

[DONE] TODO: implement instanceof operator (used by stdlib/string)

[DONE] TODO: array prototype object

[DONE] TODO: implement Function.toString()

[DONE] TODO: create fun proto obj in interp?
- Corresponding access instruction

[DONE] TODO: function IR dump, log arg slots

[DONE] TODO: $ir_get_ir_str, $ir_get_ast_str?
- Useful for implementing function toString
- Useful for debugging!

[DONE] TODO: eliminate opSetProp, opGetProp

[DONE] TODO: make ast IR gen use prop access runtime functions

[DONE] TODO: implement getProp, setProp in runtime
- array.length property access
- string indexing access
- Don't need to compute hash code, already computed in strings

[DONE] TODO: implement switch stmt code gen

[DONE] TODO: way to test for null pointer
- Make null constant an actual zero null pointer (refptr)

[DONE] TODO: set_value
- Takes word and type inputs

[DONE] TODO: eq_u8
- Useful for layout type comparison

[DONE] TODO: basic throw instruction support, make it stop interpreter

[DONE] TODO: add global undefined property

[DONE] TODO: interp/objects.d
- Object manipulation primitives
- Keep that code alive

[DONE] TODO: SET_GLOBAL, GET_GLOBAL
- D string argument
- Implement global prop slot caching
- Test speed of bitops-bitwise-and
  - About 10x faster

[DONE] TODO: boolean negation !
- Probably want to inline code sequence?
  - Better compatible with genBoolEval
- Unit test this

[DONE] TODO: finish replacing basic operators with runtime functions
- eg: +=, *=, ...
- Remove corresponding high-level instrs

[DONE] FIXME: genAssign, incompatible with rt fun calls
- Pass delegate function instead

[DONE] TODO: I64/F64 conversion instructions

[DONE] TODO: interp cycle count?
- bitwise-and => 3.72M cycles
- will be less cycles once we have GET_GLOBAL
- currently look through 170+ property names in linear search!

[DONE] TODO: complete bitwise op runtime functions

[DONE] TODO: complete runtime comparison primitives

[DONE] TODO: IIR improvements, eliminate need for $ir_jump_false
- Clearer, more concise!
- genBoolEval? Treat IIR differently

[DONE] TODO: implement/test $rt_toBool
- Before: bitwise and takes 5.97s
- After: bitwise-and takes ~24.6s
- Time probably dwarfed by global lookups

[DONE] TODO: interp file loading
- useful for testing/timing benchmarks

[DONE] TODO: make typeof use runtime function

[DONE] TODO: run controlflow-recursive in unit tests

[DONE] TODO: $rt_eq

[DONE] TODO: assertBool

[DONE] TODO: begin using runtime system for arith ops
- Works for add, make test time seems unaffected

[DONE] FIXME: GC bug redux
- Reference IRFunction in fun table instead of AST
- AST has no pointer to IRFunction

[DONE] TODO: insertRtCall(IRGenCtx ctx, string fName, LocalIdx[] argLocals)
- Current impl uses many IR instrs

[DONE] TODO: JS file tests, import some from Tachyon

[DONE] TODO: comma operator support, ir/ast.d
- Evaluates both expressions, returns second value

[DONE] FIXME: for (var i = 0; i < 1000000; ++i);
    object.Error: heap space exhausted
- SET_STRING allocates string every time

[DONE] FIXME: interpreter crash in unit test
  $rt_toBool('foo')? 1:0
- Crash may or may not happen if source is modified...
- May be related to D GC
  - What if a function we need was randomly collected...?
    - AST or IR collected
- Closure objects keep refs to ASTs
  - Need to keep a function table in interp
- Seems fun.ast has been freed by interp!
    write(core.memory.GC.addrOf(cast(void*)fun.ast));
- Add function reference table in interpreter

[DONE] TODO: Math.pow for integers

[DONE] TODO: $rt_div

[DONE] TODO: $rt_mul

[DONE] TODO: Math.sin, Math.cos, Math.sqrt

[DONE] TODO: cos, sin, sqrt instrs
- Needed for math lib

[DONE] TODO: add interp loadStdLib flag, load stdlib/math.js

[DONE] TODO: $rt_toBool

[DONE] TODO: REPL, don't print if undefined

[DONE] TODO: $ir_print instruction, for debugging
- Use in runtime print function :)

[DONE] TODO: complete $rt_toString

[DONE] TODO: complete $rt_add

[DONE] TODO: complete $rt_strcat

[DONE] TODO: complete $rt_intToStr

[DONE] TODO: GET_STR instruction

[DONE] TODO: heap_alloc instruction
- Unit test w/ load/store

[DONE] TODO: complete low-level arithmetic, bitwise instructions
- Template with mixin

[DONE] TODO: Design Link table
- Part of interpreter, statically allocated, unmoving, contiguous
- primitives to manipulate this (get, set), take a unique id number
- wLinkTable, tLinkTable
- What problem are we trying to solve?
  - For getString: want to link a string object pointer
  - For callNew: want to link a class pointer, different for each callee
  - For newClos, newObj, newArr: want to link a class pointer
    - Two pointers for newClos, closure *and* prototype
  - Want the GC to have easy, fast access to these slots!
- MAKE_LINK instr can give us link cell index (need index, otherwise 2 pointers)
- Want to be able to allocate slots lazily
- JIT may need to link constant objs too. Can be done at compilation time.
- Instrs needing global obj, obj proto?
  - Can have host primitives for this, access through interp object ***
- make_link "classptr", produces index to cell

[DONE] TODO: $rt_typeof
- Will need access to header type field

[DONE] FIXME: obj_get_header not working

[DONE] TODO: Generate runtime functions for layout alloc

[DONE] TODO: Define layout type constants

[DONE] TODO: implement new layout system, layout.py
- Declarative layouts in a list
- add make layout makefile entry
- Generate ASTs from layouts (simple ASTs)
  - For JS, auto add $rt_ prefix to every function name
- Generate D and JS source from ASTs
- layout.d, layout.js

[DONE] TODO: Interp.evalString(string str, string fileName = "string")?
- Use to load layout code

[DONE] TODO: eq_i32, lt_i32

[DONE] TODO: add_i32, mul_i32

[DONE] TODO: load/store instrs
- load_i32, ptr, offs
- simple template for op fun generation

[DONE] TODO: is_refptr, is_const

[DONE] TODO: initial $rt_add runtime function

[DONE] TODO: ftoi instruction, I32_TO_F64

[DONE] TODO: add_i32_ovf, add_f64
- unit test

[DONE] FIXME: branchy IIR, need assignment support

[DONE] TODO: is_int, is_float, is_refptr type test instrs
- Do we ever need to compare type tags? Probably not

[DONE] TODO: implement member call in AST->IR, needed for $rt_toString

[DONE] TODO: test $rt_toString runtime function

[DONE] TODO: branchy IIR syntax: if (%...)

[DONE] TODO: special syntax for inline IR, with % sign (make special unary op?)
- Could just use $iir_ syntax, KISS!
- Normal IIR is a function call expression
- Test in shell

[DONE] TODO: Create extensible table of inlinable IR instructions for IIR access

[DONE] TODO: Create interp/runtime.js file, parse/run this at interp startup

[DONE] TODO: interp.exec(AST), interp.load(file)

[DONE] TODO: integrate SET_ARG into call
- Would make for shorter IR if we call into primitives
- 2 instructions per primitive call could be alot
- constant argument: set_int, then set_arg, kind of retarded!
- setArg is fragile anyways

[DONE] TODO: No more MAX_ARGS for instrs. Var arg system.

[DONE] TODO: Add instruction branch target field
- Refactor branch instructions

[DONE] TODO: Eliminate get_ret and the likes!
- RA is call instr
- Problem: Interp loop sets next instr before call
- Doesn't matter, call/return sets next instr anyways

[DONE] TODO: instr, add IRFunction ptr,
- get rid of raSlot, numLocals in RET, PUSH_FRAME
- Better for supporting exceptions, stack traces!

[DONE] TODO: array unit tests

[DONE] TODO: Modify getProp/putProp
- Look at Tachyon code, port over
- Modify underlying getProp, or higher level?
  - setArrElem assumes array, no toObject
  - go with Tachyon approach, simplify lower level fns

[DONE] TODO: rename confusing len fields in layouts

[DONE] TODO: make type objs in class rawptr, will be host objects

[DONE] TODO: implement opNewArr

[ODNE] TODO: array literal AST->IR

[DONE] TODO: NEW_OBJECT, remove proto local
- Only used for object literals
- stdlib will use custom host functions where needed

[DONE] TODO: array object & array table layout
- Should have array table field for array objects

[DONE] TODO: refactor layout system
- genLayouts
- Auto-generate layout type ids, define constants
- Auto-add type field as first layout field
- Add default field initializers (eg: init next to null)
- Layout extension

[DONE] TODO: alloc min size on closures, proto object
- Test adding many properties to fn.prototype

[DONE] TODO: implement object extension
- Need to handle closures and arrays too!
- Need to define type tags
- Modify getProp to follow next link chain

[DONE] TODO: implement type tags into layout system
- Define as uint32 in layout.d, make enum
- Type should be auto initialized on allocation
- Remove _set_type calls

[DONE] TODO: GET_RET_NEW
- ISSUE: need access to the this object passed to the call!
- Push a hidden this argument on the stack?
- Could have CALL_NEW produce this object in output slot, do explicit
  coupling between CALL_NEW and GET_RET_NEW?
  - Seems reasonable?
- Unit tests for new operator

[DONE] TODO: fix this binding resolution

[DONE] TODO: do proto lookup in opCallNew

[DONE] TODO: prototype chain support in lookup
- Test that missing props evaluate to false

[DONE] TODO: simplify class system, allocate proto slot, all property slots for now!

[DONE] TODO: create proper closure in opNewClos, fix opCall
- Test properties on function objects

[DONE] TODO: closure layout
- Needed for functions to have .prototype
- Cannot concat new props on prop array at compile time...
- Want list of closure cell pointers, function pointer

[DONE] TODO: opNew, AST->IR for new

[DONE] TODO: FP less-than comparison

[DONE] TODO: basic floating-point support
- assertFloat w/ epsilon

[DONE] TODO: Interp.getSlot/Interp.setSlot with ValuePair
- Use to simplify code in interp/ops.d

[DONE] TODO: object literal support w/ unit tests

[DONE] TODO: opSetProp

[DONE] TODO: implement opNewObj
- Lazily create new object class?

[DONE] TODO: make alloc set size fields automatically

[DONE] TODO: auto-generate alloc layout method taking interp as parameter

[DONE] TODO: AST->IR for indexed operations, property access

[DONE] TODO: object literal AST->IR

[DONE] TODO: typeof operator
- IR, AST->IR

[DONE] TODO: string concatenation

[DONE] TODO: Implement getString, replace uses of makeString by getString

[DONE] TODO: string table extension

[DONE] TODO: Interpreter method to get a string from the table

[DONE] TODO: alloc initial string table
- allocStrTable(Interp*)

[DONE] TODO: string hash code computation

[DONE] TODO: string table layout
- len
- num_strs

[DONE] TODO: interp/string.d

[DONE] TODO: interp/ops.d

[DONE] FIXME: many moves are unnecessary
- Moving a value into the output slot, just to transfer the value
- Possible fix: add setOutSlot again

[DONE] TODO: ability to prescribe output slot to sub-context

[DONE] TODO: test unary plus, minus operators

[DONE] TODO: in-place operators, +=, -=, etc.
- Issue: "a[f()] += 1" is not "a[f()] = a[f()] + 1"
  - Don't want to evaluate f twice
- TODO: check in what order V8 evaluates lhs, rhs?
  - lhs, then rhs
- Try passing IR instr to assgToIR for in-place operators

[DONE] TODO: revise ast-to-ir design, currently hard to debug&maintain
- context/sub-contexts interfere with each other in unpredictable way
- out slot should be allocated in current context too, to avoid collision
- should eliminate desired out slot/set out slot mechanism?
  - inserts confusing invisible moves!
  - every expression allocates an output temp for itself
- favor simpler, more robust design!
- When creating sub-ctx, decide if it has output or not
  - If it has output, allocate out slot immediately

[DONE] TODO: fix class desc, prop idx instead of woffs/toffs

[DONE] TODO: test global function declarations

[DONE] TODO: test global var statement

[DONE] TODO: global var unit tests

[DONE] TODO: basic SET_GLOBAL, GET_GLOBAL interp implementation

[DONE] TODO: SET_GLOBAL, GET_GLOBAL IR instructions + IR gen
- opSetGlobal, opGetGlobal?

[DONE] TODO: allocate global object in interpreter init function
- Also need to allocate global class
- Also need to initialize both objects
- Make room for 512 properties

[DONE] TODO: finalize initial object layout, class desc layout
- Start with simple layouts
  - V8 uses at least 3 extra words per object, if not more!

Objects have:
- Header
- Num fields
- Class ptr
- Next ptr
- Prop words
- Prop types
- Proto is property 0

Arrays are objects with special properties:
- array table
- length, capacity

Functions are objects with special properties:
- fn ptr slot (raw ptr)
- fixed number of closure vars (can be named)

Class desc:
- Needs next pointer too, so we can add new fields if needed

[DONE] TODO: IR gen for logical and, logical or
- More unit tests

[DONE] TODO: implement/test string concat

[DONE] TODO: implement SET_STR in interpreter
- Lazily allocate strings in the interpreter?
- Unit test this

[DONE] TODO: instr implementation functions
- instr type objects, rename to opcode
- Have pointer to implementation function
  - implementation takes interp state pointer as input

[DONE] TODO: merge Interp and State, no need for two classes

[DONE] FIXME: crash bug, taking address of function wrong

[DONE] TODO: implement string constant IR gen

[DONE] TODO: think about object layout/format further
- Object needs next ptr, otherwise can't reallocate more space
  - Only needed when writing past num fields
- Simple approach might be best!

[DONE] ISSUE: reading field from object, always need to check next pointer...
- Never know that object is big enough to have this field
- Unless class has special "all conforming" field?
  - All pointers to old objects eliminated during GC
- Result: as soon as a new field is added to one object, class is expanded, 
  not all conform (unless only one object of this type), any JITted using this
  class code must be recompiled not to assume next is null
- Global object: if preallocated large, can stay conforming

[DONE] TODO: SET_STR instruction
- Have string + ref/ptr val, not yet allocated?
- Note: string references exist outside the heap

[DONE] TODO: rename REF to REFPTR

[DONE] TODO: interp/layout.js
- genLayout(), test with mixin immediately, print output

[DONE] TODO: heap memory block
    import core.sys.posix.unistd, core.sys.posix.sys.mman;
    PROT_READ | PROT_WRITE | PROT_EXEC;
    auto mem = mmap(null, length, flags, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (mem == MAP_FAILED)
        return null;
    return cast(ubyte*)mem;
- Must be executable ***
- State should allocate a ubyte array for the heap. Must be immovable.
- Alloc ptr is bumped and aligned (see previous gc code)

[DONE] TODO: break, continue IR gen
- When entering IR gen for a loop, associate labels with break, continue blocks
  in the current context.
- Make a context function for this, pass a statement, the break and continue blocks
- Make a context function to do a recursive break or continue target lookup

[DONE] TODO: break, continue with and without label in parser

[DONE] TODO: label support in parser
    LabelledStatement :
        Identifier : Statement
- Store a list of labels on the statement
- Try with backtracking, see how speed is affected

[DONE] TODO: IR gen for cond ? expr

[DONE] TODO: IR gen for post incr., decr

[DONE] TODO: IR gen for do-while loop

[DONE] TODO: IR gen for for loop

[DONE] TODO: Interpreter while loop test

[DONE] TODO: repl, if ExprStmt, transform into ReturnStmt?

[DONE] TODO: repl, output to string?

[DONE]FIXME: handle incorrect argument counts, currently crashes
- add unit tests

[DONE] TODO: state.move function

[DONE] FIXME: IR function args printing

[DONE] TODO: test fib

[DONE] TODO: test fact?

[DONE] TODO: ValuePair to string

[DONE] TODO: test lt comparison

[DONE] TODO: test branching

[DONE] TODO: implement JUMP, JUMP_TRUE, SET_TRUE, BOOL_VAL instructions

[DONE] TODO: implement CMP_LT comparison instruction

[DONE] TODO: test local var assignment

[DONE] TODO: parameter passing

[DONE] TODO: function calls, return global call
- unit tests

[DONE] TODO: unit tests for global expr return

[DONE] TODO: basic interpreter loop
- Capable of evaluating global expr

[DONE] TODO: calling of top unit-level functions in interpreter
- Interp.run(ASTProgram) ?
- Interp.getRet() ?

[DONE] TODO: PUSH_FRAME call at start of function

[DONE] TODO: start implementing simple interpreter
- Could cheat, closures as IR fn ptrs
- Interpreter state structure
  - Double stack system, two base pointers, two top pointers
  - IR instruction pointer
  - heap allocPtr?

[DONE] TODO: auto name unit functions
- use delegate, map?

[DONE] TODO: reverse local indices after IR gen?
- Issue: want to use stack pointer, not base pointer
- Need to know how many locals there are
- Highest local becomes index 0, top of stack

[DONE] TODO: IR gen, map hidden args in local map

[DONE] TODO: IR gen for closures of nested functions

[DONE] TODO: use IR function in new_clos IR

[DONE] TODO: look at IR for global call

[DONE] TODO: IR gen for function call

[DONE] TODO: IR gen for function expressions

[DONE] Call protocol ISSUES:
- Many hidden args (closure, this, nArgs, RA)
- Should we push all after normal args? Practical, may be problematic if frame resizing needed
  - Not a problem for the JIT if call is inlined (most calls can be?)
  - Not a problem if no resizing!
- Would want call instr to take exception block arg?
  - Technically, this can be some annotation per return address for a function!

Stack frame layout (grows down):
        arg0
        arg1
...
        argN
        closure (pushed by call)
        this    (pushed by call)
        nArgs   (pushed by call)
        RA      (pushed by call as raw pointer)
...
SP+2    local
SP+1    tmp
SP+0    tmp

[DONE] TODO: IR instructions for call protocol

[DONE] FIXME: resolve vars in assign lhs exprs?

[DONE] TODO: pretty print of expressions with less parentheses
- Can parenthesize sub-expressions
- When do we need parentheses?
  - Parent has higher precedence: (x + y) * z
- getPrec function, returns highest by default (atomic)

[DONE] TODO: IR gen for while statement

[DONE] TODO: float expr

[DONE] TODO: IndexExpr, merge with dot operator to simplify AST
- create string expr from ident

[DONE] TODO: IR gen for VarStmt

[DONE] TODO: code gen for if statement

[DONE] TODO: IR for undef constant, return undef by default

[DONE] TODO: decide on IR generation strategy.
- Current code generation strategy:
  - Create codegen context for sub-expressions
  - Can specify an output slot (where the sub-expression should store its output)
  - Sub-expression can specify it already has a slot, move inserted if needed
  - Sub-expression can get a slot allocated for its output if none was specified
- What is problematic about this approach? How can we fix it?
  - Need more higher-level constructs, simplifications for common operations

[DONE] TODO: unary negation code gen

[DONE] TODO: look at Marc's simple C compiler. It uses a stack machine.

[DONE] TODO: for-in statement parsing
- need to make work with regular for statement
- if there's no var, we know it's an expression
- could parse whole expression, see if it's an "in" expression ***?
- if starts with var, parse following expression
  - check if expr is "in" expression
  - can't parse as real var statement...
- for var ... in, could try peeking ahead more

[DONE] TODO: peekSep, peekKw

[PASS] TODO: IR, fuse compare and jump
- Uselessly complicates IR->AST translation

[DONE] TODO: optional catch clause

[DONE] TODO: try parsing stdlib

[DONE] TODO: fix sunspider/3d-raytrace parsing/toString bug

[DONE] TODO: decide on boxing scheme
- Scraping float bits for tagging is problematic
- x86 has (all valid in 64-bit):
    CMP r/m8, imm8 : two-byte instruction
    MOV r/m8, imm8 : two-byte instruction
    MOV r8,r/m8     : 2 bytes?
    MOV r/m8,r8     : 2 bytes?
- With double wrappers, don't need to query objects about their type!
- ASM microbenchmark?
  - Performance indistinguishable between one vs two stack
    pointers, separate type array or not
- "Representing Type Information in Dynamically Typed Languages"
  - Had mostly good things to say
  - Seemed to assume that the only "large-wrapper" option is two words
- Separate tags may have advantages for instr level parallelism (ILP)

[DONE] TODO: adapt parser code
- [DONE] fix operator precedence, operator table
- [DONE] new operator
- [DONE] function syntax, missing fn name
- [DONE] object literal syntax
- [DONE] string literals with single quotes
- [DONE] source should be processed as wstring, UTF-16
- [DONE] string expr should store wstring
- [DONE] hex/unicode string escapes
- [DONE] hex number support
- [DONE] variables, one scope per function
- [DONE] functions, find fn decls in scope
- [DONE] variables, multiple decls per statement
- [DONE] optional semicolon for expression statements
- [DONE] test empty statement
- [DONE] multiline string continuation
- [DONE] re-parse test
- [DONE] optional semicolon for var statement
- [DONE] optional semicolon for return and throw
- [DONE] fix bug with crypto benchmark, do diff
- [DONE] break, continue statements
- [DONE] switch statement, as if cascade
- [DONE] more unit tests
- [DONE] real JS code unit tests, sunspider benchmarks
- [DONE] reverse operator precedence numbering
- [DONE] implement comma operator

[DONE] TODO: put project on github

[DONE] TODO: create Higgs project folder, move code

[DONE] TODO: how many benchmarks can we run with this? Need 2-5 (easier first)
- access-binary-trees, new operator
- math-spectral-norm, uses FP
- math-cordic, uses FP
- access-fannkuc, uses arrays
- access-nbody, uses FP math, arrays
- navier-stokes, uses arrays, FP math
- string-base64, uses strings, arrays
- crypto-*, strings, arrays
- crypto (V8), strings, arrays, math, new
- richards
- splay
- deltablue, uses .call
- raytrace, uses .apply, arguments as object, object literals, FP math
- earley-boyer, uses .call, .apply, arrays, strings
- some of the new octane ones might be feasible (non-DOM ones)

