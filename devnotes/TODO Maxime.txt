Conference deadlines:
- DLS 2013      June 8, 2013
- VMIL 2013     ~August 2013
- CGO 2014      ~September 2013
- CC 2014       Oct 4, Oct 11 2013
- PLDI 2014     Nov 8, Nov 15 2013
- VEE 2014      ~November 2013

------------------------------------------------------------------------------

TODO: take a look at Mozilla regression tests
http://hg.mozilla.org/mozilla-central/file/8c5a94ba1096/js/src/jit-test/
- ideally requires test harness

TODO: add --jit_trace command-line option

TODO: complete WAV output support, test it out with sine wave

------------------------------------------------------------------------------

TODO: begin writing classes, functions for new JIT
- Assembler & encoding
  - KISS, direct encoding methods? as.jmp(label), as.label(label) and as.label(name)
  - No intermediate structures for instrs, just encode directly
  - Arg structs for mem opnds
  - Labels are just strings in a map!
- Executable memory management
  - Interp class owns executable chunk?
- CodeGenState
- BlockVersion
- Stubs
- compile(block, state)
- genBranchEdge(edge, predState)

TODO: think of how to convert JIT ops to library of functions
- Only need lib fns for more complex or infrequent ops
  - No need for lib fn for core typed arith ops, comparisons
- Convention for calls from JIT?
  - Not really necessary, just spill all, keep as is

TODO: comment out JIT code
- Comment out contents of ops.d, assembler.d, jit.d

TODO: add source position info for call sites
- Map of call sites to source pos in IRFunction?
- Do this in genCallTargets?
- Throw instr also needs a source pos

TODO: remove JIT entry point hooks from IR

TODO: comment out interpreter unit tests












------------------------------------------------------------------------------

[DONE] TODO: unit test that checks object == and === equality after extension
- Push to master once done

[DONE] TODO: unit test that extends global object through indirect pointer
- globalObj = this; ...
- Loop with property names to 5000
- Once extended, try setting global prop, reading global prop

[DONE] FIXME: delete as property name not supported
- Special case of . member operator
- Add parser test
- Test map
- Does Tachyon have map unit tests?
- Push to master

[DONE] TODO: add map.js to Higgs stdlib
- Impact on make test time?
- Make more ES6 conformant

[DONE] TODO: think about lazy code gen, make new codument

[DONE] TODO: custom D assert handler
- Even more useful if no more interpreter
void setAssertHandler(errorHandlerType h);
alias AssertHandler = void function(string file, size_t line, string msg) nothrow;
throw new AssertError( msg, file, line );

[DONE] TODO: ask StackOverflow about 4GB executable alloc
- Want to guarantee 32 bit relative jumps always work
- Does any OS allocate the pages you don't touch?
=> yes, probably safe, but not clear that this is necessarily what we want
    how will our memory GC work?
=> limited to 2GB machine code, not that great anyways?
=> probably want to prefer 32-bit offset, but support 64-bit if needed?

[DONE] Monday meeting:
- Higgs roadmap
- Benchmarks using arrays
- Unifying theme for thesis
- Internship possibilities for the summer *****

[DONE] TODO: look at benchmarks using arrays
- How are the arrays used? Do we always loop over all elements
- Submethods mutating elements? ***
- SunSpider:
    spectral norm might work
    3d-cube, many matrix/vector ops, most not in a convenient form
        may be able to tag on creation, however
    3d-raytrace, has 3D vectors, but loops pre-unrolled
        could also test on creation and write
    fannkuch, integer arrays, but no clear "i < length"
    nsieve, boolean array, same problem
    cordic, float array, same problem
    crypto benchs use byte arrays
    string-base64 also has arrays of ints
- V8:
    crypto uses arrays with constants instead of .length for size
    navier-stokes, uses width, height which aren't array length
- Many benchmarks use arrays of integers and floats, especially in SunSpider
- Sensible way is to test when writing to array, not when reading

[DONE] TODO: think about unifying theme for thesis
- Lazy compilation?
- Versioning?
- Dynamic compilation? Dynamic languages need dynamic compilers
  - Versioning and laziness fit under this umbrella
- Dynamic, delayed compilation for better performances
- Many ways to be dynamic
- Argument why this is good

[DONE] Group meeting:
- Higgs refactorings
- Map system on the host side
- Created a dev branch
- Higgs roadmap

[DONE] TODO: new document, Higgs roadmap
- Lazy JIT plans
- Local profiling
- Inlining, should be more aggressive in hot code
- Type representation
- Interprocedural JIT
- Lazy prop? How to make this practical

[DONE] TODO: make print accept var arg, use $argc

[DONE] TODO: re-run ./benchmark after map introduction (on desktop)
is_i32: 4925933
is_const: 73248
exec time (ms): 1187
comp time (ms): 180
interp cycles: 535948
code size (bytes): 90032
is_rawptr: 28
call bailouts: 6
is_i64: 1
type tests: 7825131
unjit instrs: 55799
ret bailouts: 5
is_refptr: 297776
is_f64: 14666

[DONE] TODO: shootout/hash2, class capacity exceeded, should work now

[DONE] TODO: create dev-maxime branch

[DONE] TODO: rename ClassMap to ObjMap?

[DONE] FIXME: obj_get_map, need load_mapptr

[DONE] FIXME: segmentation fault
instr: ret $2 ($rt_arrtbl_alloc(14FF))
instr: $0 = map_num_props $8 ($rt_newArr(2B3C))
Segmentation fault (core dumped)

[DONE] FIXME: interp.interp.RunError: call to non-function
RegExp(AB62) ("stdlib/regexp.js"@864:1)
- Probably method lookup failing?

[DONE] TODO: GC must scan ctor map in closures

[DONE] TODO: new ctor map, set at new_clos time? Should be the same for all "new" operators
- Just lazily create in new

[DONE] TODO: $rt_getPropEnum
- Need way to get prop names, null if none?
$rt_class_get_prop_name => $ir_map_prop_name

[DONE] TODO: $rt_getPropIdx, IR instr should return false if not found

[DONE] TODO: $rt_class_get_num_props(classPtr) => $ir_map_num_props?

[DONE] TODO: look at link creation in ir/ast.d

[DONE] TODO: MAKE_CLASS, minNumProps, numRsvProps

[DONE] TODO: gc, when scanning IR, scan IRMapPtr, visitMap!

[DONE] TODO: interp/ops, make MAKE_CLOS, newArr, newObj use IRMapPtr instead of IRLinkIdx

[DONE] TODO: GC, when traversing object, visit map ptr, visitMap

[DONE] TODO: rework map creation in interp.d for newObj, global obj
- Add ref to mapRefs
- newMap(Interp interp)? getMap?

[DONE] TODO: remove map layout

[DONE] TODO: map accessor instructions
- Mostly just getPropIdx for now?

[DONE] TODO: gc support for maps
- mapRefs, liveMaps

[DONE] TODO: run ./benchmark before refactoring (desktop times)
is_i32: 4981024
is_const: 75589
exec time (ms): 955
comp time (ms): 220
interp cycles: 624630
code size (bytes): 102622
is_rawptr: 29
call bailouts: 6
is_i64: 1
type tests: 7884795
unjit instrs: 6746
ret bailouts: 5
is_refptr: 299946
is_f64: 14909

[DONE] TODO: MAKE_MAP instr
- Make classes host/VM objects
- CLASSPTR type tag
- needs caching, IRClassPtr

[DONE] TODO: implement class map

[DONE] TODO: can we eliminate setTarget with branch desc argument, have only block arg?

[DONE] TODO: IR, attach branch descs to branch instructions instead of pred blocks?
- examine use cases
  - grep -R "\.pred" .
- might need to rework remInstr, remBlock?

[DONE] TODO: remove type prop from master branch

[DONE] TODO: pull changes from cc2014 branch

[DONE] TODO: add music.js to lib/

------------------------------------------------------------------------------

[DONE] Oct 11th: CC Paper Submission Deadline
- 20 page limit, LNCS format

[DONE] TODO: create cc2014 branch on github
- put inlining limit very high, 50
- reduce min call frac

[DONE] TODO: typeProp improves upon versioning results on 3d-cube, why?
- Identify smaller benchmark where typeProp catches cases
./higgs --stats --jit_maxvers=50 --jit_typeprop
- bitops-nsieve-bits also
- beats us on phi nodes *** why???
Flow into self might be tricky?
- We can enter mid-loop... Have no type info
- Very little difference when enabling type prop over versioning in practice

------------------------------------------------------------------------------

[DONE] TODO: test --jit_typeprop with ./benchmark.py
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"
- Works, successfully reduces type tests

[DONE] TODO: use typeMap in IsTypeOp

[PASS] FIXME: programs/sunspider/crypto-aes
- Nondeterministic behavior, decryptedText.length varies between runs
- Does it work with --jit_disable? Same number of interp cycles, same string length?
- Nope!
- Problem with interpreter u16 load/store semantics?
  - Not load, check if store changes value
  - Store: value properly truncated, but u32 always different
- Why are the int32 values not always the same...
- Nondeterminism comes from usage of date, but length should be the same as V8...
- Faulty regexp implementation may be at fault, skip for now

[DONE] TODO: test typeProp with ./benchmark.py

[DONE] TODO: store typeMap on CodeGenCtx

[DONE] TODO: examine typeProp code, do transfer functions all make sense?
- Found one bug

[DONE] TODO: email Marc, notes:
- Added type test breakout by type
- Tried tweaking inlining heuristics to further reduce type tests, not very successful
- Began implementing intraprocedural representation analysis, based on SCCP
- Will add command-line flag to enable analysis

[DONE] TODO: test --jit_typeprop
./benchmark.py --higgs_cmd="./higgs --stats --jit_typeprop"
./benchmark.py --higgs_cmd="./higgs --stats --jit_maxvers=0 --jit_typeprop"

[DONE] TODO: add command-line option to enable type prop, --jit_typeprop

[DONE] TODO: complete type prop implementation

[DONE] TODO: document csv module, example

[DONE] TODO: begin work on intraprocedural representation analysis (SCCP)
- ir/typeprop.d
- Same type model as backend
- Must be able to gain info from type tests
- Fixed-point

[DONE] TODO: read_i8, read_i16, notify Tom
- Ask to use load_u32 for load_i32

[DONE] TODO: try inlining all the adds/subs/muls first
- 3d-raytrace is very sensitive to the inlining of arithmetic primitives
- Do it one-level only: make list of adds/subs/muls in CFG, inline them
- Does this reduce the number of type tests? Check effect with ./benchmark
- Before, growth factor 30x:
    is_i32: 2141245
    is_const: 20976
    exec time (ms): 1465
    comp time (ms): 402
    interp cycles: 1267749
    code size (bytes): 138314
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3717303
    unjit instrs: 5992
    ret bailouts: 8
    is_refptr: 291458
    is_f64: 10210
- After, growth factor 30x:
    is_i32: 2136726
    is_const: 20977
    exec time (ms): 1485
    comp time (ms): 425
    interp cycles: 1270943
    code size (bytes): 139407
    is_rawptr: 35
    call bailouts: 7
    is_i64: 1
    type tests: 3712645
    unjit instrs: 5997
    ret bailouts: 8
    is_refptr: 291435
    is_f64: 10199
- Doesn't do much!

[DONE] TODO: try smaller growth factor for just primitives, eg: 3x
- Still many type tests to eliminate
- Unfortunately doesn't help at all

[DONE] TODO: copy over Tachyon SCCP code into ir/typeprop.d, create bare module

[DONE] TODO: breakout of specific kinds of type tests with counts

[DONE] TODO: try scrapping min call frac heuristic
- See effect on global type tests, code size, exec time
- Before, budget 3x
    exec time (ms): 621
    comp time (ms): 133
    interp cycles: 675989
    code size (bytes): 108567
    call bailouts: 0
    type tests: 7957747
    unjit instrs: 0
    ret bailouts: 0
- Before, budget 40x
    exec time (ms): 880
    comp time (ms): 235
    interp cycles: 1270519
    code size (bytes): 142653
    call bailouts: 0
    type tests: 3540466
    unjit instrs: 5998
    ret bailouts: 0
- After, budget 3x, frac 50
    exec time (ms): 681
    comp time (ms): 142
    interp cycles: 662441
    code size (bytes): 109442
    call bailouts: 0
    type tests: 9063187
    unjit instrs: 7688
    ret bailouts: 0
- After, budget 10x, frac 50
    exec time (ms): 825
    comp time (ms): 249
    interp cycles: 879796
    code size (bytes): 133343
    call bailouts: 0
    type tests: 5866077
    unjit instrs: 8144
    ret bailouts: 0
- After, budget 40x, frac 50
    exec time (ms): 1091
    comp time (ms): 345
    interp cycles: 1240329
    code size (bytes): 153116
    call bailouts: 0
    type tests: 3693675
    unjit instrs: 6118
    ret bailouts: 0

[DONE] Meeting notes:
sort log_tests_3d_raytrace.txt | uniq -c | sort -n
- FP comparisons improved based on GCC
- Added CSV output to benchmarking script
  - For paper, command-line tools, latex csv package
- Discuss specific metrics to gather
  - currently: 
    - total generated code size
    - JIT compilation time (*JIT only*)
    - Total execution time including compilation
    - Number of type tests executed by the JIT
- Toutes les statistiques (incluant le temps d'exécution) devraient se faire
  mesurer lorsque le code s'est "stabilisé" (plus de nouvelles versions de BB).
  - Difficile a faire, invalidation de code pendant execution, somewhat incremental
- Dans l'article on pourra compléter avec des statistiques plus globales (incluant
  le temps de compilation, le temps passé dans l'interprète, etc).
  - I have usec counter, but lots of context-switching happens, won't be fully precise?
  - Could design timer mechanism based on state machine, events, count time in each state?
  - Could try using CPU cycle counter (but will include *some* OS context-switching noise
- Il ne faut pas perdre de vue qu'on doit découpler autant que possible l'étude
  du versionnement de BB de son implantation dans Higgs
  - Optimal case, compilation time is irrelevant?

[DONE] TODO: log JITTed type tests executed, examine what happens in 3d-raytrace
- needs inlining budget of ~20X to eliminate most type tests...
- can we annotate functions? how can we help this?
- can do JIT trace, see where types tested come from
- with 3x budget:
    3d-raytrace : is_i32 tests in rt_add and rt_lt
    3d-cube     : is_i32, is_f64 in add, lt, ge, some inlined in DrawLine
    earley-boyer: se, getProp, setProp, all uninlined
    still many calls to uninlined primitives
- with 40x budget: 
    3d-raytrace : is_i32, is_f64 Triangle.prototype.intersect, many getProp, still some rt_lt, rt_ns
    3d-cube     : almost all is_i32 and is_f64 in drawline. Why are these not all eliminated???
    earley-boyer: many in getProp, ns, some inlined

[DONE] TODO: benchmarking script, add cmd line options for higgs CMD, csv out file
- Keep default command
- Does Python have some option parsing module?

[DONE] TODO: look into CSV command-line tools
- transpose, concat, etc
- use python CSV package, program util fns

[DONE] TODO: look into CSV to latex tool
\documentclass{article}
\usepackage{csvsimple}
\begin{document}
\csvautotabular{scientists.csv}
\end{document}

[DONE] TODO: benchmarking script, generate CSV output

[DONE] TODO: get updated stats
exec time (ms): 1004
comp time (ms): 234
interp cycles: 675941
code size (bytes): 108613
call bailouts: 0
type tests: 7958803
unjit instrs: 0
ret bailouts: 0

[DONE] FIXME: growth factor issue, functions grow at every invalidation

[DONE] TODO: use "growth factor" based on initial size for inlining budget
- Special provision for small functions
- Allow 3x, shrinkage after peephole

[DONE] TODO: sort call sites by exec frequency for inlining
- Go through call sites, find most executed eligible call site
  - implement in separate function
  - could check caller and callee size at the same time
- Eliminates need for current min frequency heuristic
- Log performance before and after
- Keep minimum call threshold for inlining, useful for primitives

[DONE] TODO: threshold on block stubs before immediately invalidating
- Might save compilation time, allow for more useful profiling

[DONE] TODO: get mean exec times and type tests
exec time (ms): 1146
comp time (ms): 175
interp cycles: 801596
code size (bytes): 93926
call bailouts: 0
type tests: 7174455
unjit instrs: 7948
ret bailouts: 0

[DONE] TODO: benchmark script, geo mean of type tests, cut out decimals

[DONE] TODO: benchmarking script, display mean times (exec time (ms))

[DONE] TODO: stats, shorten names

[DONE] TODO: examine inlining decisions in bitwise-and, run with --nostdlib
- Way too many type tests!
- purportedly inlines rt_lt, rt_and, rt_add
- Need to look at ASM output
- The problem is that we're operating on global values!

[DONE] TODO: peephole opt for if_true of constant

[DONE] FIXME: 3d-raytrace segfaults with maxvers=0
./higgs --jit_maxvers=0 --jit_dumpinfo --stats programs/sunspider/3d-raytrace.js
- Crashes during GC, invalid ref?
  - Forwarding clearly integer or const value

[DONE] TODO: test nsieve-bits, 3d-cube, 3d-raytrace with maxvers=0

[DONE] FIXME: segfault with maxvers=1 on bitwise-and
./higgs --jit_maxvers=1 --stats programs/sunspider/bitops-bitwise-and.js
- crashes somewhere in stdlib?
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
Segmentation fault (core dumped)
num blocks: 20
num versions: 21
compiling function $rt_getPropObj(2D2F)
compiling block: entry(3305) (execCount=252)
compiling block: for_test(330C) (execCount=801)
block cap hit: 1
compiling block: for_body(330D) (execCount=801)
entering fn: $rt_getPropObj(2D2F) (for_test(330C))
for_test(330C) ($rt_getPropObj(2D2F))
if_true true => for_body(330D), for_exit(330F)
for_body(330D) ($rt_getPropObj(2D2F))
$2 = call_prim "$rt_obj_get_next", <fun:$rt_obj_get_next(12F8)>, $1 => call_cont(331F)
entry(336D) ($rt_obj_get_next(12F8))
$0 = load_refptr $5, 0
Segmentation fault (core dumped)
Note: we're entering getPropObj mid-loop, at for_test, and the block cap is hit...
- Take a look at ASM dump!
- When we jump from the exported entry point, we don't load anything into r10
- Probably because we don't treat entry points like block transitions ****

[DONE] TODO: implement cap on number of block versions
- Add command-line options, jit_maxvers=n
- If we request things like known phi types, will get mismatch
  - Once we reach the vers limit, compile general version, will match all
- General vers can have custom regs, but no known types and values
  - Strip pred map of known types and values

[DONE] FIXME: issue, function entry contexts have no locals, will give perfect match score?
- Should have penalty if pred map has more entries than succ map?
- Or maybe do another scan for pred maps, check for missing info in succ

[DONE] TODO: CodeGenState.diff(that), distance function
- returns size_t, size_t.max if incompatible, 0 if perfect match
- Sums up penalties

[DONE] TODO: implement get_link instruction in JIT
- pre unjitted ops, 3d-raytrace: 59713, 3d-cube: 104491

[DONE] TODO: implement floating-point comparison instructions
- 3d-raytrace, 3d-cube dominated by FP comparisons
- use UCOMISD instruction
- Pre-opt times, 3d-cube: 1796ms, 3d-raytrace: 2193ms
- Time not really improved

[DONE] TODO: genBoolOut

[DONE] TODO: release target with no asserts for performance testing
- the -release flag disables assertions

[DONE] FIXME: 3d-cube segfaults with lt_f64
- Do we need to use JB, JA, etc? with UCOMISD?

[DONE] TODO: get_arr_proto JIT instr

------------------------------------------------------------------------------

Goal: perf gains on loop increment microbenchmark 

[DONE] FIXME: earley-boyer segfaults when run on its own
$40 = add_i32 $18, 1
jump => arg_test(18645)
$0 = lt_i32 $18, $92
$19 = get_arg $18
Segmentation fault
sc_list(13F29)
0
sc_list(13F29)
139998753980417

[DONE] FIXME: JIT bug wrt call_prim, crash on stdlib init

[DONE] TODO: optimize calling primitives by name
- Time improvement on all benchmarks, code size reduced
- Number of type tests not always reduced

[DONE] TODO: Record new stats for 3d-cube, 3d-raytrace, earley-boyer

3d-cube:
total execution time (ms): 1948
total compilation time (ms): 563
machine code generated (bytes): 240666
type tests executed: 8724951
unjitted instructions executed: 346907
call bailouts executed: 0
return bailouts executed: 2626
interpreter cycles executed: 1569272

3d-raytrace:
total execution time (ms): 2844
total compilation time (ms): 968
machine code generated (bytes): 405845
type tests executed: 23950271
unjitted instructions executed: 192498
call bailouts executed: 0
return bailouts executed: 2544
interpreter cycles executed: 1106456

earley-boyer:
total execution time (ms): 5775
total compilation time (ms): 822
machine code generated (bytes): 354933
type tests executed: 24255101
unjitted instructions executed: 473302
call bailouts executed: 4143
return bailouts executed: 266451
interpreter cycles executed: 3638773

[DONE] TODO: add Marc's microbenchmark to repo
programs/jit/loop_decr_sum.js

[DONE] TODO: blog about inlining
- perf
- basic heuristics
- making inlining more selective
- many bugs in 300 lines of code
- testing with interpreter only
  - interpreter is robust, easier to debug
- benchmark loop incr to 500M with and without inlining

[DONE] TODO: phi of phi peephole opt
- pred has phi and then jump, succ has one phi which uses our phi
- make our incoming jump to succ, pass phi arguments directly
- big incr down to 3.2s, 409 bytes

[DONE] TODO: Redundant jump peephole
- Block ends in a jump, successor has no phi nodes, successor has only one incoming
- Might enable further phi elimination. 7 phis before. 7 after, but some opts!
- big incr down to 4.3s, 412 bytes

[DONE] FIXME:
mov rbp, [qword r14 + 200];             49 8B AE C8 00 00 00
mov [byte r13 + 23], 0;                 41 C6 45 17 00
mov [qword r14 + 184], 0;               49 C7 86 B8 00 00 00 00 00 00 00
Don't need to write the value 0 if we just wrote a non-pointer type tag
- Measure big_incr perf before and after
    5.9s    411 bytes
    5.1s    462 bytes

[DONE] TODO: add asm comment with function name for asm dump

[DONE] Meeting notes:
- Fixed many bugs, system now much more stable
- Inlining increases compilation time, but decreases execution time significantly
- Made inlining more selective
- Implemented static calls, significant performance gains
- Implemented propagation of known types through phi nodes
- Implemented OSR for top of stack functions mid-loop execution
- Enabled peephole opts mid-loop execution
- Tried loop to 2B, decreased type tests from 4B down to 1

[DONE] TODO: enable peephole opts mid-function?
- Need current target and liveness info
- Don't remove the current block (assert delBlock doesn't do this)
- Don't remove live phis or instrs (just skip?)
optIR(fun, IRBlock target)
- Don't delete the current target block
- Can't replace an instruction that's live by a value that's not live

[DONE] TODO: look at IR from big_incr, can we eliminate phi nodes easily?
- 7 phi nodes in total
- several possible improvements, worth looking into

[DONE] TODO: don't inline when compiling primitives? No!
- will make their compilation faster
- should result in better inlining overall
- do we have an isPrimitive, isRuntime test?
  - add method to IRFunction?
- What's the difference in compilation time?
- Performance is worse on every benchmark, even though comp time is smaller

[DONE] TODO: propagate types through phi nodes
- Could save type byte moves, generate better code in loop microbenchmark
- Reduced code size, reduced type tests on benchmarks
- Not much type test reduction on some benchmarks
  - Possibly, unjitted instructions are causing spills
- One type test executed in big incr (mid-loop entry), down from 4B

3d-cube:
total execution time (ms): 2223
total compilation time (ms): 599
machine code generated (bytes): 253236
type tests executed: 8998583
unjitted instructions executed: 344956
call bailouts executed: 0
return bailouts executed: 2426
interpreter cycles executed: 1820808

3d-raytrace:
total execution time (ms): 3052
total compilation time (ms): 909
machine code generated (bytes): 386667
type tests executed: 31909720
unjitted instructions executed: 190284
call bailouts executed: 0
return bailouts executed: 2494
interpreter cycles executed: 1310769

earley-boyer:
total execution time (ms): 6509
total compilation time (ms): 863
machine code generated (bytes): 362126
type tests executed: 32377182
unjitted instructions executed: 470606
call bailouts executed: 3725
return bailouts executed: 266251
interpreter cycles executed: 3885102

[DONE] TODO: modify IsTypeOp comparison + branch to add info to context?
- Loop microbenchmark does is_i32 twice, once for lt, once for add
- Could save 6 instructions in loop benchmark
- Pre-opt exec time : 8.45s
- Post-opt exec time: 6.78s
- Less type tests in 3d-cube and 3d-raytrace, but more code, slightly slower...

[DONE] TODO: look at code for the for loop test
- write this code in a JS file, programs/jit/big_incr_loop.js
time ./higgs --nostdlib --jit_dumpinfo --jit_dumpasm programs/jit/loop_big_incr.js
- phi nodes make optimization difficult... Should look at IR, try to enable peephole opts mid-exec?
- not passing type info through phi nodes, problematic for loop opt

[DONE] TODO: add comments for phi node moves... Hard to decipher as is

[DONE] FIXME: dumpir fails, segfault

[DONE] TODO: --jit_dumpir

[DONE] TODO: ASMInstr.nextNC?
- Modify peephole to ignore comments

[DONE] TODO: make inlining take advantage of static calls
- avoid placing conditional block when inlining call_prim

[DONE] TODO: implement call_prim in JIT
- funOnStack segfaults...
- only one call_prim occurs, to rt_lt, corrupts frame

[DONE] TODO: implement static calls for runtime primitives
- call_prim "str" ptr, cached IRFunPtr instruction
  - check that the function has no closure variables
- modify runtime call generation in ir/ast
  - call with IRFunPtr directly, no closure object

[DONE] TODO: optimize init loops in layout.js, use lt_i32, add_i32
- benchmark
- improves times of both 3d-cube and 3d-raytrace

[DONE] TODO: in collectFun, nullify instruction args, remove uses
- See if mem usage is improved, maybe a bit

[DONE] FIXME: sunspider/3d-cube segfaults
- Crashes just after rewriting the frame for MMulti
$5 = heap_alloc $23
$6 = get_global "$rt_arrtbl_set_cap", <idx:164>
$7 = get_global_obj
if_eq_fun $6, <fun:$rt_arrtbl_set_cap(1611)> => entry(100C2), call_reg(100CA)
$0 = get_global "$rt_arrtbl_ofs_cap", <idx:154>
$1 = get_global_obj
$27 = call $0, $1, $5 => call_cont(100C6)
ret 12
store_u32 $5, $27, $109
The offset is correct
The pointer is invalid
$5 gets corrupted?
- Bug in JIT heap_alloc implementation

[DONE] FIXME: jit crashes after inlining 
entering fn: $rt_obj_set_type(1301) (entry(3BD9))
- Store offset in store instruction is corrupted
- Need to zero-extend the offset

[DONE] FIXME: rework inlining to create return phi in special call merge block
Creating a return phi in a loop header is problematic. Can't know what the
initialization conditions should be for blocks that already have incoming branches

[DONE] FIXME: jit/jit.d(1186): no reg mapping for instr:
$26 = load_refptr $177, $52 (no uses)
./higgs --e "test()" --jit_dumpinfo programs/gc/graph.js
- peephole currently disabled when doing mid-execution OSR

[DONE] FIXME: top-level OSR faults after jit_inlining2
- op_set_str fails with refptr out of heap, odd!
  - possibly, a function was GCd, its link table entries collected?
- Possibly need to be careful when collecting link table entries
  - Should make sure they have no uses before removing them

[DONE] TODO: make load throw proper JS exception when failing to load file
- Test in interpreter
- Add test for this

[DONE] FIXME: top-level OSR segfaults 
- Could try again disabling JIT, letting interp run, problems will be more obvious
- ops.d(389): invalid operand 2 type in op "auto r = x * y;" (int32)
  - Log function where this occurs
- Phi value is not rewritten, skipped as dead
- Only 4 values written, none overwritten
- Log the values we're rewriting, to see if they make any sense
  - Values appear sensible
- PROBLEM: when at target, we already made the jump, we're *past* the phi nodes
  - Must check liveness after the phi nodes
- Still have an issue in 3d-raytrace
  rewriting frame for Array(5EE4) at for_test(E893)
  - Newly created array value is not rewritten
  - Array value not marked live after first block instr?
The $rt_newArr call was inlined
$20 = phi [call_reg(120B1):0 => $51, call_cont(120AE):0 => $50]
$20 is used in the loop body
$20 is returned
But somehow we don't see $20 as live at the for_test block
Do we even query for $20? Probably not... $20 was live before the
transformation, but isn't anymore!
Still a problem... We've created a phi node for the array (return phi), but
this phi node was not executed because it didn't exist!
Would need to check, for live values being rewritten, which ones are inputs to
phi nodes from our block, and the phi node wasn't rewritten (is new)
- Catches the case where we have a new phi node
- Idea is: I have a value that is live, does it go into some phi node that is
  also live here?
- Try this and see if it works in practice...
Do we actually want liveness info from before inlining? ***
Could we be in some situation where some phi node needed to have been executed
way back, because of some other inlining? The value was replaced by a phi node? ***
- Seems like we could
- Can detect what phi nodes are newly live, see which of their inputs were live previously
  - If multiple inputs were previously live???
  - In the case of inlining, might be impossible that multiple inputs were previously live,
    because the inlined case didn't exist
- store mapping of call sites to ret phi nodes, process phi nodes based on
post-inlining liveness info

[DONE] FIXME: inlining should not create return phi if there are no uses of the call site

[DONE] TODO: implement top-level OSR mid-function
- Save current stack frame into temp arrays
- Redo liveness info if necessary
- Pay attention to liveness and IP when doing peephole
  - For first version, probably shouldn't do peephole in this case

[DONE] TODO: IRBlock.moveInstr(dst)
- Want to maintain instruction identity when possible
- Stack frame translation post inlining will be problematic otherwise
- remove/unlink from current block
- add/relink in new block
  - update instr.block
- if branch, change descs to point from current block, replace old block in preds

[DONE] FIXME: sunspider/string-base64, jit/jit.d(1073): no reg mapping for instr:
$25 = and_i32 $1, -8
- Is this instr not used, is it from the wrong function?

[DONE] TODO: revise Higgs page on pointersgonewild
- add new supported benchs
- remove runtime redefinable prims as language feature

[DONE] TODO: IRValue.addUse if use is dstval, check that from same fn
- Put in assert or debug block

[DONE] TODO: enable JIT pathos test

[DONE] TODO: alloc state cleanup code
- After each instr, should check if its uses are now dead, if so, remove all
type and alloc info. For branches, should pass branch instr to the 
genBranchEdge function, this function should cleanup any uses of the
branch instruction itself.
- cleanup fn should just remove output type of instrs if immediately dead ***
- May want to add liveAtEntry and other helpful functions to liveness info class.

Meeting notes:
- Inlining bugs fixed, now fully working with JIT
- Found some language shootout benchmarks
- With inlining, compilation time is much longer, but benchmarks still faster
- More selective inlining, less useless inlinings
  - Faster compile time, less machine code generated, better execution time
- Pathological case, now we inline more useful code, but seem to get exponential blowup
- Probably need block version cap

[PASS] FIXME: function: safe_add(EF0C)
machine code bytes: 2798357
num locals: 108
num blocks: 106
num versions: 35294
- Doesn't even contain a loop, unclear why so many versions
  - Might have a string op in there?
  - No for_ blocks or obvious loop blocks
- In less bloated case, 10 versions of call_cont(FF89)
  - Are these legitimately different? Probably so
- Try to design a pathological case? Add of add of add...?

[DONE] TODO: make inlining more selective
- Don't inline calls with relatively small execution frequency
- Favor inlining of more likely calls
- Log data first to get an idea of call site ratios when inlining
  - Scheme seems to very much make sense
  - Place threshold at 1/3?
  - const CALL_MIN_FRAC = 3
- 3d-cube (pre)
    total execution time (ms): 2551
    total compilation time (ms): 737
    machine code generated (bytes): 338787
- 3d-raytrace (pre)
    total execution time (ms): 3839
    total compilation time (ms): 1230
    machine code generated (bytes): 571490
- Small but significant improvement on all factors

[DONE] TODO: handling of parsing new without parens
- Should enable 2 shootout benchmarks

[DONE] FIXME: inline test is wrong
- not testing the type of the callee value
- not testing that it's a function object
- should make special callee check comparison?
  - problem is, need multiple comparisons
- if_eq_fun <clos> <IRFunPtr>

[DONE] FIXME:
Tom: try importing the stdio lib
Tom: interp/ops.d(626): ref ptr not in from space in load op

[DONE] TODO: add shootout benchmarks to tests
- set arguments[0] before running each one

[DONE] FIXME: unit function arguments handling
- arguments should refer to the global variable, not the arguments object

[DONE] FIXME: regular JIT call doesn't check that callee is a function
- enable jit_call_exc test
- try to pass test with --jit_noinline first

[DONE] TODO: make JIT regression test that catches exceptions, change callee
- call instr should throw an exception if the callee is not valid

[DONE] TODO: re-enable IR opts after inlining

[DONE] FIXME: inlining bug, we replace uses of the call by uses of a phi node in
call_ret. This is incorrect. Must take the value of the call from call_reg
into account.
- Add the ret phi node to call_cont directly, as before.
- Add a value to ret phi from call_reg as well (the new call site).
- Add new phi arguments at inlined rets to *all phis*
  - if arg was call site, replace by ret value
- Need to do replacement of call site uses manually before inlining?
  - skip phis in the call cont block?
  - could replace all, then go over call con't block and replace by new call instr?
- There may be existing preds to the call_cont
  - ret phi should have incoming values for these too

[DONE] TODO: basic const prop for mul_i32
$2 = mul_i32 1, $10
$0 = mul_i32 2, 6
- inlining makes opportunities appear

[DONE] TODO: write adversarial JIT test where inlined call gets changed, new call
returns something different

[DONE] FIXME: 
sunspider/crypto-md5
global property "error" is not defined
programs_sunspider_crypto_md5_js(23C306) ("programs/sunspider/crypto-md5.js"@1:1)
- no GC
- make regression test
- str concat seems to be broken
  - try making JIT strcat test? replicates the problem
- something in strcat is broken (by the JIT) after inlining?
  - first bytes written are zeros
- We compile theAdd, and then our loop fails to execute... i remains undefined
  - Maybe it was never initialized to zero? Set to undef on some path?
- Still have bug in inlineCall wrt phi nodes in call cont block

[DONE] FIXME: Inlining, a stub is produced for call_ret... Give call_ret the same
execCount as the call continuation
- function gets invalidated every time a call_ret is hit!

[DONE] FIXME: assembler.d(395): invalid instruction: imul r10d, 0;
- Inlining now working with interpreter only

[DONE] TODO: in debug mode, try encoding instructions immediately when added to assembler
- X86Instr.isValid()

[DONE] FIXME: inlining causes GC crash?
./higgs --e "test()" programs/gc/strcat.js
visiting frame for: $rt_str_alloc(11BA)
- top stack frame, we get to a value tagged INSPTR, seg fault
- ra slot is 32, but the insptr is found at 21
- many functions just inlined into rt_str_alloc
- instr.block is null...
  - must have been an old call site, now inlined

[DONE] FIXME: es5_comparisons, 4 >= 34 ==> false (expected true)
inlining $rt_refIsLayout(2B6A) into $rt_valIsString(2B7A)
inlining $rt_obj_get_header(12A2) into $rt_valIsString(2B7A)
- problem: replacing call uses by ret phi, but uses can be phi in call continuation!
- can't directly put the ret phi in the call continuation, needs its own block

[DONE] TODO: if no inlining happened, don't re-allocate stack slots

[DONE] FIXME: missing phi argument for:
$87 = phi [, call_reg(EBA3):0 => $295, call_cont(EB9F):0 => undefined]
in block:
if_join(E83B):

[DONE] FIXME: nsieve-bits segfaults
- Try logging executed instructions again
- Inlining itself fails for $rt_valIsString(2B7A) into $rt_setProp(2D02)

[DONE] FIXME: copying eliminates phi args

[DONE] FIXME: phi node is missing arg from one branch post inlining
- missing phi arg from call_reg

[DONE] TODO: rework inlinePass
- KISS, top of stack replacement only for when at call entry

[DONE] TODO: add interpreter cycle count, add to stats?
- move stats out of jit namespace?
- --stats option

[DONE] TODO: refactor inlining function

[DONE] TODO: implement heap_alloc in JIT?
- interp.allocPtr + size > interp.heapLimit
- if past heap limit, bailout
- increment interp.allocPtr
- align interp.allocPtr
  - align: +7 & -8
  - + (ptrSize - 1) & -ptrSize
  - drops the low 3 bits
- if the size is a multiple of ptr size, no need to align :)
- fasta unjitted instrs, 541366 vs 853500
  - but not much faster!

[DONE] TODO: better JIT ret handling for too few or too many args in call & ret
- Special handling branches should go out of line, return to main line
- ret bailouts
    3d-raytrace     3.3K    2.4K
    string-fasta    4.8K    0
    earley-boyer    271K    266K

[DONE] TODO: think about different inlining strategies
- Can create new IRFunction & replace in closures, but...
  - Still need to mutate an IRFunction during inlining
- Current scheme might still be best
- Can simplify for now by avoiding top of stack replacement, gets most gains

[DONE] FIXME: bug in earley-boyer
core.exception.AssertError@ir/ast.d(162): cannot add instr:
jump
current block already has final branch:
call_cont(1BC38):
  ret t_1BC37
in function "anon(1AECE)"
./higgs(void ir.ast.stmtToIR(ir.ast.IRGenCtx, parser.ast.ASTStmt)+0x1181) [0x575dfd]
./higgs(void ir.ast.switchToIR(ir.ast.IRGenCtx, parser.ast.SwitchStmt)+0x3a2) [0x5768be]

[DONE] TODO: jit.stats, total size of machine code generated

[DONE] FIXME: bug with 3d-raytrace introduced by stack slot opt
- only happens in context of make test
- crashes while during GC, while visiting stack roots
    forwarding object 3 (false)
- Probably, stack slot gets corrupted somewhere in the JIT
- A single phi node is producing this value ***
  - Uses values from a call and from another phi ($30)
  - $30 was already forwarded
$119 word: 3
$119 type: INT32
$30 word: 47386518933928
$30 type: REFPTR
Type comes from $30...
Value comes from $119
On path from $119 (call cont), phi is assigned to r11
REFPTR type is written to the stack
On path from $30, phi is also assigned to r11
When doing GC deep down the stack, need to have spilled r11
May not ever spill this phi node if it isn't live after the call ***
This is a peculiar situation... Type is on the stack but value is in a reg

[DONE] TODO: all instrs whose value is not used can share one stack slot

[DONE] TODO: get_arg for V8/raytrace
- 782K unjitted, 3.3s
- 620K unjitted, 3.2s
- still many many ret bailouts

[DONE] TODO: blog
- JIT complete, now with SSA
- Difficulties encountered, phi nodes, reg alloc bugs, call/ret bugs
- For now reg alloc simple
- Better code quality, speedups (table?)
- Higgs would ideally need fuzz testing

[DONE] TODO: StoreOp
- 3d-raytrace at 2.4s
- V8 raytrace now fast enough

[DONE] TODO: add call bailout and ret bailout JIT stat, try on string-fasta
- 3d-cube and 3d-raytrace have a few thousand ret bailouts
  - wasting time in the interpreter
- string-fasta has about 4K ret bailouts only
  - might still amount to a lot of time in the interpreter

[DONE] FIXME: some kind of phi node bug in $rt_getPropIdx
- once mod_i32 introduced, value gets de-incremented?
- spilling a register, but the value is mapped to the stack
  - mapping of reg to values got broken
- bug when phi node reg is in use by said phi node

[DONE] TODO: mod_i32 op
- 3d-raytrace unjitted ops down to 7.1M, string-fasta down to 17.9M

[DONE] TODO: gen_call, accept type imm

[DONE] TODO: how many unjitted instrs in string-fasta?
- about 28M
- does a lot of ret bailout, probably most of the problem

[DONE] FIXME: string-fasta segfaults at the end?
- No call or ret bailout
- global v is not the corrupted value...
- something gets written at the wrong position?
- what if our type tag gets written in the wrong place?
- bug in set_global implementation

[DONE] TODO: check ref ptr values stored in interp StoreOp

[DONE] TODO: void checkVal(Assembler as, X86Opnd wordOpnd, X86Opnd typeOpnd, string errorStr)
- use CMP to check value, jump to final label if OK, otherwise print errorStr
- use this in set_global to try and find when problems happen

[DONE] TODO: implement get_word, get_type
- 3d-raytrace now 8.0M unjitted

[DONE] TODO: implement set_value
- originally 9.25M unjitted instrs, 3.6s
- now 8.2M unjitted instrs

[DONE] TODO: logging of default JIT ops using ctx.as.printStr, test on 3d-raytrace, string-fasta
- lots of store(s)
- $2 = get_type missing
- $0 = set_value $20, $21
- $2 = get_word $29
- lots of mod_i32

[DONE] TODO: stat counter for number unjitted instructions executed
- 9.5M for raytrace, probably dominates execution time!

[DONE] TODO: dynamic type tests, incr counter only if jit_stats enabled

[DONE] TODO: exec time stat? record start time in static ctor
- Could we log stats in static dtor???

[DONE] TODO: can we compute comp time using microsecs to make more accurate?
- 3d-raytrace, 327ms out of 3675ms

[DONE] TODO: jit.stats, stats.compTimeMS
- What is the comp time for 3d-raytrace? 304ms out of 3800ms

[DONE] TODO: optimize non-constant comparison followed by if_true
- cmp can check that if instruction follows and is the only use
- if can check that cmp instruction precedes
- could possibly directly check the last ASM instruction?
- time benchmarks before if opt, best of 5
3d-cube             1.75    1.65
3d-raytrace         3.84    3.5
bitops-nsieve-bits  1.14    1.12
access-fannkuch     2.32    2.28

[DONE] TODO: improve cmp + if_true
- can generate bool and then cmp independently
- must modify ifTrueNext
- generate bool if we have more than one use or no if_true follows
- generate the if_true if one immediately follows

[DONE] FIXME: segfault after if opt.
- Problem is not with single use
- using for only IsTypeOp seems to work
- two versions of a null comparison, one fails?
- Problem is, for comparison, we can only do do cmp in the comparison operator...
  - Might need an implementation of if_true to which we can supply our own comparison operators...
  - if_true just calls implementation if bool arg doesn't immediately precede
- need void genCondBranch(trueOp, falseOp)

[DONE] FIXME: assembler fixed point goes into infinite loop...
- Computed jump offset can be wrong
- If jump instr becomes shorter, label offset is no longer accurate in current pass
- May recompute offset and get wrong answer because label position is no longer valid

[DONE] TODO: boolArgPrev
- Can avoid comparing against true val if cmp already done!
- most often true, but not always, sometimes because of phi

[DONE] TODO: implement ifUseNext(IRInstr) for IsTypeOp and CmpOp
- log occurrence: 80 to 90% true

[DONE] TODO: implement more opts in JIT, target defaults of slower benchmarks
- i32_to_f64? already commented out
- 3d-raytrace time?

------------------------------------------------------------------------------

[DONE] FIXME: error in v8/richards
- also issue with call bailout

[DONE] FIXME: segfault in v8/deltablue
- when fixed, enable in unit tests
- does this fix other segfaults?
- crashes somewhere in the plan execution
- modifying Plan.prototype.execute causes it to work properly
- get the IR string for this function?
  - just one phi node for the loop increment
  - mostly function calls
entering fn: Plan_prototype_execute(F529) (for_test(F642))
Segmentation fault
The call to c.execute crashes
Call bailout happens in this function just before the crash!
- Forgot to put loadVal=false in all getWordOpnd calls

[DONE] TODO: JIT currently checks if call instr has out slot, do we still have
situations where we don't allocate an out slot to call? test it

[DONE] TODO: cleanup call cont generation code
- add ctx.genCallCont function
- remove getEntryPoint from there

[DONE] FIXME: bug with sunspider/3d-cube, mov xmm0, 0;
- How do we load an immediate into XMM?

[DONE] TODO: re-benchmark and re-enable more sunspider/v8 tests

[DONE] TODO: getTypeOpnd in gen_ret should have acceptImm = true

[DONE] TODO: valToString should validate ref pointers
- core.memory.query, returns null if invalid pointer

[DONE] FIXME: bug in stackvm with ret enabled
- doesn't happen with interp ret only
  - much less JIT execution
- Does it crash when run on its own? Yes
- Does it crash if we disable GC? Yes, after a few runs (enough for JIT?)
- Try disabling specific ops, like load?
./higgs --nostdlib programs/regress/jit_ctor.js
- segfaults with object ctor call, adding property, returning new object
- many conditions need to occur
- Disabling load fixes the segfault...
  - Enabling just load_u32 makes it happen
    - 5 instances
  - pointers and offsets passed seem valid
  - doesn't seem like the load itself is causing the segfault
- Load code seems correct, try disabling other ops
- Bug in ret bailout code, state doesn't match entry state
  - need to set loadVal=false in getWordOpnd

[DONE] FIXME: jit ret causes infinite loop in stdlib, setPropObj
- Not caused by phi nodes
- Return value somehow not set?
  - interp and jit ret should be doing the same wrt return value
- Seems we get a loop with always the same next pointer returned
  - but the return code seems correct
- The situation we have occurs with a loop... The loop definitely has phi nodes
- Seems we really have an object with itself as next value
- Disabling ret makes it work
  - disabling jit ret doesn't fix it
  - disabling jit call cont generation doesn't fix it
- must be a phi node issue with the interpreter
- wspReg, tspReg not set in interpreter before interp.branch

[DONE] FIXME: jit entry point should be executing the phi moves...
- interp entry point doesn't execute moves, because the interpreter
  already executed them in the branch() function
- Could put a special pointer on the call instruction
- genBranchEdge to generate the phi nodes?
  - need to use stack entry state
- store association between label and call instr
- at the end of compFun, write the pointer
    ctx.genBranchEdge(
        ctx.ol,
        new Label("cont_branch"),
        instr.getTarget(0), 
        new CodeGenState(fun)
    );
- fixup gen_ret to use jitCont
- also make the branch edge exported
- add jitCont pointer on IRInstr

[DONE] FIXME: printStr is broken

[DONE] TODO: reimplement ret instruction in JIT
- need to fix jump(reg) to work branch desc
- move code into ret, it's the only usage

[DONE] FIXME: es5 comparisons, 2 !== 2 ==> false (expected undefined)
- undefined, wrong value extracted from array?
- try prop read loop in REPL?
- try disabling comparisons?
- make small regression test again
- test passes when JIT comparison ops disabled
  - fails if eq_i8 enabled

[DONE] FIXME: segfault once JIT call is enabled
make; ./higgs --nostdlib --jit_dumpinfo programs/sunspider/bitops-bitwise-and.js 
- segfaults if using interp call
- no segfault if interp call and no call continuation
- no segfault with JIT call and no call continuation
- still segfaults with stdlib enabled
  - after $rt_obj_get_cap compiled?
  - disabling JIT load ops seems to fix this
  - wrong reg used in load

[DONE] TODO: debug mode tests in load ops

[DONE] TODO: reimplement call instruction in JIT
- might cause load ops to be triggered, bugs to pop up, we shall see!

[DONE] FIXME: get_global, set_global, cannot allocate IR value for constant

[DONE] TODO: fixup load ops in JIT
- Also improve codegen wrt imm

[DONE] TODO: set_global, get_global

[DONE] TODO: asm peepholes, eliminate jump after jump

[DONE] TODO: re-enable JIT-specific unit tests

[DONE] TODO: reimplement basic arith

[DONE] TODO: reimplement eq instructions

[DONE] FIXME: CmpOp causes malfunction?
- Causes some values to be loaded from the stack...
- Neither $rt_se nor $rt_toBool have phi nodes, so this is probably not the issue
- Seems we get issues when using EDI as our output reg?
- Not obvious at all what's wrong
- Issue is with CmpOp not writing the upper 32 bits of memory words
- Fixed if_true implementation in interpreter

[DONE] TODO: copy es5_cmp, simplify until bug disappears, regress_cmp
- use --nostdlib to minimize interference
  - no JIT usage
- only one instance of eq_i32, in $rt_se

[DONE] TODO: check that phi nodes aren't getting the same register in succState

[DONE] TODO: reimplement if_true instruction

[DONE] FIXME: interp.d(538): ref ptr out of heap
- es5_cmp benchmark, many ifs
- no gc
- phi moves are involved
- Check if if_true code is correct...
  - all cases are exerted
- Log if cycles occur
  - no cycles
  - several mem-mem moves, type info
  - few moves, moves seem normal
- if args are all regs
  - two of the args are phis
  - are we loading them properly?
  - mapping all phis to stack doesn't fix the problem
./higgs --e "test()" --jit_dumpasm programs/es5_cmp/es5_cmp.js 
entering fn: $rt_valIsString(2B7A) (entry(32C2))
- disabling IsType ops seems to fix the problem
- test in more detail what in IsTypeOp causes an issue
- Bug in loading from mem to reg, not loading all the bits
- Also bug in getTypeOpnd

[DONE] TODO: reimplement jump instruction

[DONE] FIXME: mov r12l, [qword r14];
- 8-bit dst? wtf?
- getWordOpnd mem opnd wrong

[DONE] FIXME: getTransLabel, can't just insert instructions immediately!
- Might be called at various points inside an instruction
  - branch instructions only, at end of blocks
- Need to wait until end of current instruction
- can queue until end of current block
- What if we supplied a label to getTransLabel?
  - Call genBranchEdge at the end

[DONE] TODO: fix execMoves wrt tmp reg size
- add sanity checks, ie: no move into imm

[DONE] TODO: X86Reg.ofSize

[DONE] TODO: block transitions, state transition handling
- getTarget, need to generate code
- Need mechanism to handle block transitions w.r.t. phi nodes
  - "Execute" the phi assignment at the beginning of that block
  - Update state to reflect which phi nodes are in slots or regs
  - Insert moves as appropriate
  - May have cycles between phi node moves

[DONE] TODO: fix getWordOpnd
- used once in SpillRegs
- used by block trandition!
- need to be able to prevent load
- comment out current implementation and try reimplementing?
- getCurOpnd sub-function?

[DONE] TODO: fix getOutOpnd

[DONE] TODO: reimplement is_i32 instruction, IsTypeOp

[DONE] TODO: fix getOutOpnd

[DONE] FIXME: getEntryPoint, interp already executed phi nodes
- Doesn't make sense to generate new phi node mapping
  - phi nodes should remain on the stack as they were
- Could add a "noLoadPhi" arg. Simple enough

[DONE] TODO: fix getTypeOpnd

[DONE] FIXME: don't want to need interp pointer to evaluate constants
- could make static interp method, callable with interp or null

[DONE] TODO: re-enable jit call in interpreter
- get jit working with defaultFn only
- no branch handling for now, bailout to interpreter pre-branch

[DONE] TODO: fix defaultFn

[DONE] TODO: implement IRInstr.hasArg(IRValue)

[DONE] TODO: fix spillRegs calls

[DONE] TODO: fix spillRegs implementation
- if something is dead, delete it from the map, no more RA_DEAD

[DONE] TODO: replace liveSets by liveQueryFn

[DONE] FIXME: Object.keys({length : 1}).length == 0
keys there should give ["length"] but instead you get []
- Test in REPL
- Add object unit test

[DONE] TODO: make register mapping use values instead of local indices

[DONE] TODO: move list execution function
- uses one temp reg
- algorithm:
  - Identity moves are removed
  - If no moves don't overwrite an src, take pair (A->B) and remove from list,
    move A into tmp, add (tmp->B) to list
  - Pretty simple iterative algorithm!

[DONE] TODO: dumb register allocator
- need to test our ideas first, quality reg alloc is not on the critical path

[PASS] TODO: smarter slot/register mapping pass, jit/regalloc.d
- Only map registers for now, later map both slots and regs
- Ideally, slot/reg allocation assigns vals and phi nodes to same slot/reg
  - Provided they don't interfere
- Ideally, values that share a phi target end up in same register
- Should do phis first, values after?
- Should produce mapping of values to slots, allows remapping stack frames
  - Don't compute liveness just for interp, that's expensive
- Map instr to first slot that's not already mapped to an interfering value
  - Grow num slots as needed

[DONE] TODO: how often are phis live/interfering with their non-const arguments?
- compute stats in astToIR to get this info
- Liveness... Do we need more info?
  - Can manually test if used by a phi node if necessary
  - When checking if phi interferes with arg... Doesn't matter if val is live
    while phis are being assigned into if the val isn't live after
- Phis and args do sometimes interfere but most of the time not ***

[DONE] FIXME: live vars queries with instr from block that isn't in the function anymore?
- instr.block.fun is null (so block was removed from function?)
- we got this instr from a phi argument
- normally, incoming branch should have been removed
- PROBLEM: if instr had been removed, its block would be null...
- delBlock in peephole.d causes this to happen
  - only deleting dead blocks... removing incoming to other blocks
  - our instructions should have null block
- the instruction is still the valid last instr in the block!
- block was deleted, should have no instrs...

[DONE] TODO: jump to if_true of phi opt pattern
- Occurs in $rt_add
- pred can potentially be made to do if instead of jump
- succ must have just this one phi, which feeds into the if
- down from 6 to 2 phis in $rt_add!

[DONE] TODO: fixup liveness analysis to work with SSA
- better liveness data structure?
- could have dead/kill points for values?
  - if no uses, immediately dead
  - can die on branches

[DONE] TODO: read SSA liveness PDF
- Should really use bit sets for liveness if possible
- Could we produce live sets as query-able closures? ***
  - Internally store bit set(s), instr to id mapping
  - Probably not that inefficient
  - If each instr has a bit set, could allocate quadratic storage contiguously
    - Instrs/phis with no uses get no entry
    - Can log biggest table size for ease
- Paper says "variable by variable approach" performs best, read section 5

[DONE] TODO: fix loop bug w.r.t. loop vars and continue

[DONE] TODO: remove dead instrs peephole
- hasNoUses, !opcode.isImpure, !opcode.isBranch
- Actually very few dead instrs, probably a good thing

[DONE] TODO: $nullptr
- add unit test for typeof $nullptr, typeof $argc

[DONE] TODO: in ir/ast.d, flip ctx arg to be first in *toIR functions

[DONE] FIXME: null owner block for phi use
- phi node is not attached to a block
- have phi node use that was deleted, but not properly unregistered
- PROBABLE: we make a block dead, and it has arguments to some phi
  - branch is removed, but phi args never removed
  - remIncoming should unregister all associated phi args

[DONE] TODO: jump to jump peephole opt
- block with only branch instr, no phi nodes

[DONE] FIXME: jump to jump peephole doesn't seem to work when done with call
and phi args are allowed...
- ret instr in interpreter seems capable of handling phi args...
- Need to set ret val before executing phis!

[DONE] TODO: int32 add const prop peephole opt

[DONE] TODO: fixup FFI
- extract args into buffer

[DONE] TODO: basic IR peephole pass
- look at irString for primitives, add, getProp, etc before and after
- opts:
  - phi node opts
  - dead blocks
- See if interp performance changes much
bitwise-and     7.24    6.8-7.1
nsieve-bits     77.6    69

[DONE] FIXME: GC bug after phi replacement, gc/closures
- ops.d(613): pointer is not pointer type in load op
- new_clos triggers the collection
  - clos allocation itself triggers collection
- crashes in $rt_cell_get_word, inside of closure code
- cell pointer set to wrong value? or maybe in wrong closure?
  - very unlikely
  - we are calling the right closure object
- cell pointer we got from closure (clos ptr arg to call) is wrong?
- final get seems to be what fails...
  - adding prints in test function or getCellVal seems to make this issue go away
- As soon as the GC executes, tsp[3] becomes corrupted. How is this possible?
- GC corrupts type stack when zeroing it out using wrong pointer type!

[DONE] FIXME: phi moves don't swap properly... would have to all be simultaneous
- could load all arg values into a temp vector, then copy temp vector?
- preallocate temp vector for phi, calls in interp, not that inefficient!
- eliminate alloca

[DONE] FIXME: phi uses deleted phi
- removing "first use", but firstUse is null... val already deleted?
  - could we be marked as a use of ourself? should not be an issue?
- Can't just destroy phi nodes or instrs when removing block
  - May have other (dead, uncollected) uses still referencing them

[DONE] FIXME: removing phi nodes always results in a seg fault? why?
- printing some instr fails while printing args...

[DONE] TODO: get jit.d compiling with JIT disabled

How should the SSA JIT work?
- Moves may need to be generated for some phi nodes, when jumping to a block
  - getTarget may need to take pred into account, generate stub of moves
- Current state: whether each value is in its register or slot
- Will need a way to request an argument as a register
  - If it's a constant, we need to supply a temp
- If I have some phi incoming in a slot, and I branch to a block, I'll be
  redefining this phi node, hence the state I branch to should have that phi
  also in a slot, if they're the same ***
- Maybe the JIT shouldn't make phi nodes have fixed slots?
  - This only matters if phi incomings and phi nodes often interfere ***
    - Must compute this stat to inform our decision

------------------------------------------------------------------------------

July 15th goal: complete AST->IR and interpreter refactoring

[DONE] TODO: rebase main branch onto SSA

[DONE] TODO: fixup GC
- Try enabling GC tests in steps

[DONE] TODO: grep for FIXME

[DONE] TODO: exceptions, try-catch-finally
- Finally execution
- Try/catch/finally, context merging
- Throw, throw ctx lst? See Tachyon
- genExcPath needs to be altered

[DONE] FIXME: trying to add instr after call to rt_add
- Seems to be caused by englobing try block... genExcPath?

[DONE] TODO: for-in loop
- crash, first call to enumerator fails

[DONE] TODO: arguments object

[DONE] TODO: call_apply

[DONE] FIXME: "programs/basic_assign/basic_assign.js" produces 20

[DONE] TODO: new operator

[DONE] TODO: switch statement
- Needed to load stdlib
- Look at Tachyon code

[DONE] TODO: array literal support

[DONE] TODO: object literal support
- Should enable many more tests

[DONE] TODO: delete operator
- Signal 11 on delete of global

[DONE] FIXME: $rt_toString(5), ir.d(932): phi node is not attached to a block
- Replacing value by unattached phi node????
- Problem: replacing uses of phi but, phi may be in context already
- Shouldn't be doing this during code gen... Need separate opt phase

[DONE] TODO: typeof operator
- Has its own unittest section

[DONE] TODO: for loop

[DONE] TODO: do-while loop

[DONE] TODO: compare Tachyon and Higgs WhileStmt versions
- Possible improvements for clarity/simplicity? Refactor now
- createLoopEntry? look at Tachyon usages, do we always register labels?

[DONE] TODO: get simple while loop with phi nodes working
- can now test this with --nostdlib --e "..."

[DONE] FIXME: break/cont target should have both ctxList and IRBlock
- enable some loop tests

[DONE] TODO: operator ++

[DONE] FIXME: signal 11 at ret in basic tests
  call_cont(26473):
    $0 = or_i32 $5, $8
    ret $0
- phi node assigns into RA!

[DONE] TODO: --nostdlib option?

[DONE] TODO: log branch target idx in phi toString

[DONE] TODO: if you do remPhi, should remove args for that phi node
- BranchDesc.remPhiArg(PhiNode phi)

[PASS] FIXME: phi nodes with 0 or 1 input
- seems valid for now...

[DONE] TODO: test if 1 + 1 (runtime, arith ovf) is working
- Missing if statement support

[DONE] FIXME: visible argument slots wrongly assigned?

[DONE] FIXME: phi node toString doesn't show any incoming values
- desc.args.length: 0

[DONE] FIXME: newlines in IR listing

[DONE] TODO: ternary expression

[DONE] FIXME: r/ast.d(1854): variable declaration not in local map: "x"
- x is a parameter to $rt_add
- local map length: 0

[DONE] TODO: && operator

[DONE] TODO: if statement

[DONE] TODO: jump with branch descriptor, handle phi nodes
- interp.getValue(IRValue val)
- interp.branch(BranchDesc branch)

[DONE] TODO: set_str

[DONE] TODO: set_undef... Do we want to implement a $undef and $missing?
- Like $argc

[DONE] TODO: new_clos, needed by runtime lib

[DONE] TODO: get set_global, get_global working
- Needed for even basic runtime
- x = 1; return x;

[DONE] TODO: get basic "1", "ir_add_i32" working in interpreter

[DONE] TODO: getArgVal

[DONE] TODO: add loadRuntime option to interpreter

[DONE] TODO: make callFun interp method

[DONE] FIXME: temps are not per-block

[DONE] TODO: implement simple stack slot assignment pass
- should be called at end of astToIR
- ir/slotalloc.d, allocSlots(IRFunction)
- instrs with single uses *in the same block* interfere with other from block
  - these are "bounded" temps (same block bound)
  - each get a slot from tempSlots
- instrs in the other category interfere with everything
  - each get their own slot from varSlots
- for now phi nodes get own slots too, from varSlots

[DONE] TODO: rename "dsts" to uses, less confusion

[DONE] FIXME: do you consider branch desc args as uses? ***

[DONE] TODO: comment out currently broken tests, get make test working

[DONE] TODO: get IR gen for function calls working

[DONE] TODO: get IR gen for function decls working

[DONE] FIXME: get x = 1 working

[DONE] FIXME: get while (1) to work
- genRtCall is incomplete

[DONE] TODO: get while(true) to work

[DONE] FIXME: merge ctx should check if branch exists
- If branch present, find matching target

[DONE] TODO: context.merge(subCtx)... proper local map handling?

[DONE] TODO: IRGenCtx.dup? Bring back subCtx! less copying overhead

[DONE] TODO: IRGenCtx.ifTrue

[DONE] TODO: adapt context for loops, break ctx list, cont ctx list
- No longer want exit and continue blocks, but lists instead

[DONE] TODO: convert genBoolEval
- KISS for now, improve with SSA way later?

[DONE] TODO: mergeContexts
- In Tachyon, with the output of mergeContexts
  - Set it as the "output" (continue generating code there), like .merge
  - Continue generating code from a new context with that block
- Creating a new context seems like the safer, cleaner option (and probably just as fast)
  - Much cleaner abstraction

[DONE] TODO: mergeLoopEntry?

[DONE] TODO: method to set/add branch desc argument?

[DONE] TODO: createLoopEntry
- creates phi nodes for each variable going through the loop
- start by making basic while loop work!

[DONE] TODO: test simple functions/expressions
- print text output
- modify main to do this? return early

[DONE] TODO: fixup IRFunction.toString

[DONE] TODO: begin porting stmtToIR, exprToIR
- constant exprs
- arith add
- statement expr, return expr

[DONE] TODO: modify/port (most of) astToIR function to get familiar

[DONE] TODO: port genRtCall
- needed for astToIR function

[DONE] TODO: mutable int32 IR value? IntVal?

[DONE] TODO: modify IRGenCtx
- outValue
- localMap

Context merge idea: we must make the contexts jump/branch to the right block
(we do this already). Must also create phi nodes and add incoming values as
appropriate.

It seems like we probably could have a simpler mergeContext that works on
an individual context basis... 
- mergeLoopEntry uses a map of entryLocals and an entryBlock
- createLoopEntry creates a phi node for each variable going through the loop
  - no choice without prior knowledge

Tachyon IRConvContext has:
labels,
localMap,   // Mutable map of local variable states
sharedMap,  // Map of shared variable locations
breakMap, 
contMap,
throwList,  // Throw context list
funcObj,
thisVal,    // This argument value
outValue    // Output value of the evaluated AST node

IRConvContext.prototype.setOutput = function (exitBlock, outValue)
- Note: exitBlock is no longer necessary

// Create a context for the loop entry (the loop body)
var entryLocals = new HashMap();
var brkCtxList = [];
var cntCtxList = [];
var bodyContext = createLoopEntry(
    astStmt,
    astStmt.statement,
    context,
    entryLocals,
    brkCtxList,
    cntCtxList,
    'loop_body'
);

// Merge the break contexts
var loopExit = mergeContexts(
    brkCtxList,
    context.localMap,
    context.cfg,
    'loop_exit'
);

// Merge the continue contexts with the loop entry
mergeLoopEntry(
    cntCtxList,
    entryLocals,
    context.localMap,
    testContext.entryBlock
);

// Merge the local maps using phi nodes
var joinBlock = mergeContexts(
    [trueContext, falseContext],
    context.localMap,
    context.cfg,
    'iir_join'
);

[DONE] TODO: string constant IRValue

[DONE] TODO: get code into compiling state
- Comment out code until things compile?
  - Comment out most of ir/ast.d
- getArgSlot?
  - for interp, assert use has an out slot

[DONE] TODO: remove useless instructions
- set ..., move

[DONE] TODO: remove original IR classes, replace by new ones

[DONE] TODO: implement SSA IR
- Constant pool for int32s, float64s, true/false/null/undef/missing
- Remove instrs that are now constants

[DONE] TODO: fix dependency cycle ir.ir -> interp.ops -> ir.ast -> ir.iir -> ir.ir

[DONE] TODO: disable various IR analyses

[DONE] TODO: disable JIT for now, comment out aside in makefile

------------------------------------------------------------------------------

[DONE] TODO: think about register kill in ASM, would be very useful
- Combined kill with bit mask of GP registers to kill
- KillRegs annotation
- Only insert if !jit_noasmopts
- slows the code gen a bit...
  - another argument for SSA
- this idea actually sucks

[DONE] TODO: basic peephole opts

[DONE] TODO: jit_noasmopts flag

[DONE] TODO: try to use one less scratch reg, commit before
- Benchmark first, note times ***
  3d-cube               2.45    2.50
  3d-raytrace           4.34    4.43
  bitops-nsieve-bits    1.32    1.33
- Grep for scrRegs64[3]
- Result: no noticeable difference!

[DONE] TODO: lsft_i32, rsft_i32

[DONE] TODO: test simple artificial benchmark for study
- for_loop.js, just a for loop that increments a counter
- issue: quite likely, w.r.t. const prop, global values aren't optimized
  - global version is a little slower
- stare at ASM, make it better
- Observations
  - lt, add successfully inlined in main loop
  - tons of stubs are produced, should probably optimize stub compilation
  - with lots of iterations, it's almost twice as fast with inlining
- when we do get_global, we copy the type to the stack, but we keep the
  value in a register. We then write 0 to the stack to prevent a type out
  of sync problem...
- jumps to next label are quite common
- int offset in load instr could be optimized

[DONE] FIXME: useless move in simple for loop, closure version
- Flaw in init analysis w.r.t. dead code and argument initialization

[DONE] FIXME: bug in 3d-raytrace, has to do with set_true, set_false
- Fn args could be constant, but call/ret wouldn't know?
  - Test if this is the case

[DONE] TODO: getWordOpnd: provide a tmpReg parameter

[DONE] TODO: rename getArgOpnd to getWordOpnd

[DONE] TODO: getTypeOpnd, do we ever get a type that's not an instr argument? grep it

[DONE] TODO: eliminate getReg

[DONE] TODO: restructure/simplify call, spill everything *after* arg copying

[DONE] TODO: SET_TRUE should store its constant

[DONE] TODO: optimize IsTypeOp

[DONE] TODO: add flags for known boolean values, defer value write?
- Allows optimizing both IsTypeOp and if_true
- If opnd is requested, move value to opnd
- If spilling, write value
- Probably need a special TF_CONST

[DONE] TODO: basic OSR if function is on top of the stack
- Easy at this point? Just move the values to the new slots
- Fn on stack must be interp function if we're in compFun
- Large majority of stuff isn't deep on the stack when compiled
  bitops-nsieve-bits shows $rt_arr_ofs_len as "deep"... How???
  - Could an old RA be left over on the stack, not used?
  - Try implementing proper stack traversal
- Disable temporary compFun in callFun

[DONE] TODO: remove localMap thang from inlineCall, not needed

[DONE] TODO: re-implement FP ops in JIT

[DONE] FIXME: v8bench/splay borks the JIT
- operand is null, nonsense!

[DONE] TODO: GC unit test
- Alloc small object, add more properties, trigger GC,
  try accessing latter properties

[DONE] FIXME: GC bug with next chain
- Segfault in gc/graph after collection is done
- GC is artificially triggered by shrinkHeap, not during allocation
- Crashes somewhere while setting up initial graph
- Seem to be crashing on array push
- Crashing when trying to get a closure cell property (array_toObject)
  - $rt_getCellVal
- Quite possibly our closure got a next pointer before the cells were set!

[DONE] TODO: interpreter stack traversal function with delegates?
- use for GC, funOnStack
- delegate with: IRFunction fun, wsp, tsp, size_t depth

[DONE] TODO: blog, Implementing Inlining
- Inlining in Higgs
  - OSR aspect
  - nontrivial, stressing the JIT, bug fixing
  - frame compaction, optimization
  - most tests show slight perf loss, some slightly faster
- Plans: more libs, graphics/audio wrappers, testing system
  - Competing with Python?
- DConf 2013 talk in a week or so
  - Will be announced and linked on this blog and on my twitter feed

[DONE] TODO: investigate why most functions get no inlining, including $rt_add, $rt_lt
- Lack of inlining partially explains lack of speed
- bitwise-and is a loop, won't inline anything without basic OSR
- rt_add, rt_lt themselves don't really need inlining for the common case
- must have basic OSR to see change in functions with loops
- 3d-cube is actually faster

[DONE] TODO: re-implement add_i32_ovf in JIT

[DONE] TODO: re-implement set_f64

[DONE] TODO: for inlining, be a little smarter
- Check if arg count never read, if so don't write it
- Check if arg slots never written, if so use arg vals directly

[DONE] TODO: jit_noinline flag
- remove plain jit_noopts, not specific enough
- 3d-raytrace still 0.6s faster without inlining, 3.5 vs 4.3

[DONE] TODO: IR flag for non-pure values, things we can't safely remove
- STORE_..., SET_LINK, SET_GLOBAL, EVAL_STR, PRINT_STR, CLOSE_LIB, GC_COLLECT
- OpInfo.IMPURE

[DONE] TODO: optimize instructions needed for inlining
- set_rawptr, eq_rawptr, set_i32, load_rawptr
- produces some speedup, but still not as fast as uninlined
- moves may be quite inefficient

[DONE] TODO: test performance on raytrace, bitwise-and? try increasing fn size limit
- Raytrace is twice as slow, 4.4s vs 10s

[DONE] TODO: test inlining with functions not currently on stack (pre-OSR)
- funOnStack
- ISSUE: all functions are on the stack when compiled!
- For now, temporarily call compFun in function call bit?

[DONE] FIXME: rt_sub used for negative numbers in JS layout computation!
- Look at irString, $rt_clos_ofs_cell
- Fix in parser

[DONE] FIXME: inlined rt_sub is compiled all wrong???
- Move instruction doesn't copy type tag properly?
- Disabling gen_move fixes problem
- Immediately after move, is_int32 fails
- IsTypeOp doesn't account for known type tags

[DONE] FIXME: segmentation fault on Higgs init
- JIT is probably calling valIsString with the wrong stack frame size
- Optimized call based on pre-inlining size

[DONE] TODO: JIT string printing mechanism

[DONE] TODO: test inlining with the JIT off first?
- Tests pass without JIT and without inlining
  inlining $rt_setCellVal(22E120) into clos(2380CD)
- invalid move dst in clos() function
    $4 = set_undef
    move $4
    jump => call_cont(23812C)
- Call with no return value unhandled

[DONE] FIXME: segfault when executing fun w/ inlining
inlining $rt_obj_ofs_type(11AC) into $rt_obj_set_type(11D6)
- Arguments not copied right, inverted order

[DONE] FIXME: segfault during JIT compilation

[DONE] FIXME: pointer is not pointer type in load op, failing to load from clos ptr

[DONE] TODO: implement size limit in inlining test

[DONE] TODO: funOnStack
- Just scan the stack for RAs, very simple

[DONE] TODO: go over inlining implementation, inspect code

[DONE] TODO: implement inlining
- Maintain original call cont blocks
- Keep track of who's inlined at each call site, for exception stack unwinding
  - Map of call instrs to lists of functions
- Produce mapping of pre-inlining stack slots to inlined slots, for OSR
  - Map of stack indices to stack indices

[DONE] TODO: change function layout so function pointer has fixed offset
- Get offset of word slot 0?
- on alloc class, add numRsvProps parameter

[DONE] TODO: fix closure ctor_class issue

[DONE] TODO: IR, i64 tag, support

[DONE] TODO: IR instr renaming for convenience
- is_i32, is_f64, ...
- set_i32, set_f64, set_str, ...

[DONE] FIXME: crypto-aes, run-time error: undefined base in property read
- array w in KeyExpansion should have been initialized with array, is not
- Likely, failing because loop index is not integer

[DONE] FIXME: crypto-aes, invalid operand 2 type in op "auto r = x * y;" (int32)
- Investigate, create failing unit test
- Problem with new Array, size resulting from division is a float

[DONE] TODO: blog
- DConf, impressions
- method JIT, versioning
- talk slides
- forum.dlang.org/group/digitalmars.D

[DONE] TODO: fix loop label segfault

Publishing: figure out their litmus test. For some, numbers, for some it's
proofs, make sure you have that
- You're selling something, try to have a grand narrative
- Why it's hard, why it's interesting, why is it novel
- Papers you *should cite*, how does it compare
- Try to cite the reviewer...?
- Cohesion, line of thought, don't want sections to look like afterthought

Michael: try to do these optimizations by hand on some benchmarks, where will it pay off?
- I wasted a lot of time trying to do clever things I thought would matter

Michael: constant folding, copy propagation, try to predict benefit? *****

Michael: either work backwards or you backtrack
- Or do it greedily backwards?

Shu: flow problem. Want to optimize CFG to reduce joining work.
- Attach weight to individual nodes based on amount of work
- How much work did we save?
- Model performance characteristics

Problem: add operator, overflow case... Don't want this automatically compiled
- Whole other loop path for doubles?

Michael: don't want duplication to propagate all the way through
- Merge as early as possible
- Metric of benefit vs cost of duplicating a block
- If merging from two different types, we get boxing overhead

Max: Incremental duplication may be necessary... Prevents impossible/useless
duplications to some extent. Otherwise duplication can propagate to successors.
- Similar problem to trace trees

Michael: if you duplicate a block, what is the probability you'll have to
duplicate its successors

Michael: tail duplication has been around for a long time, lots of literature

Michael: would be interesting to try and predict if tail duplication will help
at a specific point

Michael: come up with a metric
- Now way of knowing tail duplication will pay off in the future
- Has a cost, could afford it if it pays off

Shu: split (terminology?)

Michael: profile in an interpreter
- Backwards flow analysis, I need this type info?
- I would like this not to be polymorphic
- Would like this to be an int

Shu: tail duplicate until things become monomorphic
- Drives the duplication

Michael: compile without duplication, monitor hot spots

Shu: don't version at some blocks?
- Re-merge if useless?

[DONE] TODO: start sketching out ir/inlining.d
- inlineCall?
- add comments to flesh out process

[DONE] TODO: allocate stacks with malloc, NO_SCAN

[DONE] TODO: use GC.BlkAttr.NO_SCAN when allocating heap, link table

[DONE] FIXME: return with no semicolon causes parse error
- Create failing parser test

Problem: unwinding stack frames on throw or before calls...
- Must setup stack frame as multiple frames before each exiting call?
  - Correct stack height
  - Write return addresses
  - Spill values/types in the proper slots
- Could save on cost of having to spill types too?
- Need to inflate if exiting to interpreter
  - call to interp
  - unsupported behavior
  - unsupported instruction
- Exceptions need to be able to make the caller inflate
  - Probably want a special extern(C) function to inflate/spill stack frames?
  - Map of call instrs to inflate function
- We can still have interpreter entry points in the middle of functions as before!
  - But these will go to non-inlined versions of functions
  - Don't place entry points in the inlined functions, only at top level
  - Not a huge deal
- Functions with inlining can have an internal stack frame size different from numLocals
  - If we optimize an inlined function and remove temps/vars, need to somehow know
    what temps map to which original function temps
    - could use special pseudo-instr to manage this
    - plase pseudo-instr before possible bailout points, function calls

[DONE] TODO: think about dynamic block/version compilation further
- What would the infrastructure look like?
  - Compile to an assembler, write to a code block
  - ol assembler used for interp entry points, interp fallback
- No longer need a queue of things to compile!
  - Blocks, entry points compiled immediately, until branch occurs
- Need an out of line code block
- Contexts need to account for inlining

Dynamic block compilation...
- Could dynamically profile branches/calls on stubs, eventually compile
- Need to manage a code block and append to it
  - Could simply preallocate to start
- Need to keep track of what jumps to what? Only if we need to displace?
- Incremental compilation of functions
- If compiling and branch occurs, create interp fallback stub, install profiling counters
  - First stub to trigger compilation gets concatenated?
  - Could have already compiled multiple loop iterations?
    - No, because you stopped at the branch!
- Inlining, could do it in the backend?
  - Yes, but we need some sort of lazy move, special alloc state
  - Might be able to recompile calls after some counter hits a threshold
- Issues:
  - Suboptimal code, reoptimization more difficult, but not impossible
  - Jumps to movable code, need to place and rewrite jump

Dynamic compilation cons:
- complicates the backend (N level contexts when inlining?)
- possibly reduces optimization opportunities
- hard to reoptimize code
- need to keep around lists of block versions for future compilations
- can't compute total frame size for inlining ahead of time...
  - would need to reserve space ahead of time

Dynamic compilation pros:
- may save compilation time
- get better profiling data
- avoids invalidating on stub hit
- can try going along with an inlining and back out of it?

[DONE] Inlining heuristics:
- max allowable numLocals of the callee
- max allowable number of blocks in the callee
- total caller + callee size
- total caller + callee locals
- IBM paper considers inlining based on profiles at the callee
  - How many callers, how frequently
  - Generates inlining requests for next compilation
  - Works based on call edge density/distribution, relative method hotness

[DONE] TODO: read empirical inlining paper, note insights

[DONE] TODO: look at IR for getPropIdx... Can we benefit from type info at all?
- Has a ton of calls to various methods
- some eq_const, eq_refptr
- Benefit would probably be fairly small, but inlining will help a lot

[DONE] TODO: functions, remove closure caching, slow offset comp path

[DONE] TODO: BOOL_OUT flag on instructions

[DONE] FIXME: v8/splay segfault with JIT
- Does lots of GC, could be related
- Is this fast enough to include in unit tests? Can we make it faster?
- Note: the GC happens increasingly fast! heap space is exhausted

[DONE] TODO: don't init temps to undef, only local variables
- numTemps, numVars?

[DONE] FIXME: i++ does get_global "i" twice???
function () { return i++; }
- confirmed, first value not used
- Problem is we want the value pre-incrementation

[DONE] FIXME: bug with 3d-raytrace
run-time error: undefined base in read of property "intersect"
Scene_prototype_blocked ("programs/sunspider/3d-raytrace.js"@244:27)
- all unit tests pass, make new regress_raytrace test
- iteration index i becomes null
- i is a global variable! some kind of type corruption happening
- problem is with set_global not using type info properly

[DONE] FIXME: type spilling
- Should only write a type when spilling a value AND the type is not in sync
- What if we're writing a dynamic type, e.g.: move
  - Should write 0 value on the word stack
- BUT, what if we have a memory operand?
  - Might still know the type, not write it to the stack...
  - If we're writing a different type and not in sync, write it to the stack?
- Problem: copying types during ret and call is cumbersome
  - getTypeOpnd, pass scratch reg if mem reading is needed?
  - Need to add stack offset param (in case we pushed more stack space!)
  - default is int32_t.max

[DONE] TODO: try to optimize global prop access, remove offset recomputation

[DONE] TODO: make setOutType change type state
- Should result in more versions, but still working code

[DONE] TODO: simple `make install` target

[DONE] TODO: add typeState to CodeGenState

[DONE] TODO: write adversarial GC/JIT test
- Big loop
- Mix many obj refs & integer calculations?
- Branching

[DONE] TODO: improve register spilling, defaultFn, better usage of liveness info

[DONE] TODO: add a V8 benchmark to make test, more sunspider tests?

[DONE] TODO: re-implement return in JIT

[DONE] TODO: usesThis, usesClos, can optimize function calls further

[DONE] TODO: type flags, type state definitions
- Known type bit
  - If not known, it's stored on the stack
- In sync with stack bit
  - if we test a type, the type we now know is what's on the stack
  - if we spill a type tag, stack becomes in sync
  - if we set a type, and it's the same as before, flag unchanged
- 5 bits for type tag itself, if known

[DONE] FIXME: function calls
- Selectively spill non-args in regs before the call
- Everything that's live after the call must be spilled
- Keep non-live flag for spilling?

[DONE] TODO: try eliminating init maps
- Don't store on function, don't use in GC
- Can init less slots if we only worry about uninitialized variables
- Refactor GC to init/reset stack to 0
- Temporarily: when setting a type, write 0 value
  - Writing 0 in get_global prevents GC crash

[DONE] TODO: check if 0 when setting type fixes the GC bug w.r.t. calls/spills
- Crashes during GC

[DONE] TODO: jit/ops.d

[DONE] TODO: default state, only args should be on stack

[DONE] FIXME: jit.d(485): argument is neither in a register nor on the stack
- Problem is with rt_typeof, used in jit/loop_new
- Log the function we're actually compiling
  $1 = set_null
  $3 = eq_refptr $10, $1
  if_true $3 => if_true(A368), if_false(A36B)
$3 is in fact live after eq_refptr
- eq_refptr uses the interp fallback
  - will not map its value as being on the stack!
  - could change interp fallback to fix this?

[DONE] TODO: bitwise-and, must still be missing instrs for lt
- using default for: $7 = lt_i32 $15, $16 ($rt_lt(27EA))

[DONE] TODO: fix set_global
- Bug with type tags? Should get true, get integer 1, integer type tag

[DONE] TODO: implement/fix get_global

[DONE] TODO: pushRegs, popRegs

[DONE] TODO: revise gen_call
- Will test the limits of the reg alloc

[DONE] TODO: implement reg alloc for simple instructions
- add, mul, and
- get_global_obj
- load

[DONE] FIXME: load with refptr gets bus error
- Unaligned memory access or wrong address???
- Could we be, by using int32 offsets, having invalid hi reg values?
  - If so, problematic!
  - There's your problem...

[DONE] FIXME: ; if_true $4 => if_true(32D6), if_false(32E2)
- Jumping to block with wrong reg alloc

[DONE] TODO: exit to interpreter, should spill regs appropriately

[DONE] TODO: revise defaultFn, might need to save allocatable regs

[DONE] TODO: spill logic

[DONE] TODO: make getArgOpnd have a loadVal argument, load to reg
- Assert not bumping output val

[DONE] TODO: make getOutOpnd try to load to reg if not bumping input

[DONE] TODO: make versioning system work without actual versions or reg alloc
- Always the same state, one version

[DONE] TODO: think about block version **state** objects
- State evolves as we go through blocks
- Should be a struct so we can assign it simply
- Need list of block versions, labels with associated states
- For now, ignore type tags, keep them on the stack ***
  - Focus on reg alloc only
- Need a map of blocks to state/label pairs
  - getBlockLabel(block, state)
  - Try to find a match, if none, produce one

[DONE] TODO: integrate level 0 FFI functionality

[DONE] TODO: interference analysis, coloring
- Go over basic blocks, count number of instrs where values interfere
  - Add counts to edges
- Color slots with registers so as to minimize conflicts
  - Use greedy coloring algorithm
  - If register must be used, pick one from neighbor with least contention
- Also color with XMM registers for FP values and spills

[DONE] TODO: JIT-to-JIT call
- fast jit entry points on blocks

[DONE] TODO: liveness analysis for stack slots
- Returns map of instrs to sets of live slots after the instr
- Need to know if we can kill a value after an instr

[DONE] IDEAS: Basic block versioning
- Can version based on spill status, type, known constant value
- Instr flow functions give us type info
- Type checks give us extra type info
- Checking if something is a given constant gives us info
  - e.g.: check type of receiver before inlined call
- Can avoid generating paths that haven't occurred in practice
  - Jumping to non-existing path needs to bailout to interpreter, invalidate function
- Blocks with 0 exec count are stubs
- If IRFunction is transformed for inlining, non-inline paths will have 0 exec count to begin with
- If known constant value, can try generating new version
  - If too many versions already, try to match existing versions more coarsely

[DONE] IDEAS: Versioning JIT
- Generalize versioning to per-version pre-conditions
  - Generic/catch-all version has no conditions required
  - Type requirements of various granularities can be encoded as conditions
- Count interpreter cycles per call to grant versioning/optimization/inlining budget
  - Functions that take long to execute should get more!
- Monitor call args to decide how to version
  - Can specialize all the way down to constants
- Can transform loops into tail calls
  - Optimize the tail

[DONE] TODO: implement callee-guessing
- Map of call instrs to lists of callee fptrs with frequencies
  - Store on the caller function
- Test fptr and not closure ptr

[DONE] TODO: mid-loop entry
- Create entry points for loop headers
- Bitwise and can't be optimized without this

[DONE] TODO: basic block stubbing
- Code should be out of line
- Invalidates code block and all entry points for function
  - Implement through C function
- Run unit tests

[DONE] TODO: implement some of the ops in rt_and
- is_int32, and_i32

[DONE] TODO: make basic method JIT work, use only scratch regs for now, no reg alloc
- Implement jump, if_true
- Implement initial call/ret by bailing out to interp
  - Generate export for continuation target
- Test on bitwise-and to start
- Try unit tests and commit method JIT v0

[DONE] TODO: JIT compilation & entry hooks in interpreter
- If block reaches target exec count, compile its function
- Will automatically work for loops too

[DONE] TODO: secondary entry points for fn returns
- Function to generate the code for an entry point
- Create an exported label? Need to wait until code is assembled to set
- Map of blocks to exported labels
- This code should be out of line ***
- getEntryPoint
- Eliminate initial entry point, just get the entry point for the entry block!

[DONE] ISSUE: you don't know if the caller was running JITted code?
- If calling interpreter function, have to bail out to interpreter first, so that's OK
- If doing JIT-to-JIT call, and then we bail out to the interpreter...
  - KISS: when you do any call, spill the locals

[DONE] TODO: begin compiling basic blocks?
- getBlockLabel?
- stack overflow warning

[DONE] TODO: store CodeBlock pointer on compiled function

[DONE] TODO: solve first problem: how do we enter, how do we bailout
- To enter, call entryFn on some basic block
  - Saves regs, does required prep
- To bailout, pop regs, save wsp, tsp, do return to interpreter
- For now, can have generic bailout label in code gen context

[DONE] TODO: plan register mapping with fixed regs, scratch regs, allocatable regs

[DONE] TODO: read SELF customization article

[DONE] TODO: research procedure cloning, dynamic languages
- Find MATLAB versioning article
  - MaJIC, precompiles version

[DONE] TODO: can we generalize versioning, dispatch based on arbitrary conditions?
- types of class properties involved in parameters (specific type sets)?
  - Is this effective? Avoids invalidation
  - Might have lots of type sets involved?
  - Can disable entry to function with boolean flags, basically
- How granular? can dispatch all the way down to constant values
  - Profiling argument types would make sense here
  - If almost always constant, take advantage
- Heuristic: functions with longer execution time (in interpreter instrs)
  should get more versioning budget/granularity
  - Re-add interpreter cycle counter?
- Should generalize string down to pre-conditions **********
  - Generic/catch-all version has no conditions required ******
  - Type requirements of various granularities can be encoded as conditions
- Start by implementing generic method-based compiler

[DONE] TODO: think about method-based compilation
- Interp fallback
  - Dump stack slots to interp stack
- Mid-loop interp jump
  - Special entry point that jumps into loop (outer loop only?)
  - Can have special prelude code
- Fallback w/ inlining
  - Need to keep track of frames pushed, locals for each frame
  - When inlining, add special call/ret annotation instructions
    - Keeps track of frames pushed, slots added
- Join w/ inlining
  - Join at loop header, not in the middle of inlined calls
- Speculative inlining
  - Can use interp fallback if incorrect guess, or have 2 paths
  - Default path does generic call
- Can prealloc space for inlined frames on call to compiled function
  - When doing inlined call, avoid copying args until write occurs
- Calling non-inlined function
  - Leave extended stack frame as is
  - Put calling instr on stack, as normal
  - Callee checks who caller is when returning, can find actual RA
  - May need to return to interpreter to do call

[DONE] TODO: add support for regexp in parser
var re = /pattern/flags
var re = new RegExp("pattern", "flags");
flags: i, g, m, y

[DONE] TODO: 3d-cube has a horrible trace exit count, why?
- Is it because traces are limited in length? Is it because of recursion?
- MMulti trace has 513 blocks
    root trace entry count: 1160855
    sub-trace entry count : 624093
    trace loop count: 241408
    trace exit count: 919447
- Increasing max trace length doesn't improve things
- getPropIdx isn't the problem
- Low trace count and super long traces doesn't help
- The trace is legitimately very long...

[DONE] TODO: compute trace completion rates?
- increment interp counter on trace start, other counter on final trace completion
- counter for interpreter fallback rate ***
- jit_stats
- Loops? Increment on each trace entry

[DONE] TODO: blog
- Traces, sub-traces
- Stack frame init maps
- Updated perf numbers
- All SunSpider/V8 benchmarks except regexp working, thanks to Tom Low
- FFI
- eval

[DONE] FIXME: segfault on ./higgs programs/sunspider/bitops-bits-in-byte.js 
- Doesn't crash with no JIT
- jump to self at block 30/169 in sub-trace of bits-in-bytes
- Root node has no trace object???? wtf
  - root not marked as a trace start
  - not calling record on it
- not setting root node properly in sub-traces

[DONE] TODO: look at more missing instrs for nsieve-bits
- eq_i8
- does this make sub-traces faster? yes
- crash in sunspider tests, signal 11

[DONE] TODO: review traces and sub-traces, do they make sense?
- long traces probably due to loops in runtime, e.g.: getPropidx
- does allowing longer traces result in slowdowns?
- increasing max trace length makes it slower

[DONE] TODO: jit_dumpinfo

[DONE] TODO: test JIT on earley-boyer
- check memory usage: 2.3%
- sub-traces aren't making much difference

[DONE] TODO: try tweaking trace/sub-trace constants/heuristics
- use jit_nosubs for performance comparisons
- 3d-raytrace is faster with sub-traces
- Tweaking inconclusive, would ideally need automation

[DONE] TODO: jit_disable, jit_dumpasm, jit_nosubs

[DONE] TODO: increment block idx only for trace headers

[DONE] TODO: add/enable more sunspider benchmarks in unit tests

[DONE] FIXME: gc/stackvm crashes with JIT, uses GC
- Crashes during sub-trace compilation

[DONE] FIXME: 3d-raytrace segfaults
- jumps to self too early?

[DONE] FIXME: stack depth issues in sub-traces
- Not keeping track of call stack and call stack depth properly
- Sub-trace needs this initial call stack
- Trace start node needs to start with correct stack depth

[DONE] FIXME: make sub-traces belong to parent trace object, not blocks

[DONE] TODO: make it so sub-traces are part of the root trace tree?
- Do we really need a trace pointer in TraceNode objects, is rootNode ok?

[DONE] TODO: Pass a copy of the CodeGenCtx to the sub-trace?
- Could be a big object
- Can we retrace steps from the root trace? Expensive
  - Expensive but necessary?
  - Could have hundreds of blocks in a main trace
  - Still OK if ctx is relatively small

[DONE] TODO: implement sub traces from if
- If threshold reached
  - call function that begins tracing from block
  - jump to interpreter
- Pass address to patch back for direct jump to trace
  - Write jump directly over a reserved block of nops, 10 + 2 bytes
  - Can reserve 12 bytes, use an assembler to get the proper bytes

[DONE] TODO: Trace node currently stores root node pointer
- Could store trace object pointer instead
- Trace object can store:
  - root trace node
  - parent trace object
  - parent jump address
- Creating the trace object can create the root trace node?

[PASS] TODO: loop to loop, stop at inner trace?
- Doesn't seem to improve performance

[DONE] TODO: keep track of calls/returns during tracing, avoid wasting time?
- Will avoid wasting a lot of time in function traces, super long traces
- Simplifies logic of JIT itself
- Should speedup 3d-cube, 3d-raytrace

[DONE] TODO: better callee-guessing in call

[DONE] TODO: ctx.stopTrace

[DONE] FIXME: 3d-cube, interpreter stack underflow, other crashes
- Caused by trace length being capped? No
- access-binary-trees, multiple levels of recursion in
  run-time error: undefined base in property read
  crash after compiling trace in $rt_getProp(27F5)
- Try disabling global prop access: no
- Disabling ret logic seems to fix it...
- Problem comes from default call/ret implementation not stopping trace

[DONE] FIXME: enable jump to self

[DONE] TODO: remove segment extension code, compile traces from trace nodes

[DONE] FIXME: in nsieve-bits, recording many many traces at rt_not, never compiling

[DONE] TODO: move IIR static ctor to ir/iir.d

[DONE] FIXME: seemingly unrelated blocks in traces...
- Jump into a trace while recording, end up anywhere

[DONE] TODO: implement trace node updating during tracing
- compTrace should take a TraceNode argument, construct the block list
- add a trace node pointer to the interp class?

[DONE] TODO: implement TraceNode class, jit/trace.d
- Node should have count, associated block, depth, tree root, list of children

[DONE] TODO: implement system to constrain trace starts to specific blocks
- Need to label trace start blocks
- Blocks need counter + trace start flag + trace object pointer

[DONE] TODO: refactor global return code into parser
- Useful for eval

[DONE] TODO: implement global eval
- eval_str instruction?

[DONE] TODO: rename segment object to trace, compSegment to compTrace, etc.
- Do grep for Segment/segment, to match comments

[DONE] FIXME: GC bug after multiple runs after load?
- Try to replicate with unit test
  - Hard to achieve, too much code
- rule_loop is the function that was destroyed then called *****
  - appears to be a local function, recreated
  - there are 3 different rule_loop functions...
    - 2 of them transitively added, last one destroyed
- How can we not find one of the rule_loop functions transitively?
- If we GC on global scope... Most functions are destroyed
  - Only a problem if first run occurs first
  - Obviously poor traversal, poor finding of function references
- The problem must be that our transitive function adding is imperfect..
  - Does not implement a proper DFS

[DONE] TODO: ASMComment pseudo-instruction?
- Have function to add comments when dumpasm is enabled?
- Will allow better understanding of asm output

[DONE] TODO: rename JITInstr to ASMInstr

[DONE] TODO: prepare presentation for Friday 15th March
- Explain ideas in more detail
- Elaborate on incremental segment extension
- Is counter=1 like regular tracing?
  - Not exactly, still need multiple passes through segment to extend

[DONE] FIXME: earley-boyer, call to non-function

[DONE] TODO: try self-patching mechanism for optimized global object access?
- cache based on global object address?
- can a load patch its own 32 bit offset???
- flesh out ASM code

[DONE] TODO: IP-relative addressing
- Should be able to specify label, but also extra disp
- Unit asm code execution

[DONE] TODO: refactor instruction operands
- Array of fixed size in instr
- Pointers to subclasses of X86Opnd

[DONE] TODO: IntData JITInstr
- Num bits, value

[DONE] TODO: optimize JIT interp fallback, now have mayGC, isCall
- Test with earley-boyer

[DONE] FIXME: GC during load(), not a proper function call! can't traverse stack
- unit test this, gc/load.js?

[DONE] TODO: remove stack init code from JIT

[DONE] TODO: make interp no longer init stack slots in function calls

[DONE] TODO: refactor GC to use init maps when traversing stack
- Make sure unit tests, earley-boyer still work fine!

[DONE] FIXME: ip is moved before instr is executed...
- Could probably change this with current design

[DONE] TODO: mayGC opcode flag
- Needed by heap_alloc, set_str, set_global, get_global

[DONE] TODO: implement init map system
- bug, seems to be caused by code after branch
- stop adding instrs after branch?

[DONE] FIXME: JIT bug causing segfault in earley-boyer
- Crashes in segment in $rt_class_get_cap(1394), len: 1
- Disabling call and ret JIT instrs does not fix it
- String table gets extended, class gets extended, but no GC yet
    $2 = get_global "$rt_class_ofs_cap", 177
    $1 = get_global_obj
    $3 = call $2, $1, $11 => call_cont(2D5A)
- Could it be get_global? Try disabling?
  - Works without get_global!

[DONE] TODO: optimize set_str

[DONE] TODO: try optimizing/specializing return sequence

[DONE] FIXME: gc causes crash during trace?
- Could the GC be invalidating something?
- Collecting the current function? No
- Segment causing crash is in array_push
  - Loops over $argc
- not crashing in get_arg, set_str, heap_alloc, load
- bug caused by getString in gen_call causing gc!

[DONE] TODO: can we have traces join themselves, e.g.: bitwise-and?

[DONE] TODO: add callStack in CodeGenCtx?
- push/pop the call instructions
- can allow full inlining
- may have problems with very long traces

[DONE] FIXME: v8/crypto sanity check fails

[DONE] TODO: branches extend according to which block is specified in the list
- Last if_true, if no next block is specified, insert counter code
compSegment(Interp, nextBlock, segment = null)
- Segment is created if none exists
- nextBlock gets added to the block list
- compilation loop follows the block list

[DONE] TODO: Create Segment class
- Can store counters, list of blocks, code block, etc.
- Easier to manage!

[DONE] NOTE: block exec counts are betraying us even in very simple cases!
- rt_and, both operands integers
- and_exit and and_sec blocks have the same exec count
- can't tell that the AND condition is always true
- Do we want branch counters instead?
  - Strictly more powerful than block exec counters, can still compute block exec count

[DONE] TODO: log instrs for which default fn is used

[DONE] FIXME: JIT breaks 3d-raytrace?
- Find issue, add jit unit test
- Problem seems to be in the call logic
- String(undefined) produces undefined after compilation
- $rt_isGlobalObj(this) in String starts producing true after compilation

[DONE] TODO: use unique id system for labels, use in toString?
- Just print their current offset?

[DONE] TODO: second assembler object for out of line paths
- Assembler.append(Assembler) function?
- OVF logic => out of line
- Function call interp path => out of line

[DONE] TODO: try logging branch exec counts on if_true
- Log with associated instr
- Many go entirely one way, most unbalanced

[DONE] TODO: refactor all conditional branches to have 2 targets?
- target, excTarget?
- Probably best for block extension
- Need to pick a target to extend the block with either way

[DONE] TODO: blog post about JIT compiler

[DONE] FIXME: v8/earley-boyer requires class extension
- Implement in interp/object.d
- Add unit test for this

[DONE] TODO: try to guess callee function?
- Can introspect a bit, check if calling global fun
- Compare closure pointer against known global
- If known global, run optimized sequence!
- Otherwise run interp version
- Great speedups!

[PASS] TODO: implement CALL instruction
- PROBLEM: call instruction sequence is extremely long!
- Very inefficient to implement

[DONE] TODO: implement RET instruction

[DONE] TODO: stack access functions

[DONE] TODO: table of code gen functions, addressed by opcode
- Default gen function calls the instruction

[DONE] TODO: implement JUMP_TRUE, JUMP_FALSE
- jump to trace end label

[DONE] TODO: implement set_int32
- Need to access wsp, tsp
- Load them from interpreter at start of trace, spill at end?
  - Allows proper indexing
  - Put them in callee-save registers

[DONE] FIXME: including RET or CALL in tracelet causes segfaultl
- Return seems to occur twice?
- Set traceEntry to null before entering trace
- Otherwise, we're setting it to null after trace, undoing work of another trace

[DONE] TODO: command-line option to enable or disable JIT
- options.d?

[DONE] FIXME: somehow, traces make odd behaviors happen, e.g.: call to non-function
- Somehow, semantics differ
- Lots of tracelets seem to get executed successfully
- Setting the IP before instruction execution seems to fix this...

[DONE] FIXME: trace issue, jump(block) can trigger recursive trace exec
- Could jump() set a trace pointer in interp, but not call it?

[DONE] TODO: basic tracelet JIT, jit.d
- Lazily compile tracelets for blocks
- Start with one entry point, as a C function
- Need trace to call into instr op functions
- Trace exits by doing ret

[DONE] TODO: port and test x86 execution tests

[DONE] TODO: convert push/pop test to 64-bit registers

[DONE] TODO: complete porting of assembler tests

[DONE] TODO: begin porting assembler tests

[DONE] TODO: port assembler code

[DONE] TODO: port operand toString

[DONE] TODO: finish porting basics of CodeBlock, add mem block allocation

[DONE] TODO: implement register toString

[DONE] TODO: port operand, encoding code

[DONE] TODO: port instruction table construction

[DONE] TODO: copy over Tachyon assembler tests, instr table

[DONE] TODO: fmod, needed by both raytrace benchmarks

[DONE] FIXME: raytrace sanity check fails
- Problem is division of number by string... assholes.

[DONE] TODO: look at D ABI
- Should match the linux 64-bit C ABI
First six int/pointer arguments in RDI, RSI, RDX, RCX, R8, and R9
Return value is stored in RAX

[DONE] TODO: blog
- Mozilla people, learning, friendly people, pleasant office
- DConf 2013
- Meeting with Apple
- Silicon valley is quite different
- Smartphone
- First pull requests
- Bug fixes
- Feature and benchmark list
- Brainstorming
- Preparing tracelet JIT implementation

[DONE] TODO: Add jump function, to jump to a certain block
- Changes the state of the interpreter, returns
- Asserts target is not null
- add block exec count

[DONE] TODO: enable JSON stdlib module
- parse fails, unknown escape sequence

[DONE] TODO: genCallTargets

[DONE] TODO: make call have 2 targets

[DONE] TODO: make post-call be separate block
- Don't want ret tracelet starting in middle of block
- Better for analysis?
- Alternative is ret stays in same block, IP is post-call
  - Would have to associate tracelet with instr in middle of block!
- bitops-nsieve-bits, before: 19.879, after: 24.189, sep: 21.837

[DONE] FIXME: 4294967295.0 === 0xFFFFFFFF
- Int not represented correctly
- Gen code using set_float instead

[DONE] TODO: Fix toInt32, needed by v8/crypto, v8/splay
- Make it use f64_to_i32
- Add more bitwise unit tests for and, or ops, rsft, ursft
- test corner cases

[DONE] TODO: Comply with ES5 comparison unit test
- Will help certify proper working
- Look at Tachyon implementation of primitives

[DONE] TODO: load_file instr
- Add unit test for this
- Add load to feature list on blog

[DONE] FIXME: deltablue, interpreter stack overflow
- Fails after Error object is finally found?
- Did some assertion fail?

[DONE] TODO: add more basic Tachyon unit tests
- Arith, operators

[DONE] FIXME: do we expect the result of Obj.toString to be a string in $rt_toString

[DONE] FIXME: v8/raytrace, info.color is undefined, shouldn't be
- for-in, used by object extension, is broken
- the presence of "var" screws it up

[DONE] FIXME: v8/deltablue, call to non-function
- EditConstraint corrupts working of UnaryConstraint?
- Setting EditConstraint.prototype.isInput corrupts EditConstraint.prototype.isInput

[DONE] FIXME: typeof global var should produce undefined
- $rt_typeOfGlobal(propName)?
- Needed by v8bench/raytrace
- Implement runtime function to see how practical this is
- Add unit test

[DONE] TODO: parseInt, needed for v8bench/crypto

[DONE] FIXME: interp.interp.RunError: global property "rng_pool" is not defined
- Global var stmt, not initialized to undefined
- Add unit test

[DONE] TODO: add list of working benchmark programs on Higgs page, useful to have

[DONE] TODO: Math.round, needed for 3d-cube

[DONE] FIXME: crypto-md5, crypto-sha1, invalid operand 2 type in op "auto r = x * y;" (int)

[DONE] FIXME: deltablue, 3d-cube, ref ptr out of heap
- Failing on object property
- propIdx is 2, object capacity is 2

[DONE] FIXME: lt,gt,eq functions fails in 3d-raytrace, undefined/null value as input

[DONE] TODO: anon function naming in AST
- Anon functions in sunspider/raytrace.js hard to debug

[DONE] FIXME: v8bench/richards, Segmentation fault
- Can we replicate this in a unit test?

[DONE] TODO: TypeSet, GCRoot, could we just use type monitor objects as weak roots?
- Use linked list kind of system, all type sets linked
- Store associated class, if any
- If class is dead after GC, destroy
- Functions destroy their type sets automatically
- Merge TypeMon and TypeSet

[DONE] TODO: implement delete operator
- Unit test this

[DONE] TODO: complete TypeSet constructor from val, union

[DONE] TODO: complete TypeMon basics

[DONE] TODO: GCRoot assignment operator, copy constructor

[DONE] TODO: blog, higgs interpreter complete
- Flesh out feature list on about page
- Post feature list
- Blog about monitoring
- Mozilla visit

[DONE] TODO: enable stdlib_string unit test, comment out regexp code
- interp.interp.RunError: global property "alloc_str" is not defined

[DONE] FIXME: destroy fun in collectFun causes odd interpreter bug
- Collecting function on stack?
- Log deleted functions

[DONE] TODO: parser, encode operator associativity, improve parenthesization
- Test with Function.toString
- Unit test expressions for correctness
- Problems arise when the parent doesn't have higher priority than us

[DONE] TODO: try to find expression tests that break parser re-parse
- write failing unit test

[DONE] TODO: add problematic expression tests for interpreter

[DONE] TODO: determine how to represent numerical ranges
- Look at moller's paper for insight
- just use int64

[DONE] TODO: start implementing type set object, in D
- interp/type.d?
- operations should mutate set objects? Yes, probably
  - want to keep list of dependencies
  - want to maximize speed of operations

------------------------------------------------------------------------------

Milestone Complete: working benchmarks

[DONE] TODO: for-in loop
- [DONE] Port over Tachyon runtime code for this
- [DONE] Test getPropEnum before implementing loop code gen
- [DONE] Base loop code gen on Tachyon code
  - loop until enum function returns false
- [DONE] Enable for_in unit test

[DONE] TODO: basic Date support
- currentTimeMillis()
- IR instr get_time_ms

[DONE] TODO: class obj, make it a hash table
- like the string table
- add max load consts to layout.py

[DONE] FIXME: string table extension provokes GC
- gc during table ext invalidates string ptr?

[DONE] TODO: arguments object
- If no "arguments" param, create arguments local
- KISS, just create array, copy arg vals in loop, set in local slot
- vars analysis should set usesArguments flag in function
  - KISS for now, any occurrence of "arguments" identifier
- enable gc test

[DONE] TODO: call with apply
- call_apply(closArg, thisArg, argTable, numArgs)
- enable gc test
- add unit Tachyon apply tests

[DONE] TODO: accessing missing global prop should throw exception
- use missing property constant
- assertThrows

[DONE] TODO: missing property constant, like undefined, but not
- [DONE] set_missing
- [DONE] init object properties to missing
- [DONE] revise getProp
- [DONE] revise "in" operator, hasOwnProperty
- [DONE] add unit tests

[DONE] TODO: Look at features of two "real" benchmarks to guide development
- Benchmarks: Bones, sunspider/3d-raytrace
- What features are we missing?
  - Float32Array, could replace by Float64Array, aliased to array
  - Already have everything else for bones!
  - For raytrace, new Date().getTime()
- v8/raytrace uses the for-in loop

[DONE] TODO: string->number, parsing numbers in strings
- stdlib_number unit test

------------------------------------------------------------------------------

Milestone Complete: complete simple interpreter (~Dec 31st)

[DONE] FIXME: topmost function doesn't have closure on stack?
- We free a closure, but can we free all its link indices?
  - No, because the code might still be used...

[DONE] TODO: traverse instructions of dead functions, collect link table refs
- log dead functions

[DONE] TODO: garbage collecting fun refs
- Create new fn ref table
- liveFuns table in interpreter
- When traversing closures, add fns to ref table
- Replace original ref table

[DONE] FIXME: ret addr is calling instruction, not IR function pointer
- Add special instruction pointer type tag

[DONE] TODO: blog post, interpreter milestone complete
- Next goals, monitoring, tracing JIT

[DONE] TODO: edit Higgs page on pgw, add supported features list
- Objects
- Arrays
- Closures
- Variadic functions
- For/while/do loops
- If/switch statements
- UTF-16 strings
- Integer and floating-point arithmetic
- Redefinable arithmetic operators
- Garbage collector

[DONE] TODO: remove GC output during unit tests

[DONE] TODO: garbage collecting string table
- don't forward string table, just re-alloc with same size
- after scan, remove strings table entries without a next pointer
  - need to rebuild table, reinsert strings
  - rebuild from old table
- strcat unit test

[DONE] TODO: remove stack slot init to undef, make it implicit?
- move from push to callFun

[DONE] TODO: make next ptr first field in all layouts
- init next ptr to null
- header is second field
- have GC traverse next pointers in objects

[DONE] TODO: beef up clos alloc test

[DONE] TODO: obj alloc test

[DONE] FIXME: stackvm test, segfault
- allocation completes
- crash after alloc in op_call_new

[DONE] FIXME: deepstack... Stack ref, object not in from-space heap
- collect called manually, not in the middle of anything...
- invalid object is all zeros?
- pointer appears to be from old from-space (zeroed out)
- clearing stack slots on push seems to remove problem
- Temp slots don't get initialized!

[DONE] FIXME: graph test, second collection fails, cannot copy in to-space, heap limit exceeded
- object size is corrupted (by previous GC?)
- happens during op_heap_alloc
- crash during "visiting stack roots"
  - probably, some stack object or stack ref is corrupt
- setting slots to undef on push and pop does not fix the problem
- inserting/removing prints can make the bug disappear...
- layout type of faulty object is closure...
  - object is near boundary of from-space

[DONE] TODO: implement GC count variable, IR instruction

[DONE] TODO: make programs/gc/graph.js run

[DONE] TODO: repeated closure allocation test
- closure in loop
- call closure to test

[DONE] FIXME: heisenbug with repeated closure alloc
- call to non function

[DONE] FIXME: repeated closure allocation produces segfault
- Failure probably occurs during newClos

[DONE] TODO: implement proper shrinkHeap

[DONE] FIXME: heap corruption during collection
- println fails, unhandled type in toString
  - link table problems?

[DONE] TODO: implement heap resizing for GC tests

[DONE] TODO: gc arrays test

[DONE] TODO: while manipulating references in interp, push refs to be saved on stack
- [DONE] setProp 
- [DONE] newObject
  - pay special attention to arguments
- [DONE] interp/string.d
- [DONE] setProp callers
- [DONE] throwError
- [DONE] op_call_new
- [DONE] op_new_clos

[DONE] TODO: eliminate ppClass in newExtObj? How useful is it really?
- Not that important!

[DONE] TODO: store ValuePair in stack root
- Multiple helpful constructors
- Assignment operators

[DONE] TODO: implement stack root system
- use special pointer container object, struct w/ destructor (implement in gc.d)
- object can be linked in doubly linked list

[DONE] TODO: revert to-space alloc code

[DONE] TODO: collect in function test

[DONE] TODO: $ir_gc_collect instruction

[DONE] TODO: get heap size instruction
- $ir_get_heap_size

[DONE] TODO: gcCollect after library loading

[DONE] TODO: gcCollect in middle of library loading

[DONE] TODO: first GC test, call gcCollect after interp init?

[DONE] FIXME: forwarding the same address many times over?

[DONE] TODO: function to allocate to-space
- Check if not allocated in gcCollect, if so allocate

[DONE] TODO: when allocating and running out of space, alloc to-space?
- Can keep allocating in from-space as well!
- Have a special function to check if to-space is allocated, allocate to it

[DONE] TODO: move heapAlloc to interp/gc.d

[DONE] TODO: scan link cells during GC
- Scan as roots

[DONE] TODO: layout_visit_gc(o) dispatching fn

[DONE] TODO: GC obj traversal functions
- Do a get on fields, call gcForward, set the result
  - word/type pairs slightly problematic?
    - if tpField set, call special function to forward

[DONE] TODO: remove array functions from objects.d, maintainability hazard

[DONE] TODO: init object properties and array elements to undefined for now

[DONE] TODO: unit test for obj field init
- Two objects from one class, one with a specific field, one without
  - Second one should come out undefined

[DONE] TODO: word field in object/array/cell should be annoted with type field name
- type field should be resolved

[DONE] TODO: layout_sizeof(o) dispatching fn
- Easy to implement, do this automatically
- obj_get_header(o)

[DONE] TODO: Forwarding pointer in layout
  layout_get_next(o)
  layout_set_next(o, p)
- Set special header flag (top bit), store forwarding pointer after header
- Can write these functions in D if desired

[DONE] TODO: layouts, enforce alignment of fields to field size

[DONE] TODO: implement visitStackRoots

[DONE] TODO: port gcCopy, gcForward

[DONE] TODO: complete port of gcCollect

[DONE] TODO: call gcCollect in heapAlloc function

[DONE] TODO: copy over relevant Tachyon GC code

[DONE] TODO: Make sure pointers are initialized to null
- Unless immediately initialized, init pointers to null

[DONE] TODO: create interp/gc.d

[DONE] TODO: create IRFunction ptr word type tag
- Update in layout.py as well

[DONE] TODO: store ctor class ptr on closure obj?
- refptrs

[DONE] TODO: no more ptr caching in instr/IRFunction, no ptrVal instr arg type

[DONE] TODO: modify opNewClos to use link table entries

[DONE] TODO: use new arr alloc in IR->AST

[DONE] TODO: use new obj alloc in IR->AST

[DONE] TODO: implement newClos in runtime.js
- Issue: need to get IRFunction ptr, add to ref table
  - Special instruction for this?

[DONE] TODO: GET_FUN_PTR
interp.funRefs[cast(void*)fun] = fun;
- GET_FUN_PTR <irfunction>
- Takes ptr, add fn to ref table, produces raw ptr

[DONE] TODO: implement newArr in runtime.js
- Improve Array ctor, use newArr

[DONE] TODO: implement newObj in runtime.js

[DONE] TODO: instructions to access link table
- make_link "name"
- get_link
- set_link

[DONE] TODO: make SET_STR alloc a link table cell internally
- Store cell index in arg
- Add new arg type

[DONE] TODO: add wLinkTable, tLinkTable to interpreter
- Allocate in constructor using malloc
- Have list of free link table entry indices
- Function to get a new link table entry index

[DONE] TODO: create $rt_toNumber
- Used in number constructor

[DONE] FIXME: programs/sunspider/math-spectral-norm.js
interp.interp.RunError: invalid base in property write
- Var statement is parsed incorrectly...
  - Only first identifier is resolved, rest goes in init expression
 - Make a parser unit test

[DONE] FIXME: programs/sunspider/bitops-nsieve-bits.js 
global prop unresolved $rt_not
- Add unit test

[DONE] TODO: float to string support, can't print floats right now!
- expose f64_to_str instruction
- Unit test

[DONE] TODO: can we run more benchmarks? Yes
bitops-nsieve-bits  14.5
math-spectral-norm  3.28
math-partial-sums   10.4
3d-morph            6.07
access-nsieve       8.46
access-fannkuch     33.0

[DONE] TODO: Math.log, Math.exp, Math.pow, Math.ceil, Math.floor, expose as instrs
- Too early to try optimizing this, beat libraries

[DONE] TODO: remove exec flag from heap

[DONE] FIXME: stdlib/math.js, second parse gave different result
    if (term < 1E-15)
        break;
- Add parser unit test, fix

[DONE] TODO: blog post about state of Higgs, features supported, upcoming
- Ask for help, Math.js, anything else?
  - be specific
- Simple JS FFT benchmark?

[DONE] TODO: use exceptions in op_call
- Throw exceptions on error, e.g.: call non-function
- Lookup global exception constructor
  - If avail, create deriv obj from prototype
  - If not avail, throw message string
- Need to run throw logic

[DONE] TODO: catch RunError instances in repl, print stack trace

[DONE] TODO: make stdlib/error.js work

[DONE] TODO: stack trace
- KISS for now, accumulate stack trace in throw

[DONE] TODO: test basic interprocedural try/catch

[DONE] TODO: implement stack unwinding, RunError
- Uncaught exception throws D exception

[DONE] FIXME: infinite loop when generating exc path for runtime calls?
- Infinite loop in compiling finally statements
  - string concat in finally stmt
  - finally stmt has itself in finally list? WRONGE!

[DONE] TODO: exception codegen for call / call_new
- If there is no englobing try/catch and no englobing finally, do nothing special
- If there are englobing finally blocks, need to compile those on exception path
  - After these are compiled, jump to try catch if present, otherwise do interp throw
- Prototype with call

[DONE] TODO: throw from within catch, no catch block, but should trigger finally block
- Could we use getFnlStmts, just use first fnl block?
- make test, finally_throw.js

[DONE] TODO: implement finally support in break/continue
- accumulate finallys until target? can pass list ref as argument to ctx fn
  - compile from inner to outer

[DONE] TODO: implement finally support for return
- find all englobing finally statements
  - compile from inner to outer
- test with finally_ret.js

[DONE] TODO: test intraprocedural throw
- throw_intra.js

[DONE] TODO: basic catch block compilation, ir/ast.d

[DONE] TODO: import some Tachyon stdlib tests (e.g.: boolean)

[DONE] TODO: make String ctor work

[DONE] TODO: make array toString/join work

[DONE] TODO: make new Array(len) work
- Needs arguments object
- unit test
- nqueens test?

[DONE] TODO: make Math.max work

[DONE] TODO: instructions to get arg count, access args

[DONE] TODO: refactor calling convention, call instr will:
  ra, clos, this, argc, args.., ...padding...
- pad with undef for missing args
- push args in reverse order
- push local slots
- ret pops local slots, pops args based on argc, pushes ret val

[DONE] TODO: employ closures to implement Math.random RNG
- Keep the RNG simple, KISS!

[DONE] TODO: use subCtx when creating managing clos cells at function init, save temps

[DONE] TODO: unit test closures more thoroughly
- Tachyon closure tests

[DONE] FIXME: variable resolution
- Currently, after nested function has had its defs added, resolve them
- This seems wrong, need to finish parsing parent functions
- Do a recursive resolveRefs pass at the end?
- Problem: all the scope objects are lost! god damnit.
- Alternative: find all decls at one level before trying to resolve
  - Can just resolve immediately instead of calling resolveRefs

[DONE] TODO: gen code for closure cells
- grab unit tests from Tachyon
- cellMap: maps symbols to closure cells
  - in our case, symbol -> local slot of clos cell
- Creating closure objects, set their cells

[DONE] TODO: allow not having return slot in call instr

[DONE] TODO: resolve captured (closure) vars in parser/vars.d
- In Tachyon, fun.captVars vs fun.escpVars
- captVars: captured from other functions
- escpVars: escaping to nested functions

[DONE] TODO: closure cell layout
- Extra properties after object fields

------------------------------------------------------------------------------

[DONE] TODO: improve valToString

[DONE] TODO: fix AST bracketing (curly braces)?

[DONE] TODO: support for "in" operator

[DONE] TODO: implement instanceof operator (used by stdlib/string)

[DONE] TODO: array prototype object

[DONE] TODO: implement Function.toString()

[DONE] TODO: create fun proto obj in interp?
- Corresponding access instruction

[DONE] TODO: function IR dump, log arg slots

[DONE] TODO: $ir_get_ir_str, $ir_get_ast_str?
- Useful for implementing function toString
- Useful for debugging!

[DONE] TODO: eliminate opSetProp, opGetProp

[DONE] TODO: make ast IR gen use prop access runtime functions

[DONE] TODO: implement getProp, setProp in runtime
- array.length property access
- string indexing access
- Don't need to compute hash code, already computed in strings

[DONE] TODO: implement switch stmt code gen

[DONE] TODO: way to test for null pointer
- Make null constant an actual zero null pointer (refptr)

[DONE] TODO: set_value
- Takes word and type inputs

[DONE] TODO: eq_u8
- Useful for layout type comparison

[DONE] TODO: basic throw instruction support, make it stop interpreter

[DONE] TODO: add global undefined property

[DONE] TODO: interp/objects.d
- Object manipulation primitives
- Keep that code alive

[DONE] TODO: SET_GLOBAL, GET_GLOBAL
- D string argument
- Implement global prop slot caching
- Test speed of bitops-bitwise-and
  - About 10x faster

[DONE] TODO: boolean negation !
- Probably want to inline code sequence?
  - Better compatible with genBoolEval
- Unit test this

[DONE] TODO: finish replacing basic operators with runtime functions
- eg: +=, *=, ...
- Remove corresponding high-level instrs

[DONE] FIXME: genAssign, incompatible with rt fun calls
- Pass delegate function instead

[DONE] TODO: I64/F64 conversion instructions

[DONE] TODO: interp cycle count?
- bitwise-and => 3.72M cycles
- will be less cycles once we have GET_GLOBAL
- currently look through 170+ property names in linear search!

[DONE] TODO: complete bitwise op runtime functions

[DONE] TODO: complete runtime comparison primitives

[DONE] TODO: IIR improvements, eliminate need for $ir_jump_false
- Clearer, more concise!
- genBoolEval? Treat IIR differently

[DONE] TODO: implement/test $rt_toBool
- Before: bitwise and takes 5.97s
- After: bitwise-and takes ~24.6s
- Time probably dwarfed by global lookups

[DONE] TODO: interp file loading
- useful for testing/timing benchmarks

[DONE] TODO: make typeof use runtime function

[DONE] TODO: run controlflow-recursive in unit tests

[DONE] TODO: $rt_eq

[DONE] TODO: assertBool

[DONE] TODO: begin using runtime system for arith ops
- Works for add, make test time seems unaffected

[DONE] FIXME: GC bug redux
- Reference IRFunction in fun table instead of AST
- AST has no pointer to IRFunction

[DONE] TODO: insertRtCall(IRGenCtx ctx, string fName, LocalIdx[] argLocals)
- Current impl uses many IR instrs

[DONE] TODO: JS file tests, import some from Tachyon

[DONE] TODO: comma operator support, ir/ast.d
- Evaluates both expressions, returns second value

[DONE] FIXME: for (var i = 0; i < 1000000; ++i);
    object.Error: heap space exhausted
- SET_STRING allocates string every time

[DONE] FIXME: interpreter crash in unit test
  $rt_toBool('foo')? 1:0
- Crash may or may not happen if source is modified...
- May be related to D GC
  - What if a function we need was randomly collected...?
    - AST or IR collected
- Closure objects keep refs to ASTs
  - Need to keep a function table in interp
- Seems fun.ast has been freed by interp!
    write(core.memory.GC.addrOf(cast(void*)fun.ast));
- Add function reference table in interpreter

[DONE] TODO: Math.pow for integers

[DONE] TODO: $rt_div

[DONE] TODO: $rt_mul

[DONE] TODO: Math.sin, Math.cos, Math.sqrt

[DONE] TODO: cos, sin, sqrt instrs
- Needed for math lib

[DONE] TODO: add interp loadStdLib flag, load stdlib/math.js

[DONE] TODO: $rt_toBool

[DONE] TODO: REPL, don't print if undefined

[DONE] TODO: $ir_print instruction, for debugging
- Use in runtime print function :)

[DONE] TODO: complete $rt_toString

[DONE] TODO: complete $rt_add

[DONE] TODO: complete $rt_strcat

[DONE] TODO: complete $rt_intToStr

[DONE] TODO: GET_STR instruction

[DONE] TODO: heap_alloc instruction
- Unit test w/ load/store

[DONE] TODO: complete low-level arithmetic, bitwise instructions
- Template with mixin

[DONE] TODO: Design Link table
- Part of interpreter, statically allocated, unmoving, contiguous
- primitives to manipulate this (get, set), take a unique id number
- wLinkTable, tLinkTable
- What problem are we trying to solve?
  - For getString: want to link a string object pointer
  - For callNew: want to link a class pointer, different for each callee
  - For newClos, newObj, newArr: want to link a class pointer
    - Two pointers for newClos, closure *and* prototype
  - Want the GC to have easy, fast access to these slots!
- MAKE_LINK instr can give us link cell index (need index, otherwise 2 pointers)
- Want to be able to allocate slots lazily
- JIT may need to link constant objs too. Can be done at compilation time.
- Instrs needing global obj, obj proto?
  - Can have host primitives for this, access through interp object ***
- make_link "classptr", produces index to cell

[DONE] TODO: $rt_typeof
- Will need access to header type field

[DONE] FIXME: obj_get_header not working

[DONE] TODO: Generate runtime functions for layout alloc

[DONE] TODO: Define layout type constants

[DONE] TODO: implement new layout system, layout.py
- Declarative layouts in a list
- add make layout makefile entry
- Generate ASTs from layouts (simple ASTs)
  - For JS, auto add $rt_ prefix to every function name
- Generate D and JS source from ASTs
- layout.d, layout.js

[DONE] TODO: Interp.evalString(string str, string fileName = "string")?
- Use to load layout code

[DONE] TODO: eq_i32, lt_i32

[DONE] TODO: add_i32, mul_i32

[DONE] TODO: load/store instrs
- load_i32, ptr, offs
- simple template for op fun generation

[DONE] TODO: is_refptr, is_const

[DONE] TODO: initial $rt_add runtime function

[DONE] TODO: ftoi instruction, I32_TO_F64

[DONE] TODO: add_i32_ovf, add_f64
- unit test

[DONE] FIXME: branchy IIR, need assignment support

[DONE] TODO: is_int, is_float, is_refptr type test instrs
- Do we ever need to compare type tags? Probably not

[DONE] TODO: implement member call in AST->IR, needed for $rt_toString

[DONE] TODO: test $rt_toString runtime function

[DONE] TODO: branchy IIR syntax: if (%...)

[DONE] TODO: special syntax for inline IR, with % sign (make special unary op?)
- Could just use $iir_ syntax, KISS!
- Normal IIR is a function call expression
- Test in shell

[DONE] TODO: Create extensible table of inlinable IR instructions for IIR access

[DONE] TODO: Create interp/runtime.js file, parse/run this at interp startup

[DONE] TODO: interp.exec(AST), interp.load(file)

[DONE] TODO: integrate SET_ARG into call
- Would make for shorter IR if we call into primitives
- 2 instructions per primitive call could be alot
- constant argument: set_int, then set_arg, kind of retarded!
- setArg is fragile anyways

[DONE] TODO: No more MAX_ARGS for instrs. Var arg system.

[DONE] TODO: Add instruction branch target field
- Refactor branch instructions

[DONE] TODO: Eliminate get_ret and the likes!
- RA is call instr
- Problem: Interp loop sets next instr before call
- Doesn't matter, call/return sets next instr anyways

[DONE] TODO: instr, add IRFunction ptr,
- get rid of raSlot, numLocals in RET, PUSH_FRAME
- Better for supporting exceptions, stack traces!

[DONE] TODO: array unit tests

[DONE] TODO: Modify getProp/putProp
- Look at Tachyon code, port over
- Modify underlying getProp, or higher level?
  - setArrElem assumes array, no toObject
  - go with Tachyon approach, simplify lower level fns

[DONE] TODO: rename confusing len fields in layouts

[DONE] TODO: make type objs in class rawptr, will be host objects

[DONE] TODO: implement opNewArr

[ODNE] TODO: array literal AST->IR

[DONE] TODO: NEW_OBJECT, remove proto local
- Only used for object literals
- stdlib will use custom host functions where needed

[DONE] TODO: array object & array table layout
- Should have array table field for array objects

[DONE] TODO: refactor layout system
- genLayouts
- Auto-generate layout type ids, define constants
- Auto-add type field as first layout field
- Add default field initializers (eg: init next to null)
- Layout extension

[DONE] TODO: alloc min size on closures, proto object
- Test adding many properties to fn.prototype

[DONE] TODO: implement object extension
- Need to handle closures and arrays too!
- Need to define type tags
- Modify getProp to follow next link chain

[DONE] TODO: implement type tags into layout system
- Define as uint32 in layout.d, make enum
- Type should be auto initialized on allocation
- Remove _set_type calls

[DONE] TODO: GET_RET_NEW
- ISSUE: need access to the this object passed to the call!
- Push a hidden this argument on the stack?
- Could have CALL_NEW produce this object in output slot, do explicit
  coupling between CALL_NEW and GET_RET_NEW?
  - Seems reasonable?
- Unit tests for new operator

[DONE] TODO: fix this binding resolution

[DONE] TODO: do proto lookup in opCallNew

[DONE] TODO: prototype chain support in lookup
- Test that missing props evaluate to false

[DONE] TODO: simplify class system, allocate proto slot, all property slots for now!

[DONE] TODO: create proper closure in opNewClos, fix opCall
- Test properties on function objects

[DONE] TODO: closure layout
- Needed for functions to have .prototype
- Cannot concat new props on prop array at compile time...
- Want list of closure cell pointers, function pointer

[DONE] TODO: opNew, AST->IR for new

[DONE] TODO: FP less-than comparison

[DONE] TODO: basic floating-point support
- assertFloat w/ epsilon

[DONE] TODO: Interp.getSlot/Interp.setSlot with ValuePair
- Use to simplify code in interp/ops.d

[DONE] TODO: object literal support w/ unit tests

[DONE] TODO: opSetProp

[DONE] TODO: implement opNewObj
- Lazily create new object class?

[DONE] TODO: make alloc set size fields automatically

[DONE] TODO: auto-generate alloc layout method taking interp as parameter

[DONE] TODO: AST->IR for indexed operations, property access

[DONE] TODO: object literal AST->IR

[DONE] TODO: typeof operator
- IR, AST->IR

[DONE] TODO: string concatenation

[DONE] TODO: Implement getString, replace uses of makeString by getString

[DONE] TODO: string table extension

[DONE] TODO: Interpreter method to get a string from the table

[DONE] TODO: alloc initial string table
- allocStrTable(Interp*)

[DONE] TODO: string hash code computation

[DONE] TODO: string table layout
- len
- num_strs

[DONE] TODO: interp/string.d

[DONE] TODO: interp/ops.d

[DONE] FIXME: many moves are unnecessary
- Moving a value into the output slot, just to transfer the value
- Possible fix: add setOutSlot again

[DONE] TODO: ability to prescribe output slot to sub-context

[DONE] TODO: test unary plus, minus operators

[DONE] TODO: in-place operators, +=, -=, etc.
- Issue: "a[f()] += 1" is not "a[f()] = a[f()] + 1"
  - Don't want to evaluate f twice
- TODO: check in what order V8 evaluates lhs, rhs?
  - lhs, then rhs
- Try passing IR instr to assgToIR for in-place operators

[DONE] TODO: revise ast-to-ir design, currently hard to debug&maintain
- context/sub-contexts interfere with each other in unpredictable way
- out slot should be allocated in current context too, to avoid collision
- should eliminate desired out slot/set out slot mechanism?
  - inserts confusing invisible moves!
  - every expression allocates an output temp for itself
- favor simpler, more robust design!
- When creating sub-ctx, decide if it has output or not
  - If it has output, allocate out slot immediately

[DONE] TODO: fix class desc, prop idx instead of woffs/toffs

[DONE] TODO: test global function declarations

[DONE] TODO: test global var statement

[DONE] TODO: global var unit tests

[DONE] TODO: basic SET_GLOBAL, GET_GLOBAL interp implementation

[DONE] TODO: SET_GLOBAL, GET_GLOBAL IR instructions + IR gen
- opSetGlobal, opGetGlobal?

[DONE] TODO: allocate global object in interpreter init function
- Also need to allocate global class
- Also need to initialize both objects
- Make room for 512 properties

[DONE] TODO: finalize initial object layout, class desc layout
- Start with simple layouts
  - V8 uses at least 3 extra words per object, if not more!

Objects have:
- Header
- Num fields
- Class ptr
- Next ptr
- Prop words
- Prop types
- Proto is property 0

Arrays are objects with special properties:
- array table
- length, capacity

Functions are objects with special properties:
- fn ptr slot (raw ptr)
- fixed number of closure vars (can be named)

Class desc:
- Needs next pointer too, so we can add new fields if needed

[DONE] TODO: IR gen for logical and, logical or
- More unit tests

[DONE] TODO: implement/test string concat

[DONE] TODO: implement SET_STR in interpreter
- Lazily allocate strings in the interpreter?
- Unit test this

[DONE] TODO: instr implementation functions
- instr type objects, rename to opcode
- Have pointer to implementation function
  - implementation takes interp state pointer as input

[DONE] TODO: merge Interp and State, no need for two classes

[DONE] FIXME: crash bug, taking address of function wrong

[DONE] TODO: implement string constant IR gen

[DONE] TODO: think about object layout/format further
- Object needs next ptr, otherwise can't reallocate more space
  - Only needed when writing past num fields
- Simple approach might be best!

[DONE] ISSUE: reading field from object, always need to check next pointer...
- Never know that object is big enough to have this field
- Unless class has special "all conforming" field?
  - All pointers to old objects eliminated during GC
- Result: as soon as a new field is added to one object, class is expanded, 
  not all conform (unless only one object of this type), any JITted using this
  class code must be recompiled not to assume next is null
- Global object: if preallocated large, can stay conforming

[DONE] TODO: SET_STR instruction
- Have string + ref/ptr val, not yet allocated?
- Note: string references exist outside the heap

[DONE] TODO: rename REF to REFPTR

[DONE] TODO: interp/layout.js
- genLayout(), test with mixin immediately, print output

[DONE] TODO: heap memory block
    import core.sys.posix.unistd, core.sys.posix.sys.mman;
    PROT_READ | PROT_WRITE | PROT_EXEC;
    auto mem = mmap(null, length, flags, MAP_PRIVATE | MAP_ANON, -1, 0);
    if (mem == MAP_FAILED)
        return null;
    return cast(ubyte*)mem;
- Must be executable ***
- State should allocate a ubyte array for the heap. Must be immovable.
- Alloc ptr is bumped and aligned (see previous gc code)

[DONE] TODO: break, continue IR gen
- When entering IR gen for a loop, associate labels with break, continue blocks
  in the current context.
- Make a context function for this, pass a statement, the break and continue blocks
- Make a context function to do a recursive break or continue target lookup

[DONE] TODO: break, continue with and without label in parser

[DONE] TODO: label support in parser
    LabelledStatement :
        Identifier : Statement
- Store a list of labels on the statement
- Try with backtracking, see how speed is affected

[DONE] TODO: IR gen for cond ? expr

[DONE] TODO: IR gen for post incr., decr

[DONE] TODO: IR gen for do-while loop

[DONE] TODO: IR gen for for loop

[DONE] TODO: Interpreter while loop test

[DONE] TODO: repl, if ExprStmt, transform into ReturnStmt?

[DONE] TODO: repl, output to string?

[DONE]FIXME: handle incorrect argument counts, currently crashes
- add unit tests

[DONE] TODO: state.move function

[DONE] FIXME: IR function args printing

[DONE] TODO: test fib

[DONE] TODO: test fact?

[DONE] TODO: ValuePair to string

[DONE] TODO: test lt comparison

[DONE] TODO: test branching

[DONE] TODO: implement JUMP, JUMP_TRUE, SET_TRUE, BOOL_VAL instructions

[DONE] TODO: implement CMP_LT comparison instruction

[DONE] TODO: test local var assignment

[DONE] TODO: parameter passing

[DONE] TODO: function calls, return global call
- unit tests

[DONE] TODO: unit tests for global expr return

[DONE] TODO: basic interpreter loop
- Capable of evaluating global expr

[DONE] TODO: calling of top unit-level functions in interpreter
- Interp.run(ASTProgram) ?
- Interp.getRet() ?

[DONE] TODO: PUSH_FRAME call at start of function

[DONE] TODO: start implementing simple interpreter
- Could cheat, closures as IR fn ptrs
- Interpreter state structure
  - Double stack system, two base pointers, two top pointers
  - IR instruction pointer
  - heap allocPtr?

[DONE] TODO: auto name unit functions
- use delegate, map?

[DONE] TODO: reverse local indices after IR gen?
- Issue: want to use stack pointer, not base pointer
- Need to know how many locals there are
- Highest local becomes index 0, top of stack

[DONE] TODO: IR gen, map hidden args in local map

[DONE] TODO: IR gen for closures of nested functions

[DONE] TODO: use IR function in new_clos IR

[DONE] TODO: look at IR for global call

[DONE] TODO: IR gen for function call

[DONE] TODO: IR gen for function expressions

[DONE] Call protocol ISSUES:
- Many hidden args (closure, this, nArgs, RA)
- Should we push all after normal args? Practical, may be problematic if frame resizing needed
  - Not a problem for the JIT if call is inlined (most calls can be?)
  - Not a problem if no resizing!
- Would want call instr to take exception block arg?
  - Technically, this can be some annotation per return address for a function!

Stack frame layout (grows down):
        arg0
        arg1
...
        argN
        closure (pushed by call)
        this    (pushed by call)
        nArgs   (pushed by call)
        RA      (pushed by call as raw pointer)
...
SP+2    local
SP+1    tmp
SP+0    tmp

[DONE] TODO: IR instructions for call protocol

[DONE] FIXME: resolve vars in assign lhs exprs?

[DONE] TODO: pretty print of expressions with less parentheses
- Can parenthesize sub-expressions
- When do we need parentheses?
  - Parent has higher precedence: (x + y) * z
- getPrec function, returns highest by default (atomic)

[DONE] TODO: IR gen for while statement

[DONE] TODO: float expr

[DONE] TODO: IndexExpr, merge with dot operator to simplify AST
- create string expr from ident

[DONE] TODO: IR gen for VarStmt

[DONE] TODO: code gen for if statement

[DONE] TODO: IR for undef constant, return undef by default

[DONE] TODO: decide on IR generation strategy.
- Current code generation strategy:
  - Create codegen context for sub-expressions
  - Can specify an output slot (where the sub-expression should store its output)
  - Sub-expression can specify it already has a slot, move inserted if needed
  - Sub-expression can get a slot allocated for its output if none was specified
- What is problematic about this approach? How can we fix it?
  - Need more higher-level constructs, simplifications for common operations

[DONE] TODO: unary negation code gen

[DONE] TODO: look at Marc's simple C compiler. It uses a stack machine.

[DONE] TODO: for-in statement parsing
- need to make work with regular for statement
- if there's no var, we know it's an expression
- could parse whole expression, see if it's an "in" expression ***?
- if starts with var, parse following expression
  - check if expr is "in" expression
  - can't parse as real var statement...
- for var ... in, could try peeking ahead more

[DONE] TODO: peekSep, peekKw

[PASS] TODO: IR, fuse compare and jump
- Uselessly complicates IR->AST translation

[DONE] TODO: optional catch clause

[DONE] TODO: try parsing stdlib

[DONE] TODO: fix sunspider/3d-raytrace parsing/toString bug

[DONE] TODO: decide on boxing scheme
- Scraping float bits for tagging is problematic
- x86 has (all valid in 64-bit):
    CMP r/m8, imm8 : two-byte instruction
    MOV r/m8, imm8 : two-byte instruction
    MOV r8,r/m8     : 2 bytes?
    MOV r/m8,r8     : 2 bytes?
- With double wrappers, don't need to query objects about their type!
- ASM microbenchmark?
  - Performance indistinguishable between one vs two stack
    pointers, separate type array or not
- "Representing Type Information in Dynamically Typed Languages"
  - Had mostly good things to say
  - Seemed to assume that the only "large-wrapper" option is two words
- Separate tags may have advantages for instr level parallelism (ILP)

[DONE] TODO: adapt parser code
- [DONE] fix operator precedence, operator table
- [DONE] new operator
- [DONE] function syntax, missing fn name
- [DONE] object literal syntax
- [DONE] string literals with single quotes
- [DONE] source should be processed as wstring, UTF-16
- [DONE] string expr should store wstring
- [DONE] hex/unicode string escapes
- [DONE] hex number support
- [DONE] variables, one scope per function
- [DONE] functions, find fn decls in scope
- [DONE] variables, multiple decls per statement
- [DONE] optional semicolon for expression statements
- [DONE] test empty statement
- [DONE] multiline string continuation
- [DONE] re-parse test
- [DONE] optional semicolon for var statement
- [DONE] optional semicolon for return and throw
- [DONE] fix bug with crypto benchmark, do diff
- [DONE] break, continue statements
- [DONE] switch statement, as if cascade
- [DONE] more unit tests
- [DONE] real JS code unit tests, sunspider benchmarks
- [DONE] reverse operator precedence numbering
- [DONE] implement comma operator

[DONE] TODO: put project on github

[DONE] TODO: create Higgs project folder, move code

[DONE] TODO: how many benchmarks can we run with this? Need 2-5 (easier first)
- access-binary-trees, new operator
- math-spectral-norm, uses FP
- math-cordic, uses FP
- access-fannkuc, uses arrays
- access-nbody, uses FP math, arrays
- navier-stokes, uses arrays, FP math
- string-base64, uses strings, arrays
- crypto-*, strings, arrays
- crypto (V8), strings, arrays, math, new
- richards
- splay
- deltablue, uses .call
- raytrace, uses .apply, arguments as object, object literals, FP math
- earley-boyer, uses .call, .apply, arrays, strings
- some of the new octane ones might be feasible (non-DOM ones)

